Perfect. I’ll go through all of Edgar F. Codd’s available primary works — from his landmark published papers to his IBM research reports, books, and any transcripts or interviews where he lays out his vision. I’ll create a longform, thematically organized, deeply annotated journalistic essay that digs into his original language and ideas, quoting heavily and structuring it in rich, narrative form.

Give me a bit to put together a detailed and immersive synthesis of the mind that invented the relational model.

# The Relational Sage: Edgar F. Codd in His Own Words

## Data, Independence, and the Relational Model’s Genesis

In June 1970, a quiet revolution began with a bold opening line in the **Communications of the ACM**. “Future users of large data banks must be protected from having to know how the data is organized in the machine (the internal representation)” ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=Future%20users%20of%20large%20data,in%20query%2C%20update%2C%20and%20report)), wrote Edgar F. “Ted” Codd, an Oxford-trained mathematician at IBM’s San Jose Research Laboratory. Codd’s insistence on *data independence* – the idea that users and programs should be shielded from the messy details of how data is stored and structured – set the tone for a new theory of data. In that seminal paper, dryly titled “A Relational Model of Data for Large Shared Data Banks,” Codd lays out his vision for a **relational model** that would uncouple the logical world of information from the physical hardware details. *“Activities of users at terminals and most application programs should remain unaffected when the internal representation of data is changed and even when some aspects of the external representation are changed,”* he elaborated ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=Future%20users%20of%20large%20data,in%20query%2C%20update%2C%20and%20report)). In other words, programs shouldn’t break or need rewriting just because the data’s storage format or access path changed; a sweeping departure from the status quo of the 1960s.

At the time, databases were dominated by hierarchical and network systems (notably IBM’s IMS and the CODASYL network model) that tangled the user’s view of data with *how* it was stored. Relationships were hard-coded as pointers, and getting information out often meant navigating a tree or graph of records in a predetermined way. As Codd observed, existing systems “provide users with tree-structured files or slightly more general network models of the data” ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=Existing%20noninferential%2C%20formatted%20data%20systems,consistency%20in%20the%20user%E2%80%99s%20model)). This required programmers to understand and manipulate *physical connections* – essentially chasing links between records – rather than simply stating the information they wanted. Codd found this state of affairs untenable. He had participated in many pre-1970 discussions on database management and “found those discussions altogether too fuzzy and imprecise” ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20First%2C%20let%20me%20defend,the%20mathematics%20of%20the%20subject)). The urgent need, in his view, was to introduce *precision and rigor* into data management, to transform it from a grab-bag of ad-hoc techniques into a principled discipline. *“The only way to do that,”* he later reflected, *“was to dip into the mathematics of the subject”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20First%2C%20let%20me%20defend,the%20mathematics%20of%20the%20subject)).

And dip he did. Codd brought the clear lines of set theory and logic to the amorphous problem of data organization. His relational model was rooted in the mathematics of relations – essentially tables of rows and columns – but it was motivated by a very practical goal: **unshackling data from its physical storage**. By modeling all data as tuples of values in relations, Codd aimed to let users declare **what** data they wanted without having to specify **how** to get it. It was a leap of abstraction that, as he quipped, many in industry initially found “too mathematical” ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Question%3A%C2%A0%20Let%20me%20congratulate%20you,to%20come%20to%20grips%20with)). But Codd would defend the mathematical precision of his approach vigorously: *“I found an urgent need to bring a lot more precision into the area…that paper’s ‘mathematical’ nature was really about being precise”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20First%2C%20let%20me%20defend,the%20mathematics%20of%20the%20subject)). Where others saw daunting theory, he saw a necessary exactitude – a way to eliminate the ambiguity and hidden complexity that plagued earlier systems.

Even the earliest formulation of the relational idea in Codd’s 1969 IBM Research Report (RJ599) had homed in on two bane-of-the-programmer issues: **redundancy** and **inconsistency** in databases. In the 1970 CACM paper, Section 2 was devoted to how relations could mitigate those problems ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=form%20for%20data%20base%20relations%2C,consistency%20in%20the%20user%E2%80%99s%20model)) ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=forms%20a%20sound%20basis%20for,from%20a%20logical)). Redundancy – storing the same fact in multiple places – leads to update anomalies and contradictions; Codd realized that a **normalized** relational design (where each fact is stored once) would naturally minimize such pitfalls. He warned of a “number of confusions” bred by the network model, “not the least of which is mistaking the derivation of connections for the derivation of relations (see… the ‘connection trap’)” ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=forms%20a%20sound%20basis%20for,from%20a%20logical)). The *connection trap* he mentions was a subtle but crippling problem in older models: you might correctly navigate pointers (connections) between records, yet misinterpret the *implied relationships* among the underlying data (the relations). By stripping data modeling down to its logical essence – data values and their associations, devoid of physical pointer-paths – Codd contended that one could avoid such traps entirely. The relational view, he argued, *“provides a means of describing data with its natural structure only – that is, without superimposing any additional structure for machine representation purposes”* ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=The%20relational%20view%20,of%20data%20on%20the%20other)). This was data *as itself*, freed from the baggage of how it was laid out on disk.

Codd’s pursuit of data independence was not merely academic idealism; it was fueled by an acute understanding of real-world needs. In his 1981 Turing Award lecture, he noted a “productivity crisis” in software development – end-user demand was outpacing programmers’ ability to deliver ([Relational Database: A Practical Foundation for Productivity, 1981](https://www.softwaregems.com.au/Documents/Article/Database/Relational%20Model/Codd%20E%20F/Relational%20Database%20Practical%20Foundation%20Turing%20Award.pdf#:~:text=normalization%20of%20relations,391)) ([Relational Database: A Practical Foundation for Productivity, 1981](https://www.softwaregems.com.au/Documents/Article/Database/Relational%20Model/Codd%20E%20F/Relational%20Database%20Practical%20Foundation%20Turing%20Award.pdf#:~:text=It%20is%20generally%20admitted%20that,processing%20departments%20to%20imple%02ment%20the)). Two complementary solutions were needed, he wrote: make it easier for non-programmers to directly interact with data, and boost the productivity of professionals by abstracting away low-level drudgery ([Relational Database: A Practical Foundation for Productivity, 1981](https://www.softwaregems.com.au/Documents/Article/Database/Relational%20Model/Codd%20E%20F/Relational%20Database%20Practical%20Foundation%20Turing%20Award.pdf#:~:text=Committee%20for%20his%20,development%20of%20one%20of%20the)) ([Relational Database: A Practical Foundation for Productivity, 1981](https://www.softwaregems.com.au/Documents/Article/Database/Relational%20Model/Codd%20E%20F/Relational%20Database%20Practical%20Foundation%20Turing%20Award.pdf#:~:text=E,contributions%20to%20the%20computing%20community)). A precisely defined data model could help on both fronts. As Codd later explained in an interview, the relational model *“started with the question, ‘How are people who know nothing about programming going to access or address data?’ Furthermore, if you could find an answer to that question we then asked why wouldn’t the answer also be good for application programmers.”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20The%20relational%20model%20started,be%20good%20for%20application%20programmers)) In this almost deceptively simple reversal, Codd put the *casual user* and the *professional developer* on the same plane. If databases could be made genuinely intuitive for the layperson, they would also become more efficient tools for the expert. This focus on ease-of-use – on a consistent, logical view of data for all users – is a motif that would recur throughout Codd’s work, from his early papers to his later rules for “fully relational” systems.

## The World in Tables: From Hierarchy to Relation

At the heart of Codd’s proposal is a seemingly mundane structure: the **table**. In Codd’s terminology, it’s a “relation,” an array of rows and columns in which each row represents a fact about some entity or relationship, and each column represents an attribute or field of that fact. This tabular metaphor had enormous consequences. It meant that the user’s mental model of the database could be uniform and simple: *everything looks like a table*. Gone were the hodgepodge of record types, set connections, owner-member links, and other paraphernalia that made navigating network and hierarchical databases such a specialized skill. *“One way to think of a relation,”* Codd explained, *“is that it is a highly disciplined flat file.”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20They%20are%20very%20similar%2C,relation%20in%20the%20relational%20model)) Unlike a pile of records in a flat file, however, a relation obeys strict rules: no ordering among its rows or columns carries any information, and every row is of the same format. *“Normally, with a flat file you are allowed to do several things that are not permitted in a relation,”* Codd told his 1982 interviewer. *“For example, the ordering of records in a flat file may be information-bearing… This is not true of a base relation in the relational model.”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Question%3A%C2%A0%20A%20point%20of%20clarification%3A%C2%A0,fields%20in%20a%20flat%20file)) If one were to shuffle the rows of a table or the columns within each row, the data’s meaning would not change – an almost heretical notion to designers accustomed to encoding information in the sequence of records or the positions of fields.

This discipline of the table – that a relation has no intrinsic ordering and no intermixing of heterogeneous records – was crucial to achieving data independence. It banished *positional addressing*. In older systems, you might refer to “the next record” or rely on record #17 having a special significance; in Codd’s system, you addressed data by its content. Codd introduced what he called **“associative addressing”** ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=long%20time%20,you%20a%20particular%20data%20item)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Normally%2C%20when%20you%27re%20dealing%20with,simple%2C%20completely%20associative%20addressing%20approach)): to find any atomic piece of information, you specify the table it resides in, the value of its primary key (to locate the right row), and the column name (to pick the right attribute) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20The%20approach%20of%20the,you%20a%20particular%20data%20item)). This is a simple three-part address, wholly independent of physical location. *“Who cares whether the table ‘Parts’ precedes the table ‘Suppliers’? Nobody,”* Codd quipped, driving home the point that in a truly relational system, the *position* of data is irrelevant ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=None%20of%20that%20is%20position,as%20far%20as%20I%20know)). *“With the relational model, you get down to this very simple, completely associative addressing approach,”* he said, noting that this capability is *“often completely overlooked when people compare different data models… It is a serious error.”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Incidentally%2C%20this%20associative%20addressing%20capability,it%20is%20a%20serious%20error)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=completely%20overlooked%20when%20people%20compare,it%20is%20a%20serious%20error)) The table, in Codd’s hands, became more than a storage format; it was a declaration of independence from the tyranny of pointers and paths.

Yet Codd was careful to emphasize that the relational model was more than just its *structural* aspect (the table format). He defined the model as having **three parts**: a structural part (data as relations), a **manipulative** part (operations on those relations), and an **integrity** part (rules governing valid data) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20I%20suppose%20the%20best,fidelity%20to%20the%20relational%20model)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=The%20relational%20model%20has%20three,part%2C%20but%20that%20is%20inaccurate)). *“It is often viewed as if it had only the structural part, but that is inaccurate,”* he cautioned ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20I%20suppose%20the%20best,fidelity%20to%20the%20relational%20model)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=The%20relational%20model%20has%20three,part%2C%20but%20that%20is%20inaccurate)). The full power of the approach only emerges when all three components work in concert. In practice, this meant that simply storing data in tables wasn’t enough; a system had to support a full set of high-level operations (like merging tables, filtering them, etc.) and enforce constraints (like uniqueness of keys or valid ranges of values) to truly qualify as relational. In a 1985 manifesto, Codd dryly noted that some products were calling themselves “relational” based solely on surface features. Such systems might have a table-like veneer, yet still force users to navigate via predefined links or to code around missing constraints. To Codd, these were pretenders. A genuine relational **DBMS**, he wrote, must be *“examined in terms of its fidelity to the relational model”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Question%3A%C2%A0%20How%20do%20you%20distinguish,relational%20one)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20I%20suppose%20the%20best,fidelity%20to%20the%20relational%20model)) – not just in how it stores data, but in how purely it adheres to the model’s principles of manipulation and integrity.

Codd’s own demonstration of fidelity to the relational idea came in the form of a small set of fundamental **operators** that could do everything one needed with data. He introduced operations like *project* (pick certain columns), *join* (merge tables based on common values), *restrict* (filter rows), and others – operations grounded in logic and set theory. In the 1970 paper, he sketches out these operators and notes how they can address redundancy and consistency problems ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=form%20for%20data%20base%20relations%2C,consistency%20in%20the%20user%E2%80%99s%20model)) ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=forms%20a%20sound%20basis%20for,from%20a%20logical)). By 1972, in a follow-up report titled “Relational Completeness of Data Base Sublanguages,” Codd formally defined a yardstick for database query languages: a language would be **relationally complete** if it could express at least all of these fundamental operations ([Collected Works of E. F. Codd](http://www.sigmod.org/publications/dblp/db/about/codd.html#:~:text=,1981)) ([Collected Works of E. F. Codd](http://www.sigmod.org/publications/dblp/db/about/codd.html#:~:text=,1971%29%20%2033%20BibTeX)). This was more than academic hair-splitting; it was Codd’s way of ensuring that the manipulative part of the model was powerful enough to free users from ever resorting to lower-level hacks. If you needed to traverse a pointer or loop record-by-record to get an answer, the language was not truly relational. As he put it plainly in an interview: *“Some [systems] deal only with the tables one row at a time… This is still not a relational system. It’s only when you have the capability of unrestricted ‘join’ between tables that you begin to get what I would call a minimum relational system”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=The%20relational%20model%20has%20three,part%2C%20but%20that%20is%20inaccurate)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=It%27s%20only%20when%20you%20have,comply%20with%20relational%20rules%20also)). Unrestricted join – the ability to combine any two tables by any matching values, without pre-established linkages – was, for Codd, the hallmark of relational power. It meant the user could ask any question that made sense in the data’s terms, not just those anticipated by a database designer’s hand-tuned pathways.

This emphasis on *set-oriented*, declarative data manipulation was a direct challenge to the industry’s prevailing mindset. Before relational systems, query languages (if they existed at all) were often seen as afterthoughts – “add-ons” to the real business of record-at-a-time processing ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20The%20major%20example%20is,on%27%20to%20the%20DBMS)). Codd turned that on its head: the high-level query capability was central, and it should subsume the one-record-at-a-time work as just a degenerate case. *“By contrast, in the relational approach, at least the data structures seen by the application programmer and those seen by the end user are identical,”* he pointed out, praising how some relational systems made their full query languages available for use inside programs ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=All%20application%20programming%20was%20done,the%20query%20capability%20and%20architecture)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=By%20contrast%2C%20in%20the%20relational,are%20examples%20of%20such%20systems)). This unification – one model, one language for all purposes – “greatly enhanced the communication between end-users and programmers” ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20The%20relational%20model%20started,be%20good%20for%20application%20programmers)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=nothing%20about%20programming%20going%20to,be%20good%20for%20application%20programmers)). The programmer no longer lived in a separate world with separate tools; both programmer and user could think in terms of the same relational structures and operations. Here again, Codd’s voice carries an undertone of almost egalitarian zeal: the castle walls between the keepers of data (IT staff) and the consumers of data (business users) were being leveled by the relational paradigm, enabling a common understanding.

Late in life, Codd reminisced that the relational model introduced not just a new way to structure data, but the very notion of a *data model* as a formal concept ([](https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/985420/about-EFCRT.pdf#:~:text=course%20of%20his%20career,1971)) ([](https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/985420/about-EFCRT.pdf#:~:text=%EF%81%AE%20%E2%80%9CRelational%20Completeness%20of%20Data,1974)). He often stressed the distinction between the model and its implementation, a separation still “regrettably widely misunderstood” according to one commentator ([](https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/985420/about-EFCRT.pdf#:~:text=1%20An%20epub%20version%20,find%20the%20result%2C%20though%20readable)) ([](https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/985420/about-EFCRT.pdf#:~:text=As%20everyone%20knows%2C%20the%20foundation,technology%20in%20general%2C%20over%20the)). In Codd’s own writings, this theme appears in his emphasis that a database user should not have to know if data is stored as hashing or indexed B-trees or sequential files – those are implementation details separate from the model the user interacts with. *“Data independence,”* a phrase that sounds abstract, in practice meant human independence: freedom for the user to focus on *meaning* rather than mechanics. And that, in Codd’s relational world, was accomplished by elevating the humble **table** to be the central abstraction of all data, and equipping users with a precise algebra to manipulate these tables.

## The Sublanguage of Truth: Relational Algebra and Calculus

Codd’s vision of a “data sublanguage” for relational databases was ambitious: he sought nothing less than a **substitute for computer programs** in the realm of data retrieval and manipulation. In 1970 he floated the concept of a “universal data sublanguage” ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=Existing%20noninferential%2C%20formatted%20data%20systems,consistency%20in%20the%20user%E2%80%99s%20model)), a high-level language in which one could express *every* operation needed on the data. He was inspired by the power of first-order logic (the predicate calculus) and abstract algebra. In fact, one of his great insights was that database queries could be seen as logical assertions (in a **declarative calculus**) or as compositions of algebraic operations on sets – and that these two views were equivalent in expressive power. By showing this, Codd built a bridge between theory and practice: the logical calculus was a way to declare *what* you want, and the algebra provided a way to actually compute it. In his 1972 article on relational completeness, he introduced **Relational Algebra** and **Relational Calculus** as dual formalisms and argued that any viable database language should map to one or the other (or both) ([](https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/985420/about-EFCRT.pdf#:~:text=%EF%81%AE%20%E2%80%9CDerivability%2C%20Redundancy%2C%20and%20Consistency,Nonprogrammers%3A%20The%20Relational%20and%20Network)). 

Interestingly, Codd didn’t immediately provide a concrete user-facing language in his early papers. Instead, he described an intended language named **Alpha** in abstract terms – a kind of blueprint for what a relational query language should look like. Alpha was never fully implemented, but it outlined features like selecting, projecting, joining, and dividing relations using a syntax inspired by mathematical logic. A few years later, teams at IBM (system R’s SQL) and elsewhere (UC Berkeley’s QUEL) would create actual relational languages, but Codd’s Alpha was arguably the first attempt to sketch such a language ([](https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/985420/about-EFCRT.pdf#:~:text=%EF%81%AE%20%E2%80%9CDerivability%2C%20Redundancy%2C%20and%20Consistency,Nonprogrammers%3A%20The%20Relational%20and%20Network)). He demonstrated, for example, how a simple query like “find the supplier numbers for suppliers who supply part P2” could be expressed in a relational calculus notation (a formula with existential quantifiers) and how an equivalent result could be obtained via relational algebra operations. The specifics of Alpha’s syntax aside, the enduring point was the **separation of logic and execution**: one declares a predicate or a set operation, and the system figures out the procedural details. 

Codd’s insistence on a rigorous linguistic foundation stemmed from his experiences with earlier systems where, as he lamented, query facilities were bolted on as a separate, often inconsistent component. *“Until the relational data base concepts came along,”* he noted, *“people used to regard query capabilities as an ‘add-on’ to the DBMS… All application programming was done record-at-a-time in one language… while all query was done in a different language… Little or no attention was paid to the query capability and architecture.”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20The%20major%20example%20is,on%27%20to%20the%20DBMS)). This bifurcation struck Codd as fundamentally flawed. It not only duplicated effort, but it meant that the integrity of the data could be compromised because one part of the system might bypass rules enforced in another. The relational approach, by contrast, was to have **one language to rule them all** – a single, coherent framework for both transactional updates and ad-hoc queries, for both naive users and expert developers. 

In his 1981 Turing Lecture, tellingly titled *“Relational Database: A Practical Foundation for Productivity,”* Codd argued that raising the level of abstraction (through relational languages) directly addressed the software productivity gap ([Relational Database: A Practical Foundation for Productivity, 1981](https://www.softwaregems.com.au/Documents/Article/Database/Relational%20Model/Codd%20E%20F/Relational%20Database%20Practical%20Foundation%20Turing%20Award.pdf#:~:text=A%20Practical%20Foundation%20for%20Productivity,contributions%20to%20the%20computing%20community)) ([Relational Database: A Practical Foundation for Productivity, 1981](https://www.softwaregems.com.au/Documents/Article/Database/Relational%20Model/Codd%20E%20F/Relational%20Database%20Practical%20Foundation%20Turing%20Award.pdf#:~:text=Committee%20for%20his%20,development%20of%20one%20of%20the)). By letting people state what they want in a non-procedural way, you reduce the amount of code they have to write and maintain. And by basing that language on sound mathematical footing, you ensure that what they write will behave predictably. *“If you examine DBMS’s that are not based on some clearly defined mathematical foundation, you find that the behavior of their structures gives a lot of surprises,”* Codd warned ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Question%3A%C2%A0%20Getting%20back%20to%20the,a%20benefit%20to%20the%20user)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20If%20you%20examine%20DBMS%27s,gives%20a%20lot%20of%20surprises)). He cited how early hierarchical systems started simple (a single tree) but grew unwieldy when users needed multiple hierarchies and ad-hoc linkages; their behaviors became hard to reason about ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Let%20me%20give%20you%20an,As%20such%20they%20were%20manageable)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=several%20hierarchies%20at%20once%20that,one%20another%20in%20various%20ways)). Those surprises were, in effect, the tax one paid for not having a precise model. The relational algebra and calculus were the antidote – they endowed the database with a kind of predictability and transparency. If a query is just a logical formula, one can more easily reason about whether it’s correct; if an operation is algebraically defined, one can analyze its effects in a formal way. This made it possible to build **query optimizers** – software that can transform one algebraic expression into an equivalent one that runs faster – a breakthrough that would soon follow in the 1970s, underpinning the performance of SQL databases. Though Codd himself did not invent the first query optimizer, it was his algebraic framework that made such optimizers conceivable.

Codd had an interesting relationship with **SQL**, the now-ubiquitous implementation of his ideas. SQL was born in IBM’s System R project in the 1970s, initially without Codd’s direct involvement. By the early 1980s, SQL was on the path to becoming a standard, yet Codd did not hesitate to critique it for deviating from relational purity. In private and public, he pointed out SQL’s allowances for duplicate rows and unordered results as compromises that muddied the relational model. *“It sounds a bit like sour grapes from those who lack the academic footing,”* he once replied to critics who dismissed relational theory as mere ivory-tower stuff, noting pointedly that *“the relational approach is becoming successful in the marketplace in spite of that alleged handicap”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Question%3A%C2%A0%20What%20do%20you%20say,applicable%20to%20the%20real%20world)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20I%20have%20two%20complementary,this%20criticism%20is%20really%20vacuous)). The success of SQL, to Codd’s mind, was proof that the underpinning relational ideas were robust – even if SQL wasn’t the perfect realization. In fact, one impetus for Codd’s famous **12 rules** in 1985 was his desire to measure products like SQL against the full ideal of the relational model. SQL-oriented systems satisfied many of the rules but not all, and Codd wasn’t shy about highlighting the gaps (such as Rule 3 on nulls, or Rule 6 on updatable views, where early SQL systems had limitations). 

In the broad sweep of Codd’s writings, his work on relational languages and logic cemented the notion that *databases are about **what**, not **how***. As one commentator summarized, Codd “saw the potential of using the ideas of predicate logic as a foundation for database management” ([](https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/985420/about-EFCRT.pdf#:~:text=Approaches%E2%80%9D%20)) ([](https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/985420/about-EFCRT.pdf#:~:text=much%20less%20satisfactory%20than%20the,regular%20printed%20version)). In Codd’s own words decades later, a relational system *“has no user-visible navigation links between tables”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Question%3A%C2%A0%20So%20your%20definition%20of,requires%20an%20unrestricted%20join%20capability)) – you get to data by content, not by following pointers. This is the essence of declarativity. It was a hard-won concept: he had to convince a generation of programmers that the computer could do the searching and joining for them, if only they would trust a higher-level approach. Thanks to his relentless advocacy (and working prototypes like System R and Ingres backing him up), by the 1980s this battle was largely won. Vendors and users came to expect set-oriented query languages in their DBMS products. Codd’s relational algebra and its kin became the lingua franca of database queries – whether in the mathematical guise of **relational calculus** or the more English-like syntax of commercial languages.

## Normalization: Form and Substance of Data

While the relational algebra addressed the *processing* of data, **normalization** addressed the *organization* of data. Codd introduced the concept of a *“normal form”* for database relations in his 1970 paper, and it evolved into one of the cornerstone principles of relational design. At its core, normalization is about structuring data to reduce redundancy and dependency anomalies. Codd noticed early on that many databases (and file systems) suffered from *“repeating groups”* or sub-records – essentially, lists of items (like a list of children’s names within an employee record, or a history of jobs within a person’s file) embedded in a single record. These made operations awkward and led to duplication of information. His solution was simple yet profound: flatten those hierarchical structures into multiple relations and link them via common keys. In the 1970 paper, he illustrated this with an example of employees, their job histories, and children. The original “unnormalized” structure had an `employee` record containing a `jobhistory` field which was itself a set of jobs, and so on ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=normalization,employee%20I%20jobhistory%20I)) ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=employee%20%28man,childname%2C%20birthyear)). By applying a procedure (which he called **normalization**), Codd showed how to turn this into a set of four relations: `employee`, `jobhistory`, `salaryhistory`, and `children`, each a flat table, with primary keys propagated appropriately ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=employee%20%28man,childname%2C%20birthyear)) ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=Normalization%20proceeds%20as%20follows,repeat%20the%20same%20sequence%20of)). The transformation eliminated nested arrays in favor of separate tables; for example, instead of one employee record with a repeating list of children, you’d have multiple child records each carrying the parent’s employee ID. Figure 3(a) and 3(b) of his paper starkly contrasted the *“unnormalized set”* with the *“normalized set”* ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=employee%20%28man,childname%2C%20birthyear)) ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=FIG,each%20of%20the%20immediately%20subordinate)). The latter was bigger (more rows overall), but it had a crucial advantage: **each fact was stored exactly once.**

Codd’s normalization in 1970 was primarily concerned with removing repeating groups – what would later be formalized as achieving **First Normal Form (1NF)**. He required that all domains (columns) be “simple” (atomic) values ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=1,necessary%20for%20a%20relation%20with)) ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=If%20the%20user%E2%80%99s%20relational%20model,take%20a%20form%20such%20as)). If a domain was *non-simple* (meaning it contained relations or sets as values), he advocated eliminating it through decomposition. This idea was somewhat controversial at first – after all, one could imagine allowing tables within tables – but Codd felt strongly that flatting the data made everything simpler and more reliable. *“The simplicity of the array representation which becomes feasible when all relations are cast in normal form is not only an advantage for storage purposes but also for communication of bulk data between systems,”* he wrote ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=normalizing%20kind%20are%20possible,would%20have%20the%20following%20advantages)) ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=The%20simplicity%20of%20the%20array,valued%20%29)). Normalization, therefore, was not just a theoretical nicety; it had practical payoffs: it removed pointers, index structures, and ordering from the equation, making data interchange and understanding easier ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=feasible%20when%20all%20relations%20are,all%20dependence%20on%20hash%20addressing)) ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=,bank%20can%20take%20a%20simpler)). 

Over the next couple of years, Codd expanded the normalization theory. In a 1971 research report “Further Normalization of the Data Base Relational Model,” he introduced **Second Normal Form (2NF)** and **Third Normal Form (3NF)** ([Further Normalization of the Data Base Relational Model](https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/987737/00-efc-further-normalization.pdf#:~:text=was%20introduced,a%20viable%20state%20when%20data)) ([Further Normalization of the Data Base Relational Model](https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/987737/00-efc-further-normalization.pdf#:~:text=3,Suppose%20that%20all%20three%20of)). These addressed more subtle redundancies that occur even when there are no repeating groups. Second normal form dealt with eliminating partial dependencies on a composite key (each non-key attribute should depend on the whole key, not just part of it). Third normal form went further to eliminate *transitive* dependencies (non-key attributes depending on other non-key attributes). In plain terms, 3NF ensures that *every piece of information in a table depends only on the primary key and nothing else*. Codd provided formal definitions: *“A relation R is in third normal form if it is in second normal form and every non-prime attribute of R is non-transitively dependent on each [candidate key of R]”* ([Further Normalization of the Data Base Relational Model](https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/987737/00-efc-further-normalization.pdf#:~:text=3,transitively%20dependent%20on%20each)). He accompanied these definitions with examples – relations that were not in 3NF would allow awkward situations where deleting one kind of data inadvertently deleted another, or where certain facts had to be duplicated across multiple rows. By converting such a relation into two or more relations (a process we now call **decomposition**), those anomalies vanished. *“Note how the undesirable insertion, update and deletion dependencies have disappeared with the removal of the transitive dependencies,”* he commented in one example ([Further Normalization of the Data Base Relational Model](https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/987737/00-efc-further-normalization.pdf#:~:text=Fig,the%20original%20relation%20W%20may)). *“No essential information has been lost, since at any time the original relation… may be recovered by taking the natural join”* of the new tables ([Further Normalization of the Data Base Relational Model](https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/987737/00-efc-further-normalization.pdf#:~:text=Fig,the%20original%20relation%20W%20may)). This remark is the essence of normalization: you break tables apart to remove bad dependencies, but you do so in a way that a correct join operation can always reconstruct the original information.

Codd saw normalization as an **articulation of data semantics**. *“Normalization is an attempt to capture tiny bits of the semantics of information in a formal way – that is, to suggest the rules by which fields should be put together into a single record,”* he explained ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20Before%20the%20normalization%20ideas,no%20semantic%20considerations%20anyway)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Normalization%20is%20an%20attempt%20to,not%20just%20relational%20systems)). Before normalization, database design was something of a black art; one might throw fields together in a file because they “felt” related or because an application needed them together. But there was no theory to guide it. Codd changed that by identifying *functional dependencies* as the key notion: a field Y is functionally dependent on field X if X determines Y. Using this, one can discern which attributes belong together. If in a table, attributes A and B together determine C (but A alone does not, and B alone does not), it indicates a certain key structure, and possibly that breaking the table might yield smaller tables with their own keys that are more stable. Codd and his contemporaries (notably Raymond Boyce, who with Codd defined the Boyce–Codd Normal Form in 1974) provided a series of normal forms that designers could use as a checklist for a *sound schema*. The goal was a design that would be resilient to change – or as Codd put it, *stable*. In the interview, the question was posed: is the chief advantage of normalization yielding stability in database design? Codd responded, *“I certainly believe that the normalization ideas, plus others, can contribute to a good deal more stability in data base definitions and structure. It should become less necessary to have reorganizations of the logical level.”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Question%3A%C2%A0%20Getting%20back%20to%20the,in%20the%20data%20base%20design)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20I%20certainly%20believe%20that,reorganizations%20of%20the%20logical%20level)). He was realistic, though: *“notice I said ‘less.’ There is no way you can get a definition of the data base that’s going to be good for, say, manufacturing operations *forever*, because the environment may change… All we’re trying to do is to get more stability.”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=contribute%20to%20a%20good%20deal,reorganizations%20of%20the%20logical%20level)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=But%20notice%20I%20said%20,is%20to%20get%20more%20stability)). In that humility lies a deep truth: normalization isn’t a magic bullet that captures *all* meaning (indeed, new requirements can always arise that force redesign), but it’s a method to *delay* the day of reckoning, to make the schema as logical and future-proof as possible.

Codd was aware that not everyone in the database community embraced normalization. Some considered it too theoretical or inflexible. *“There have been some strange reactions to it,”* he mused. Database administrators largely found it useful, he observed, and *“many people use normalization concepts regularly.”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Question%3A%C2%A0%20How%20do%20you%20assess,reaction%20to%20the%20normalization%20concepts)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20Well%2C%20there%20have%20been,people%20use%20normalization%20concepts%20regularly)) But *“some computer scientists… tend to look at normalization and say that, because it is a very formal recipe for information, it must be just a syntactic approach,”* he noted ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Question%3A%C2%A0%20How%20do%20you%20assess,reaction%20to%20the%20normalization%20concepts)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Second%2C%20computer%20scientists%20,be%20just%20a%20syntactic%20approach)). In other words, critics accused normalization of focusing on structure (syntax) rather than meaning (semantics), perhaps because it operates by rather mechanical rules. Codd’s reply was nuanced. He conceded that normalization *does not capture all meaning* – *“I don’t view it as capturing anywhere near all the meaning that can be captured,”* he said ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Second%2C%20computer%20scientists%20,be%20just%20a%20syntactic%20approach)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Now%20let%20me%20say%20that,understandable%20by%20machines%20than%20otherwise)). However, *“the point is that normalization takes a little bite of the data’s meaning and casts it into a formally manipulable form. This doesn’t mean it ceases to be semantic in nature, but just that it’s more usable by people and understandable by machines than otherwise.”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Second%2C%20computer%20scientists%20,be%20just%20a%20syntactic%20approach)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Now%20let%20me%20say%20that,understandable%20by%20machines%20than%20otherwise)). Here Codd is drawing an important line: normalization *is* about semantics – the semantics of dependencies and keys – but it’s a constrained, well-defined slice of semantics that we can handle algorithmically. There will always be more meaning (business rules, contextual knowledge) outside what normalization covers. But that extra meaning lacks the crisp edges needed for automation. Normalization, on the other hand, translates some of that intuitive understanding (like “this field is determined by that field”) into a systematic design method.

In his later work, including **Version 2 of the Relational Model** (1990), Codd revisited normalization in light of new needs, such as handling **hierarchies of categories** (what we might call subtypes or class hierarchies today). He introduced the notion of **essentiality** and further normal forms to deal with more complex constraints, but the core message remained: data should be structured in relations that represent *natural* groupings of attributes, and dependencies should be made explicit and logical. Normalization was one of Codd’s gifts to database theory that outgrew the relational model itself – even non-relational data designers (for XML, for example) have applied Codd’s normalization ideas to avoid redundancy. It’s striking that Codd himself viewed normalization as **separate from the relational model proper**: *“Normalizaion is an associated theory, but is not part of the relational model per se,”* he said in 1982, *“Relational theory is much broader than the relational model alone.”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Question%3A%C2%A0%20So%20normalization%20is%20not,the%20relational%20model%20per%20se)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20No%2C%20I%20don%27t%20think,than%20the%20relational%20model%20alone)). By that he meant the relational model mandates only the structural/mathematical aspects (tables, algebra, etc.), whereas normalization is a design guideline that one uses when *applying* the model. Indeed, one can have a relational database that is not normalized (nothing in the formal model forbids redundancy), but it will not enjoy the same integrity and simplicity benefits. Codd clearly preferred that designers do normalize – his writings are filled with encouragements to that effect – but he recognized it as a distinct thread of theory, one that he and others developed in parallel to the main relational thesis.

## Keys, Integrity, and the Soul of the Relational Model

From the beginning, Codd’s relational model was not just about structure and operations, but also about **constraints** – the laws that govern valid states of the data. Two constraints in particular were highlighted: **entity integrity** and **referential integrity**. In simple terms, *entity integrity* means each table has a primary key and that key cannot be null (every row must be distinguishable), and *referential integrity* means foreign keys must actually match primary keys in the referenced table (no invalid references). These concepts seem obvious now, but Codd codified them as essential parts of the model’s *integrity* component. In the famous **Rule 10** of his 1985 rules, he states: *“Integrity constraints specific to a particular relational data base must be definable in the relational data sublanguage and storable in the catalog, not in the application programs.”* ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=,not%20in%20the%20application%20programs)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Assume%20the%20relational%20model%20is,to%20every%20relational%20data%20base)). This is a powerful statement: it asserts that the database system itself should understand and enforce the business rules (so far as they concern the data structure), rather than leaving that entirely to external programs. 

Codd elaborated on this in his interviews. *“The new approach to integrity control in a relational DBMS requires that: 1) all integrity constraints should be specified linguistically – not by means of data structures… and 2) the integrity constraint statements should be stored in the catalog (and NOT in the application programs),”* he emphasized ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=On%20Integrity%20Constraints%20)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20,in%20a%20fully%20relational%20DBMS)). The benefits? If rules are centralized in the database, they are *uniformly enforced* and can be changed in one place. He gave a practical scenario: suppose a business rule says “a customer cannot be deleted if they still have orders.” In a non-relational system, that rule might be embedded in various application programs, each of which would have to be modified if the rule changes. In Codd’s approach, the rule would be a single constraint in the database schema. *“If, as sometimes happens, either business policies or government regulations change, it will probably become necessary to change the integrity constraints,”* Codd wrote. *“Normally, this can be accomplished in a fully relational DBMS by changing one or more of the integrity statements that are stored in the catalog… without forcing any rewriting… of application programs.”* ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=If%2C%20as%20sometimes%20happens%2C%20either,are%20stored%20in%20the%20catalog)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=relational%20data%20base,to%20every%20relational%20data%20base)). This was forward-thinking – in effect advocating what today we call *declarative integrity constraints* and triggers. Codd saw the DBMS as not just a passive data store, but an active guardian of data integrity.

He also linked the idea of integrity constraints back to the objective of data independence. If all the rules are in the catalog, applications remain stable even as rules evolve. *“This stems from the fact that changes in the integrity constraints stored in the catalog can usually be made without changing any of the application programs,”* he noted ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=activities)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=As%20a%20consequence%20of%20T3,total%20system%20to%20environmental%20changes)). By removing “explicit calls” in applications to enforce specific constraints and letting the DBMS handle it, one achieved a form of **integrity independence** ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=application%20programs%20,total%20system%20to%20environmental%20changes)). Indeed, in Codd’s 12 rules, Rule 10 is sometimes dubbed *Integrity Independence*, to stand alongside Rule 8 (Physical Data Independence) and Rule 9 (Logical Data Independence) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=In%20rules%20eight%20through%2011%2C,heavily%20discussed%20for%20many%20years)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=independence%20aimed%20at%20protecting%20customers%E2%80%99,heavily%20discussed%20for%20many%20years)). He felt this aspect had been neglected: *“Rules 10 and 11 – integrity independence and distribution independence – are aspects of the relational approach that have received inadequate attention to date but are likely to become as important as eight and nine,”* he wrote in 1985 ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=data%20independence%20%E2%80%94%20have%20been,heavily%20discussed%20for%20many%20years)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Rules%2010%20and%2011%20%E2%80%94,important%20as%20eight%20and%20nine)). It was a gentle prod to the industry that integrity should be taken as seriously as physical storage and logical schema evolution.

Central to integrity are **keys** – a concept Codd inherited from the data management tradition but made fundamental in the relational model. Every relation, in Codd’s world, must have a primary key (one or more attributes that uniquely identify a tuple), and that key’s role is sacrosanct. In Rule 2, the *Guaranteed Access Rule*, he asserts that *“each and every datum (atomic value) in a relational data base is guaranteed to be logically accessible by resorting to a combination of table name, primary key value and column name”* ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Guaranteed%20access%20rule)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=,key%20value%20and%20column%20name)). This wouldn’t hold if primary keys could be null or if duplicates were allowed freely, hence the requirement of entity integrity (no component of a primary key can be null) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=relational%20data%20base,to%20every%20relational%20data%20base)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=,value%20from%20the%20same%20domain)). Similarly, foreign keys (sometimes called referential attributes) create a directed relationship between tuples of different relations, ensuring consistency across the database. Codd’s Rule 3 (on nulls) and Rule 10 (on integrity) intersect on this point: you should be able to declare that a foreign key column cannot be null (if you require a relationship) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=,way%2C%20independent%20of%20data%20type)), and also declare the foreign key constraint itself (the rule that every foreign key value must match a primary key in the referenced table) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=,value%20from%20the%20same%20domain)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=value.%20,value%20from%20the%20same%20domain)). He even spelled out these two integrity rules explicitly in the Computerworld articles: *“(a) Entity integrity: No component of a primary key is allowed to have a null value. (b) Referential integrity: For each distinct nonnull foreign key value... there must exist a matching primary key value from the same domain.”* ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=,value%20from%20the%20same%20domain)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=,value%20from%20the%20same%20domain)).

Beyond keys and basic constraints, Codd was intrigued (and sometimes frustrated) by the broader notion of **semantics** in databases. Some critics in the late 1970s and early 1980s claimed the relational model was “semantically poor” – that is, it didn’t explicitly capture higher-level meanings like hierarchies or inheritance or real-world relationships as richly as newer “semantic data models” or the emerging object-oriented approaches did. To this, Codd responded vigorously: *“First of all, I strongly disagree with those who claim that the relational model is devoid of semantics,”* he stated ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=On%20Semantics%20)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20First%20of%20all%2C%20I,foreign%20keys%2C%20and%20integrity%20constraints)). *“Examples of semantic concepts are domains (including the constraints they place on comparison of values…); primary keys, foreign keys, and integrity constraints.”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=On%20Semantics%20)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20First%20of%20all%2C%20I,foreign%20keys%2C%20and%20integrity%20constraints)) In his view, the relational model had plenty of semantic hooks: a **domain** in a relational schema isn’t just a data type, but a concept – for instance, an EmployeeID domain versus a DepartmentID domain carry semantic distinctions that the DBMS can honor (you shouldn’t compare an EmployeeID to a DepartmentID, for example, as they come from different domains). Keys and relationships were also semantic in that they mirror real-world notions of identity and reference. Codd acknowledged that more semantics *“can and should be added”* to the model, but he issued a caution: *“it is important to remember that there is at present no non-subjective boundary to the subject of semantics. It is a never-ending task. Therefore, some way must be found to test the usefulness of proposed semantic features.”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20First%20of%20all%2C%20I,foreign%20keys%2C%20and%20integrity%20constraints)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=keys%2C%20and%20integrity%20constraints)). This pragmatism is telling: rather than chase every possible nuance of meaning (and risk making the model unwieldy or arbitrary), he wanted to proceed judiciously, adding features that have clear and demonstrable benefit.

One such extension of the relational model to capture more meaning came in the form of **type hierarchies** and **inheritance** – essentially, early object-oriented concepts. In a 1979 paper titled *“Extending the Database Relational Model to Capture More Meaning”*, Codd explored whether the model could support superclass-subclass relationships (e.g., “ENGINEER” is a kind of “EMPLOYEE”). In a 1982 interview, he discussed this idea: *“Suppose you have employees. You have certain information about employees in general, but then you have special information about employees who are engineers… and so on. This would be a two-level type hierarchy. To carry this a step further, employees might also be customers, stockholders, and so on… Here you have a three-level type hierarchy.”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20There%20is%20a%20lot,is%20an%20example)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Suppose%20you%20have%20employees,level%20type%20hierarchy)). He explained the need for rules when dealing with such hierarchies: if we say Jones is an Engineer (subtype) and Engineers inherit properties of Employee (supertype), then deleting Jones from the Employee list should cascade or be disallowed accordingly. *“If there is an entry for Jones as an engineer, there needs to be an entry for Jones as an employee,”* Codd gave as an example rule ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Rules%20for%20manipulating%20such%20type,in%20data%20base%20management%20lately)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=as%20an%20engineer%2C%20there%20needs,in%20data%20base%20management%20lately)). These are essentially *insertion and deletion rules for subtypes*. Such semantic notions *“have been around for quite a while and [have] been getting quite a bit of attention… lately,”* he noted, referencing how these ideas were prominent in AI and were now entering database discussions ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=been%20getting%20quite%20a%20bit,in%20data%20base%20management%20lately)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Type%20hierarchies%20have%20been%20around,a%20practical%20need%20for%20this)). In **Version 2** of his relational model (1990), Codd incorporated some of these concepts more formally, while still keeping the relational foundation. He, for instance, allowed for certain kinds of table subtypes and provided guidelines on preserving consistency across them. 

Another semantic headache Codd tackled was the problem of **missing information**. In the real world, databases often have to represent “not applicable” or “unknown” for some fields. The straightforward relational model had no built-in notion of a missing value initially. So, Codd introduced the idea of **null values** – but he wasn’t entirely satisfied with the simplistic implementation of nulls in SQL (a single null representing anything from “unknown” to “not applicable”). He proposed a more nuanced approach with **two kinds of marks**: *A-mark* (“missing but Applicable”) and *I-mark* (“missing and Inapplicable”) ([Missing Information (Applicable and Inapplicable) in Relational Databases](https://sigmodrecord.org/publications/sigmodRecord/8612/pdfs/16301.16303.pdf#:~:text=or%20application%20data%20type,applicable%20I%20missing%20and%20inapplicable)) ([Missing Information (Applicable and Inapplicable) in Relational Databases](https://sigmodrecord.org/publications/sigmodRecord/8612/pdfs/16301.16303.pdf#:~:text=i%20%21%20i%20applicable%20%28A,i%3A%20Classification%20of%20Missing%20Information)). The idea was to distinguish between “I don’t know this value right now” and “This value doesn’t make sense in this context.” For example, an employee’s middle name might be unknown (so an A-mark could be used), whereas the “spouse name” field for an unmarried employee is inapplicable (an I-mark). In a 1986 article in *SIGMOD Record*, Codd (and colleagues) outlined this approach: *“We now have two kinds of marks, where there was previously just one kind of null”* ([Missing Information (Applicable and Inapplicable) in Relational Databases](https://sigmodrecord.org/publications/sigmodRecord/8612/pdfs/16301.16303.pdf#:~:text=i%20applicable%20%28A,Information%20in%20a%20relational%20DBMS)) ([Missing Information (Applicable and Inapplicable) in Relational Databases](https://sigmodrecord.org/publications/sigmodRecord/8612/pdfs/16301.16303.pdf#:~:text=%28A,briefly%20discuss%20the%20relationship%20between)), they wrote, explaining that marks behave differently from regular values in operations (they don’t propagate like normal values in arithmetic, for instance) ([Missing Information (Applicable and Inapplicable) in Relational Databases](https://sigmodrecord.org/publications/sigmodRecord/8612/pdfs/16301.16303.pdf#:~:text=Now%20follows%20a%20description%20of,else%20it%20is%20absent%20therefrom)) ([Missing Information (Applicable and Inapplicable) in Relational Databases](https://sigmodrecord.org/publications/sigmodRecord/8612/pdfs/16301.16303.pdf#:~:text=same%20as%20the%20semantics%20of,represented%20by%20distinctly%20named%20variables)). Codd was basically inventing a rudimentary **three-valued logic** for the relational model (true, false, and “maybe”/unknown, with a differentiation of two flavors of “maybe”). He believed this was a more *truthful* way to capture reality in a database. *“There is nothing imprecise about a mark: either a db-value is present… or else it is absent,”* he argued, separating the *fact* of a value’s absence from the *semantics* of why it’s absent ([Missing Information (Applicable and Inapplicable) in Relational Databases](https://sigmodrecord.org/publications/sigmodRecord/8612/pdfs/16301.16303.pdf#:~:text=information,value%20itself.%20The%20former%20fact)) ([Missing Information (Applicable and Inapplicable) in Relational Databases](https://sigmodrecord.org/publications/sigmodRecord/8612/pdfs/16301.16303.pdf#:~:text=information%20is%20that%20of%20recording,or)). Not all of Codd’s contemporaries embraced this complexity – indeed, the SQL standard stuck with a single NULL – but Codd’s proposal reflected his relentless pursuit of aligning the model with reality’s nuances. 

Keys, constraints, semantic enhancements, missing information – these all might seem like details, but in Codd’s philosophy they were part and parcel of delivering on the **promise of the relational model**. That promise was *faithfulness to the user’s mental model*. If a user thinks a certain rule holds in the data, the database should be able to enforce it; if a user expects a certain piece of data to be unique or present, the system should assist in guaranteeing that. In 1985, Codd admonished vendors that a system claiming to be relational must not allow the integrity rules to be bypassed by any “lower-level” interface: *“If a relational system has a low-level (single-record-at-a-time) language, that low level cannot be used to subvert or bypass the integrity rules and constraints expressed in the higher level relational language (multiple-records-at-a-time).”* ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Nonsubversion%20rule)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=,time)) This was his **Rule 12: the non-subversion rule**, and it underscored how vital he felt integrity was — it had to hold under all circumstances. Any loophole that allowed someone to sneakily insert bad data was an affront to the relational approach. Codd wryly observed that this rule *“is extremely difficult for a ‘born-again’ system to obey,”* since those systems (i.e., older models retrofitted with a relational veneer) *“already support an interface below the relational constraint interface.”* ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=In%20the%20relational%20approach%2C%20preservation,given%20this%20problem%20adequate%20attention)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=logical%20data%20structure%20to%20achieve,given%20this%20problem%20adequate%20attention)) In other words, if you bolt SQL on top of a navigational engine, someone might still use the old navigation API and break the rules; true relational systems avoid that problem entirely.

## The Twelve Rules: Codd’s Crusade for Relational Purity

By the mid-1980s, relational database systems were becoming commercially available from many vendors. But Codd grew concerned that the term “relational” was being diluted. Vendors advertised products as “relational” even if they only partially implemented the concepts. Marketing hyperbole risked misleading customers and eroding the benefits of the model by reintroducing old, bad habits under the relational banner. In response, Codd formulated his famous **twelve rules** (numbered 0 to 12, giving thirteen in total) as a litmus test for a *fully relational* DBMS. These appeared in two back-to-back *Computerworld* articles in October 1985 entitled *“Is Your DBMS Really Relational?”* and *“Does Your DBMS Run by the Rules?”*. In the introduction, Codd makes his motivation crystal clear: *“Use of the term ‘fully relational’ in this report is slightly more stringent than in my Turing paper (written in 1981). This is partly because vendors… have translated the term ‘minimally relational’ to ‘fully relational’… and partly because in this report, we are dealing with relational **DBMS** and not relational systems in general.”* ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Twelve%20rules%20are%20cited%20below,reporting%20systems)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=relational%E2%80%9D%20in%20this%20report%20is,reporting%20systems)). In other words, he was tightening the criteria – raising the bar – specifically to call out products that were “sort-of relational.” 

Codd prefaced the rules by noting that they *“tend to explain why full support of the relational model is in the users’ interest”* ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=However%2C%20the%2012%20rules%20tend,fidelity%20to%20the%20relational%20model)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=However%2C%20the%2012%20rules%20tend,fidelity%20to%20the%20relational%20model)). They weren’t arbitrary hoops for vendors to jump through, but principles that directly benefited the user (in terms of consistency, flexibility, longevity of data, etc.). He also reassured that *“no new requirements are added to the relational model”* ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=However%2C%20the%2012%20rules%20tend,fidelity%20to%20the%20relational%20model)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=However%2C%20the%2012%20rules%20tend,fidelity%20to%20the%20relational%20model)) – the rules were derived from his existing writings. Indeed, *“this [was] the first occurrence of all 12 of them together,”* he wrote, *“Although I have defined each rule in earlier papers.”* ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=fidelity%20to%20the%20relational%20model)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=First%2C%20I%20define%20these%20rules,all%2012%20of%20them%20together)) The rules covered a broad spectrum of features, from the very basic (Rule 1: the Information rule – all information is represented as values in tables ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=The%20information%20rule)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=,%E2%80%94%20by%20values%20in%20tables))) to the lofty (Rule 6: *“All views that are theoretically updatable are also updatable by the system”* ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=View%20updating%20rule)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=,also%20updatable%20by%20the%20system)), a challenge to early SQL systems that had read-only views). Codd enumerated four different types of independence in Rules 8 through 11 (physical, logical, integrity, distribution) aimed at *“protecting customers’ investments in application programs”* ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=In%20rules%20eight%20through%2011%2C,heavily%20discussed%20for%20many%20years)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=independence%20aimed%20at%20protecting%20customers%E2%80%99,heavily%20discussed%20for%20many%20years)). And of course, he began with **Rule 0**, the foundation: *“For any system that is advertised as… a relational DBMS, that system must be able to manage databases entirely through its relational capabilities.”* ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Rule%20Zero)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=,entirely%20through%20its%20relational%20capabilities)). If a product failed Rule 0, Codd said, it *“is not worth rating as a relational DBMS.”* ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=entirely%20through%20its%20relational%20capabilities)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=This%20rule%20must%20hold%20whether,rating%20as%20a%20relational%20DBMS)) Strong words, but from Codd’s perspective, if a database couldn’t be used without invoking non-relational tricks (like calling a procedural record manager for some operations), it hadn’t really delivered the paradigm to the user.

Some of the rules read like common sense now because they’ve been absorbed into the fabric of modern databases. Rule 1 (Information rule) basically says no hidden pointers or metadata – everything is stored in tables, including the schema itself ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=,%E2%80%94%20by%20values%20in%20tables)). This gave birth to the notion of the **data dictionary** being a set of relational tables, enabling queries on the schema using the same language as queries on data. Rule 2 (Guaranteed access) we discussed: every atomic value is accessible by table+key+column, rather than by navigation ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Guaranteed%20access%20rule)). Rule 3 (Systematic treatment of nulls) insists that null (missing info) is represented and handled uniformly, not as ad-hoc codes like 999 or “N/A” scattered around ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Systematic%20treatment%20of%20null%20values)). Codd had seen the chaos of inconsistent missing data conventions and was pushing for a principled approach, which, as we saw, he refined with his A-mark and I-mark proposal. Rule 4 (Active, online catalog based on the relational model) requires the system to maintain its schema in relational form – effectively a self-describing database ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Dynamic%20on,the%20relational%20model)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=,apply%20to%20the%20regular%20data)). This was forward-looking: it paved the way for **information schema** standards and the rich system catalogs we rely on.

Rule 5 (Comprehensive data sublanguage) was a direct commentary on some vendors’ half-baked offerings. Codd declared that at least one language should support data definition, manipulation, integrity, and transaction control, all in one ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=,all%20of%20the%20following%20items)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=,begin%2C%20commit%20and%20rollback)). He was pushing against the idea of having separate languages or interfaces for these tasks (some early systems had one language for defining schema, another for queries, etc.). He even poked fun at a mid-70s ANSI committee that advocated “42 distinct interfaces” to a DBMS: *“Fortunately, that idea has apparently been abandoned,”* he jibed ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=rarely%20be%20necessary%20to%20bring,listed%20above%20into%20distinct%20languages)). Rule 6 (View updating) and Rule 7 (High-level insert, update, delete) were about not crippling the power of the relational model when it came to updates ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=View%20updating%20rule)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=High)). If an operation can be done logically (like updating a view that is a join of two tables), the system *ought* to figure it out, Codd argued, rather than rejecting it outright. He gave a theoretical condition for when a view is updatable (a *time-independent unambiguous mapping to base relations* exists) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=system)), showing that even in these practical rules, he leaned on formal reasoning.

Rules 8 and 9 reiterated the twin ideals of **physical and logical data independence** ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Physical%20data%20independence)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Logical%20data%20independence)). They state that changes to storage or access methods (physical) or changes to the schema that do not alter information content (logical, e.g. splitting a table, adding a field that can be derived) should not break applications ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Physical%20data%20independence)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Logical%20data%20independence)). These were essentially restating the mission statement from 1970 in the guise of testable criteria. Rule 10, on integrity independence, we’ve discussed: integrity constraints must be declarable in the language and stored in the catalog ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=,not%20in%20the%20application%20programs)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Assume%20the%20relational%20model%20is,to%20every%20relational%20data%20base)). Rule 11 (Distribution independence) anticipated distributed databases: a user’s query should work the same whether the data is all local or split across sites ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=,DBMS%20has%20distribution%20independence)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=,the%20DBMS%20manages%20distributed%20data)). Codd noted this was indeed being demonstrated – e.g., queries written for IBM’s System R (non-distributed) could run on System R* (distributed) without changes ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=nondistributed%20DBMS%20can%20fully%20support,fully%20support%20this%20rule)). And then, to cap it off, Rule 12 (Non-subversion) which we just examined: no sneaky backdoors that violate the rules ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Nonsubversion%20rule)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=,time)).

Codd’s tone in presenting these rules is notably direct, occasionally to the point of scolding. At one point he remarks: *“Any statement in the manuals of a system claimed to be a relational DBMS that advises users to revert to some nonrelational capabilities ‘to achieve acceptable performance’… should be interpreted as an apology by the vendor.”* ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Any%20statement%20in%20the%20manuals,performance%20with%20the%20relational%20approach)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Any%20statement%20in%20the%20manuals,performance%20with%20the%20relational%20approach)). The subtext is clear: if a vendor tells you *“well, our SQL works but for heavy lifting you might want to use our old record-at-a-time API,”* then that vendor has failed to do their job. Codd had little patience for half-measures that undercut the model’s benefits. He was, by this time, somewhat an outsider to the mainstream database industry (having left IBM and formed his own consulting company with Chris Date). But his authority in the field was still immense, and the **12 rules** document became both a checklist for buyers and a to-do list for database developers. It wasn’t a formal standard, but it influenced standards and product directions. For example, the rules helped pressure vendors to incorporate declarative integrity constraints and to improve support for views and data dictionaries in their systems (features which are taken for granted now).

The twelve rules also stand as a kind of **creed** for the relational faith that Codd had fathered. More than a decade after his 1970 paper, the core principles had not changed – if anything, they were sharpened. The relational model started as a bold idea on paper, and through the 1970s it had to prove itself (which it did, via prototypes and the successful transaction systems like System R and INGRES). By the mid-80s, the question was no longer “is the relational model viable?” but rather “whose relational system is truly good, and are we reaping the full benefits?” Codd’s rules aimed to ensure the original purity and purpose did not get lost in commercial translation. They *“together with the nine structural, 18 manipulative and three integrity features of the relational model, determine in specific detail the extent of validity of a vendor’s claim to have a ‘fully relational DBMS.’”* ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Buyers%20and%20users%20will%20expect,%E2%80%9D)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=they%20will%20fail%20to%20get,%E2%80%9D)) he wrote. That sentence is a bit dense, but it reflects that Codd had catalogued every aspect (he counted 9 structural features, etc.) and wanted vendors to measure up on each. It’s a reminder that for Codd, the relational model was a holistic vision: it spanned how data is structured, how it is manipulated, and how it is constrained – *all three* were crucial for the coherence of the system.

As a historical note, the publication of Codd’s 12 rules put some gentle pressure on IBM, his old employer, which by then had a SQL-based product (DB2) and an installed base of IMS (the old hierarchical system). IBM was indeed promoting DB2 but also cautious about upsetting IMS users. In an interview in 1987, Codd candidly said, *“IBM has been, and still is, overprotective [of IMS]. What we should do is put these things out in the marketplace and see what customers really want… If the customer makes the decision that he would be better off moving to a relational data base… then he should have that choice.”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20The%20best%20way%20for,been%2C%20and%20still%20is%2C%20overprotective)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=investment%20in%20IMS,been%2C%20and%20still%20is%2C%20overprotective)). Ever the diplomat, he added *“IBM… will help him protect [his IMS] investment. But… they’ll probably begin finding the productivity, communicability, and distributability arguments to be so strong that the expense of a transition will be worth it.”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=What%20we%20should%20do%20is,help%20him%20protect%20that%20investment)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=But%20if%20the%20customer%20makes,transition%20will%20he%20worth%20it)). It was as close as Codd got to saying: the relational way *will* win out, because it simply makes people more productive and systems more adaptable. History proved him right; over the next decade, relational databases became the default, and even IBM’s IMS now lives in a niche rather than center stage. Codd lived to see his model triumph.

## Conclusion: The Relational Revolutionary’s Legacy

From 1969 to the early 1990s, Ted Codd’s writings display a remarkably consistent intellectual arc. He set out to elevate data management from craft to science, and in doing so, he unleashed a revolution in how we store, query, and think about information. What’s striking in exploring Codd’s works closely – in his own words – is how *fresh and bold* many of his statements remain. The notion that a user should be spared concern for *“how the data is organized in the machine”* ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=Future%20users%20of%20large%20data,in%20query%2C%20update%2C%20and%20report)) is now a bedrock expectation, yet Codd had to articulate it at a time when it ran against the grain. His insistence on precision and rigor, dipping into mathematics as needed, gave the field its solid foundations. As one tribute succinctly put it, *“he put the field on a solid scientific footing, by providing a theoretical framework within which a variety of important problems could be addressed in a scientific manner.”* ([](https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/985420/about-EFCRT.pdf#:~:text=Approaches%E2%80%9D%20)) ([](https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/985420/about-EFCRT.pdf#:~:text=much%20less%20satisfactory%20than%20the,regular%20printed%20version)) Indeed, Codd’s work transformed databases from a motley collection of hacks into a principled discipline – one could even call it the **mathematization of data management**.

Reading Codd’s papers is to witness the birth of concepts we now find utterly standard: relational **algebra** and **calculus**, the concept of a **data model**, the emphasis on data independence, the formal definition of **functional dependence** and normal forms, the requirement of a **data dictionary**, the idea of **transaction** semantics (all-or-nothing, though not covered in depth here, he did influence concurrency and recovery too). He introduced the term **“relation”** to a field that spoke of files and records, and by doing so, introduced a level of abstraction that made decades of subsequent innovation possible. And yet, he was not an armchair theorist; his writing shows constant concern for the *“casual user”*, the end-user productivity, the practical ease of use. One of his major achievements, he felt, was not just the relational model in particular, *“but the whole idea of a data model in general”* ([](https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/985420/about-EFCRT.pdf#:~:text=Approaches%E2%80%9D%20)) ([](https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/985420/about-EFCRT.pdf#:~:text=much%20less%20satisfactory%20than%20the,regular%20printed%20version)) – separating the logical aspect of data from how it is implemented. This concept now underpins everything from JSON databases to cloud storage APIs.

Throughout Codd’s work, certain **tensions** and **themes** recur. There is the tension between *simplicity* and *power*: he wanted the model to be as simple as possible (e.g., everything as tables, one high-level language) yet rich enough to capture the reality of enterprise data (keys, constraints, hierarchies). There is the theme of *independence*: independence of programs from data layout, independence of higher-level operations from lower-level representation, independence of user activity from centralized changes. And there is a profound *faith in logic* – a belief that by basing data management on sound principles (set theory, logic, consistency rules), one could conquer the complexities that previously required endless special-case coding. At times, this put him at odds with those who prioritized immediate efficiency. But Codd was not naive about performance; rather, he believed that the proper way to get performance was to have the system do it (through optimization) rather than burden every programmer with it. He noted with some satisfaction how, in mature relational systems, the **optimizer** could take a declarative query and find a good way to execute it – something unimaginable in the early days, but a direct consequence of the fixed relational framework. 

By the time he compiled *The Relational Model for Database Management, Version 2* in 1990 ([Codd's 12 rules - Wikipedia](https://en.wikipedia.org/wiki/Codd%27s_12_rules#:~:text=Retrieved%2022%20January%202022,ISBN%20%C2%A0%2085)), Codd had incorporated a lot of the lessons and extensions from 20 years of relational experience. That book, weighing in at over 500 pages, covered everything from design principles to distributed databases and even a look at *transitional models* that blended relational with object-oriented ideas. Yet, the core was unchanged – it was Version 2, not a brand new model. The relational model had proven remarkably adaptable. It could accommodate new hardware (from disk packs to main memory to parallel servers), new workloads, and even new paradigms (many object-relational features can be seen as extensions of Codd’s type hierarchies and user-defined domains). In one of his final interviews, when asked if he foresaw relational systems becoming obsolete, Codd replied: *“I see nothing on the horizon about to replace the relational approach… By the turn of the century we may have something in view that’s a lot more powerful, I don’t know – but I’m sure it’s still years away.”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20The%20applicability%20of%20relational,to%20replace%20the%20relational%20approach)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=and%20marketing%20them,to%20replace%20the%20relational%20approach)). As of 2025, one might argue that even if new data models have emerged (NoSQL, etc.), the relational model is *still* deeply entrenched and in many ways irreplaceable for a huge class of problems. Codd’s confidence in the longevity of his ideas appears well-placed.

Literary journalist Tracy Kidder once wrote, *“Ideas are holy because they are the tools by which men grasp the world.”* Codd’s ideas – expressed in the dry language of relations and normal forms – indeed became the tools by which our modern world grasps data. In close reading, his prose reveals flashes of wit, occasional impatience with folly, and a steady engineer’s wisdom. He famously valued **clarity** and **quality** in software: *“People who develop software… need to take more pride in the quality of their products. Quality should not be measured solely by the average number of bugs… of equal importance is an evaluation of the overall design.”* ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20People%20who%20develop%20software,evaluation%20of%20the%20overall%20design)). That ethos guided his life’s work. The overall design of the database, in Codd’s case, was elegant and robust – an architecture that endures. 

In the end, Edgar F. Codd comes across not just as the father of the relational database, but as its philosopher king. He combined the precision of a mathematician with the pragmatism of an engineer and the vision of a revolutionary. He never lost sight of the forest for the trees: all the formalism was in service of *human* needs – productivity, consistency, ease of use. As he reminded the trade press in 1981, relational systems were not “paper tigers” but very real engines empowering users ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=On%20the%20Trade%20Press%20)). The millions of SQL queries run each second on this planet are a living testament to that. And if those queries no longer seem magical, it is because Codd succeeded so thoroughly that we take their paradigm for granted. 

Yet, when we peel back the layers and read Codd’s original texts, we rediscover the excitement and clarity of his thinking. We hear his voice – sometimes professorial, defining a normal form; sometimes pointed, rebuking a vendor’s shortcut; sometimes enthusiastic, imagining new semantic features – and we travel the arc from theory to practice in the database field’s most transformative era. Few computer scientists have so directly changed the daily work of so many, and fewer still have done it by articulating a **model of reality** that rings as true today as it did half a century ago. Codd’s relational model was, in a sense, a mirror he held up to the complex world of data processing, reflecting back something simpler, cleaner, and more powerful. In that reflective simplicity lay its genius – and Codd knew it. As he wrote in 1985, underpinning all twelve of his rules was one principle: *“Rule Zero”*, that a system should manage data *“entirely through its relational capabilities”* ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Rule%20Zero)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=,entirely%20through%20its%20relational%20capabilities)). The relational *idea* itself was sufficient; nothing needed to be added, only implemented faithfully. Edgar Codd spent his career ensuring we understood why that idea mattered, and in doing so, he permanently altered the trajectory of data management. 

In the relational model’s elegant symmetry of tables and its logical calculus of tuples, one can still hear Codd’s voice whispering from 1970: *“Let data be free of its bonds; let relations thrive where hierarchies strangled; let every user speak the language of data; and let the integrity of information be guarded at its source.”* He did not quite say it in those words, but in the thousands of words he did write – carefully, methodically, passionately – that is the music one hears. And it is thanks to that music that today our world runs on databases that, as Codd dreamed, **let data be data**, unmarred by the machine that stores it, yet ever ready to yield its treasures to those who ask. 

**Sources:** The essay above was synthesized from Edgar F. Codd’s original papers, including *“A Relational Model of Data for Large Shared Data Banks”* (Communications of the ACM, 1970) ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=Future%20users%20of%20large%20data,in%20query%2C%20update%2C%20and%20report)) ([](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf#:~:text=The%20relational%20view%20,of%20data%20on%20the%20other)), his IBM Research Reports RJ909 (1971) ([Further Normalization of the Data Base Relational Model](https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/987737/00-efc-further-normalization.pdf#:~:text=3,Suppose%20that%20all%20three%20of)) ([Further Normalization of the Data Base Relational Model](https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/987737/00-efc-further-normalization.pdf#:~:text=3,transitively%20dependent%20on%20each)) and RJ987 (1972), the *ACM Turing Award Lecture* (1981) ([Relational Database: A Practical Foundation for Productivity, 1981](https://www.softwaregems.com.au/Documents/Article/Database/Relational%20Model/Codd%20E%20F/Relational%20Database%20Practical%20Foundation%20Turing%20Award.pdf#:~:text=Committee%20for%20his%20,development%20of%20one%20of%20the)) ([Relational Database: A Practical Foundation for Productivity, 1981](https://www.softwaregems.com.au/Documents/Article/Database/Relational%20Model/Codd%20E%20F/Relational%20Database%20Practical%20Foundation%20Turing%20Award.pdf#:~:text=There%20are%20three%20principal%20reasons%3A,at%20a%20needlessly%20low%20level)), *“Is Your DBMS Really Relational?”* (Computerworld, Oct. 14, 1985) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Twelve%20rules%20are%20cited%20below,reporting%20systems)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Rule%20Zero)) and *“Does Your DBMS Run by the Rules?”* (Computerworld, Oct. 21, 1985) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Any%20statement%20in%20the%20manuals,performance%20with%20the%20relational%20approach)) ([Codd’s Twelve Rules – Rel](https://reldb.org/c/index.php/twelve-rules/#:~:text=Guaranteed%20access%20rule)), as well as extensive interview transcripts where Codd explained his ideas in plain terms (Data Base Newsletter, 1982) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20First%2C%20let%20me%20defend,the%20mathematics%20of%20the%20subject)) ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20Before%20the%20normalization%20ideas,no%20semantic%20considerations%20anyway)). These primary sources capture Codd’s thinking in his own voice, illustrating the evolution of the relational model from its inception to its maturity. Additional context and commentary are drawn from Chris Date’s retrospectives ([](https://www.dcs.warwick.ac.uk/~hugh/TTM/CJD-on-EFC%27s-First-Two-Papers.pdf#:~:text=clearly%20be%20correct%2C%20or%20at,specifically%20of%20attributes%20and%20tuples)) ([](https://www.dcs.warwick.ac.uk/~hugh/TTM/CJD-on-EFC%27s-First-Two-Papers.pdf#:~:text=5%20Oddly%20enough%2C%20the%201969,That%20being%20said%2C%20however%2C%20it)) and other relational database histories ([In His Own Words; A Tribute to E.F. Codd (Features)](https://www.brcommunity.com/articles.php?id=b160#:~:text=Codd%3A%C2%A0%20The%20best%20way%20for,been%2C%20and%20still%20is%2C%20overprotective)) ([](https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/985420/about-EFCRT.pdf#:~:text=%EF%81%AE%20%E2%80%9CDerivability%2C%20Redundancy%2C%20and%20Consistency,Nonprogrammers%3A%20The%20Relational%20and%20Network)), which helped interpret Codd’s impact on the field.