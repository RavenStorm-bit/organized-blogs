Great — I’ll dive into the architecture and components of Chromium with a focus on core functionality rather than UI, and provide a detailed guide for modifying and compiling Chromium on Windows.
I'll include explanations of key subsystems (like networking, rendering, JavaScript engine, and sandboxing), and a step-by-step Windows-focused build and customization workflow.
I'll let you know when everything’s ready.

# Chromium Internal Architecture and Windows Build Guide

## Chromium’s Internal Architecture (Non‑UI Subsystems)

 ([Content module](https://www.chromium.org/developers/content-module)) *Chromium’s layered architecture: the **content** module provides core browser functionality (rendering, network, etc.) beneath the Chrome UI, and relies on lower-level components like Blink (WebKit), V8, **net**, and **base** ([Content module](https://chromium.googlesource.com/chromium/src/+/HEAD/content/README.md#:~:text=Architectural%20Diagram)). Arrows indicate allowed dependencies (red: Content API calls into Chrome, blue: Blink’s WebKit API calls into Content).*  

Chromium is designed as a multi-layer, multi-process browser. The **content module** (in `src/content`) contains the non-UI browser logic needed to load and render web pages in a sandboxed, multi-process environment ([Content module](https://chromium.googlesource.com/chromium/src/+/HEAD/content/README.md#:~:text=The%20%E2%80%9Ccontent%E2%80%9D%20module%20is%20located,extensions%2Fautofill%2Fspelling%20etc)). This content layer uses several key subsystems – the Blink rendering engine, the V8 JavaScript engine, the network stack, etc. – and exposes a **Content API** that the top-level Chrome application (the UI and browser-specific features) uses ([Content module](https://chromium.googlesource.com/chromium/src/+/HEAD/content/README.md#:~:text=content%20vs%20chrome)) ([Content module](https://chromium.googlesource.com/chromium/src/+/HEAD/content/README.md#:~:text=See%20an%20older%20diagram%20at%3A,module)). Below we explore the major internal subsystems excluding the UI:

### Multi-Process Architecture and Process Model

Chromium uses a **multi-process architecture** to improve stability and security. There is one **browser process** (the main process) that manages the browser’s UI, tabs, and overall coordination, and many **child processes** for isolated tasks like rendering web content ([Multi-process Architecture](https://www.chromium.org/developers/design-documents/multi-process-architecture/#:~:text=We%20refer%20to%20the%20main,interpreting%20and%20laying%20out%20HTML)). In general, Chrome uses separate processes for different types of work ([Inside look at modern web browser (part 1)  |  Blog  |  Chrome for Developers](https://developer.chrome.com/blog/inside-browser-part1#:~:text=Process%20and%20What%20it%20controls,multiple%20apps%20and%20draw%20them)):

- **Browser Process:** The central process that handles the “chrome” UI (address bar, bookmarks, etc.) and all privileged operations like file access, network requests, and GPU coordination ([Inside look at modern web browser (part 1)  |  Blog  |  Chrome for Developers](https://developer.chrome.com/blog/inside-browser-part1#:~:text=Process%20and%20What%20it%20controls,multiple%20apps%20and%20draw%20them)). This process acts as a *broker* for security, spawning and supervising the sandboxed child processes ([Chromium Docs - Sandbox](https://chromium.googlesource.com/chromium/src/+/main/docs/design/sandbox.md#:~:text=The%20broker%20process)) ([Chromium Docs - Sandbox](https://chromium.googlesource.com/chromium/src/+/main/docs/design/sandbox.md#:~:text=The%20target%20process)).  
- **Renderer Process(es):** These handle all web content for each tab or iframe. Chromium creates multiple renderer processes (typically one per tab or site) to load and render HTML/CSS/JS for web pages ([Inside look at modern web browser (part 1)  |  Blog  |  Chrome for Developers](https://developer.chrome.com/blog/inside-browser-part1#:~:text=At%20the%20top%20is%20the,see%20Site%20Isolation)). Renderers run the Blink engine to parse HTML/CSS and layout pages, and execute JavaScript via V8. They are heavily sandboxed – a renderer **cannot** directly access the disk, network, or display; it must communicate with the browser process for those tasks ([
Chromium Blog: Multi-process Architecture
](https://blog.chromium.org/2008/09/multi-process-architecture.html#:~:text=Renderers,it%20suspects%20an%20exploit%20has)). If a renderer crashes or hangs, it won’t take down the whole browser – you can close the affected tab and the rest of the browser remains stable ([Inside look at modern web browser (part 1)  |  Blog  |  Chrome for Developers](https://developer.chrome.com/blog/inside-browser-part1#:~:text=Earlier%2C%20I%20mentioned%20Chrome%20uses,by%20an%20independent%20renderer%20process)). Chrome’s **Site Isolation** feature further ensures that different websites (especially cross-origin iframes) run in separate renderer processes for security ([Inside look at modern web browser (part 1)  |  Blog  |  Chrome for Developers](https://developer.chrome.com/blog/inside-browser-part1#:~:text=At%20the%20top%20is%20the,see%20Site%20Isolation)).  
- **GPU Process:** A special process for hardware-accelerated graphics. All GPU access is funneled through a dedicated GPU process to isolate graphics driver complexity. The GPU process receives rendering commands (e.g. from renderer processes or the compositor) and interacts with the graphics API (DirectX/OpenGL/Vulkan) to produce pixels on screen ([Inside look at modern web browser (part 1)  |  Blog  |  Chrome for Developers](https://developer.chrome.com/blog/inside-browser-part1#:~:text=requests%20and%20file%20access,multiple%20apps%20and%20draw%20them)). This design improves stability (a GPU crash can be handled separately) and security for graphics drivers.  
- **Plugin Process:** Used to host NPAPI/PPAPI plugins (like Flash or PDF plugins) outside of the renderer for stability and security ([
Chromium Blog: Multi-process Architecture
](https://blog.chromium.org/2008/09/multi-process-architecture.html#:~:text=Plug,with%20the%20browser%20and%20renderers)). Each plugin type may run in its own process. Plugin processes are becoming less common as modern Chrome has phased out most traditional plugins in favor of web standards.  
- **Utility/Extension/Other Processes:** Chromium uses additional helper processes for certain tasks. For example, **utility processes** perform background tasks (like the `utility` process for network service on some platforms, or for audio decoding, etc.), and **extension processes** isolate extension scripts. These all follow the same principle: isolate functionality into separate processes where possible. You can see all the processes Chrome is running by opening Chrome’s Task Manager (⋮ > More Tools > Task Manager) ([Inside look at modern web browser (part 1)  |  Blog  |  Chrome for Developers](https://developer.chrome.com/blog/inside-browser-part1#:~:text=Image%3A%20Chrome%20processes%20%20Figure,different%20parts%20of%20browser%20UI)).

All these processes communicate with each other via defined **IPC (Inter-Process Communication)** channels. Chromium originally had a custom IPC mechanism, but now uses **Mojo** message pipes for most cross-process communication ([Multi-process Architecture](https://www.chromium.org/developers/design-documents/multi-process-architecture/#:~:text=Each%20renderer%20process%20has%20a,or%20Chromium%27s%20legacy%20IPC%20system)). The browser process maintains hosts for each renderer (e.g. `RenderProcessHost` in the browser corresponding to a `RenderProcess` in a renderer) and sends/receives IPC messages to coordinate loading pages, input events, painting, etc. ([Multi-process Architecture](https://www.chromium.org/developers/design-documents/multi-process-architecture/#:~:text=Each%20renderer%20process%20has%20a,or%20Chromium%27s%20legacy%20IPC%20system)). This architecture greatly improves robustness and security – if a web page misbehaves or crashes, it only affects its renderer process and not the whole browser ([Inside look at modern web browser (part 1)  |  Blog  |  Chrome for Developers](https://developer.chrome.com/blog/inside-browser-part1#:~:text=Earlier%2C%20I%20mentioned%20Chrome%20uses,by%20an%20independent%20renderer%20process)). It also enables sandboxing, described below.

### Rendering Engine: Blink (WebKit fork)

**Blink** is Chromium’s open-source **rendering engine** responsible for turning HTML, CSS, and JavaScript into pixels on the screen ([Blink (Rendering Engine)](https://www.chromium.org/blink/#:~:text=Blink%20is%20the%20name%20of,the%20code%20living%20under%20src%2Fthird_party%2Fblink)). Blink is a fork of WebKit – Chromium adopted it to have more control over web platform innovations. Each renderer process embeds Blink to handle the content of a web page. The Blink engine’s responsibilities include:

- **HTML Parsing & DOM Construction:** Blink parses HTML text and builds the **DOM (Document Object Model)** tree representation of the page ([Inside look at modern web browser (part 3)  |  Blog  |  Chrome for Developers](https://developer.chrome.com/blog/inside-browser-part3#:~:text=Parsing)). It follows the HTML5 specification for parsing (which tolerates malformed HTML without throwing errors). The DOM provides a structured in-memory model of the document that scripts can interact with.  
- **CSS Parsing & Style Computation:** Blink parses CSS stylesheets (and inline style attributes) and applies them to the DOM to compute the style for each DOM node. This results in a styled element tree with calculated properties (color, size, etc.) for each element.  
- **Layout (Rendering Tree & Layout):** Given the DOM and styles, Blink creates a **render tree** (Frame/RenderObject tree) and calculates layout – the exact positions and sizes of each element on the page ([Deep Dive into Chromium: A Comprehensive Analysis from Architecture Design to Core Code | by happyer | Medium](https://medium.com/@threehappyer/deep-dive-into-chromium-a-comprehensive-analysis-from-architecture-design-to-core-code-8cc8d3a328e3#:~:text=,rendered%20images%20on%20the%20screen)). This stage (also called “layout” or “reflow”) figures out how to flow text, how big divs should be, where images are placed, etc., according to CSS rules and the HTML structure.  
- **Painting & Compositing:** Blink then paints the layout tree to generate draw commands (like “draw background, draw text”). In modern Chromium, this is often split into layers and handled by a compositor. Blink’s output is a set of painted layers or a display list, which is sent to the **compositing** system (often running partly on a separate **compositor thread**) to be assembled into the final screen bitmap. If GPU acceleration is enabled, rasterization of layers and compositing can be done in the GPU process. The final result is passed to the browser process to display on screen.  
- **Executing JavaScript (with V8):** Blink integrates with the V8 engine to run JavaScript code that can manipulate the DOM and CSSOM. For example, when script modifies the DOM (e.g., via `document.createElement` or changing element styles), Blink updates the DOM/tree and may trigger re-layout or repaint as needed. Many web platform APIs (like DOM methods, WebGL, etc.) are implemented as part of Blink’s code, often in C++, and exposed to JS via V8 bindings.

Blink is optimized heavily for performance. It implements features like **incremental layout and painting**, **layout invalidation** (to only recompute what’s necessary), and **compositing** (e.g. using separate layers for complex elements, offloading work to GPU when possible – see the RenderingNG architecture ([RenderingNG architecture | Chromium - Chrome for Developers](https://developer.chrome.com/docs/chromium/renderingng-architecture#:~:text=Developers%20developer,rendering%20pipeline%20flows%20through%20them))). Blink is also continuously updated to support the latest web standards (HTML5, CSS3/4, etc.). Its code resides in `src/third_party/blink` ([Blink (Rendering Engine)](https://www.chromium.org/blink/#:~:text=Blink%20is%20the%20name%20of,the%20code%20living%20under%20src%2Fthird_party%2Fblink)), but it uses an abstraction so that it doesn’t directly call OS APIs – it relies on the content layer to provide platform services (e.g. resource loading, graphics) via an embedding API (historically called “WebKit API”) ([How Chromium Displays Web Pages](https://www.chromium.org/developers/design-documents/displaying-a-web-page-in-chrome/#:~:text=,commands%20across%20the%20process%20boundary)). In short, Blink handles the heavy lifting of turning web code into an interactive page within each renderer process.

### JavaScript Engine: V8

**V8** is Chromium’s high-performance **JavaScript and WebAssembly engine**. It runs inside each renderer process to execute the JS code for web pages. V8 is a separate open-source project (also used in Node.js), but in Chrome it’s embedded in Blink’s environment. Key aspects of V8 include:

- **Just-In-Time (JIT) Compilation:** V8 doesn’t interpret JavaScript line-by-line; it dynamically compiles JS code into native machine code for speed ([Deep Dive into Chromium: A Comprehensive Analysis from Architecture Design to Core Code | by happyer | Medium](https://medium.com/@threehappyer/deep-dive-into-chromium-a-comprehensive-analysis-from-architecture-design-to-core-code-8cc8d3a328e3#:~:text=V8%20is%20a%20high,main%20features%20of%20V8%20include)). It uses several tiers of compilation (ignition interpreter, TurboFan optimizing compiler) to balance startup speed and execution performance. Frequently-run functions get optimized aggressively, which is why Chrome can run complex web apps and games efficiently.  
- **Memory Management & Garbage Collection:** V8 manages memory for JS objects. It uses a garbage collector to automatically reclaim memory from objects that are no longer referenced ([Deep Dive into Chromium: A Comprehensive Analysis from Architecture Design to Core Code | by happyer | Medium](https://medium.com/@threehappyer/deep-dive-into-chromium-a-comprehensive-analysis-from-architecture-design-to-core-code-8cc8d3a328e3#:~:text=,isolation%20and%20sandboxing%20techniques%20to)). V8’s GC is generational and incremental, designed to minimize pause times so that web pages remain responsive.  
- **WebAssembly Support:** V8 also executes WebAssembly modules, which are compiled binary format for near-native performance. This allows web apps to run high-performance code (e.g. C++ compiled to WASM) inside the browser.  
- **Security:** V8 operates within the sandbox of the renderer process. It implements **sandboxing/isolated contexts** for things like iframes (each <iframe> can have its own V8 context, enforcing the Same-Origin Policy restrictions). If an attacker exploits a flaw in V8, the damage is contained by the renderer’s OS sandbox. V8 is designed with security in mind (e.g., pointer compression, control-flow integrity where possible) because issues in V8 can lead to JS engine exploits ([An Introduction to Chrome Exploitation - Maglev Edition - — uf0](https://www.matteomalvica.com/blog/2024/06/05/intro-v8-exploitation-maglev/#:~:text=An%20Introduction%20to%20Chrome%20Exploitation,Let%27s%20explore%20in%20more)).  

In Chromium’s architecture, each renderer has its own instance of V8. That means each tab or script context runs JS isolated from others (they can’t directly access each other’s memory). The browser process can also tell a renderer to occasionally pause or terminate scripts (e.g., via the dreaded “Page Unresponsive” dialog if a script is stuck). V8’s optimizations (like inline caching, hidden classes, and JIT) give Chrome its reputation for fast JavaScript execution ([Deep Dive into Chromium: A Comprehensive Analysis from Architecture Design to Core Code | by happyer | Medium](https://medium.com/@threehappyer/deep-dive-into-chromium-a-comprehensive-analysis-from-architecture-design-to-core-code-8cc8d3a328e3#:~:text=V8%20is%20a%20high,main%20features%20of%20V8%20include)). When you modify a web page via DevTools or run JS, it’s V8 in the renderer doing the work. V8 and Blink work hand-in-hand: Blink provides the DOM objects and API bindings, and V8 executes the script and calls into Blink’s implementations of web APIs.

### Networking Stack

Chromium has a built-in multi-platform **networking stack** (often called **Cronet** when used as a standalone library) for handling URL loads, HTTP(S) requests, websockets, etc. The networking code lives primarily in the `//net` directory and is used by the browser process (or a dedicated network service process) ([Life of a URLRequest](https://chromium.googlesource.com/chromium/src/+/HEAD/net/docs/life-of-a-url-request.md#:~:text=The%20network%20stack%20is%20located,is%20in%20the%20net%20namespace)) ([Life of a URLRequest](https://chromium.googlesource.com/chromium/src/+/HEAD/net/docs/life-of-a-url-request.md#:~:text=The%20Network%20Service%20and%20Mojo)). Key features of the network stack:

- It is centered around objects like **URLRequest** and **URLRequestContext**. A `URLRequest` represents a single network request (HTTP, HTTPS, file, data, etc.) and the `URLRequestContext` holds common state like caches, cookies, proxy config, etc. ([Network Stack](https://www.chromium.org/developers/design-documents/network-stack/#:~:text=The%20network%20stack%20is%20a,use%20a%20dedicated%20thread%2C%20and)). High-level code (e.g. the content layer or network service) creates URLRequest objects to fetch resources.  
- The stack handles all the typical layers of network communication: DNS resolution, TCP/UDP socket connections, SSL/TLS handshakes, HTTP parsing, caching, proxies, authentication, etc. ([Life of a URLRequest](https://chromium.googlesource.com/chromium/src/+/HEAD/net/docs/life-of-a-url-request.md#:~:text=The%20top,process%20usually%20managed%20by%20URLRequestContextBuilder)) ([Life of a URLRequest](https://chromium.googlesource.com/chromium/src/+/HEAD/net/docs/life-of-a-url-request.md#:~:text=The%20HttpNetworkSession%20is%20another%20major,more%20directly%20deal%20with%20sockets)). For example, when a renderer process needs to load an image or script from the network, it will send an IPC to the browser’s network code (using Mojo in newer versions) and the network stack will initiate the request, manage redirects, cookies, and so on.  
- Chromium’s network stack is asynchronous and highly optimized. It uses a single “IO thread” (in the browser or network process) to avoid blocking on network calls ([Network Stack](https://www.chromium.org/developers/design-documents/network-stack/#:~:text=The%20network%20stack%20is%20a,may%20use)). All network operations use non-blocking callbacks (e.g., a completion callback when data is read) and if needed, worker threads for DNS or disk cache so the main IO thread isn’t stalled ([Network Stack](https://www.chromium.org/developers/design-documents/network-stack/#:~:text=Many%20URLRequest%20objects%20may%20share,friendly%20format%20for%20debugging%20purposes)). This design keeps Chrome responsive even during heavy networking.  
- The network stack has support for modern protocols and features: HTTP/2, HTTP/3 (QUIC), WebSockets, caching, content encoding (gzip/etc.), and implements security features like certificate verification and **Content Security Policy** checks. It logs events to a **NetLog** which developers can use to debug network issues in Chrome ([Network Stack](https://www.chromium.org/developers/design-documents/network-stack/#:~:text=several%20components%20,friendly%20format%20for%20debugging%20purposes)). 

In older Chrome, the network code ran inside the browser process. As part of **“servicification”**, Chromium introduced a **Network Service** that can run in its own process (or still in-browser depending on configuration) ([Life of a URLRequest](https://chromium.googlesource.com/chromium/src/+/HEAD/net/docs/life-of-a-url-request.md#:~:text=Networking%20in%20the%20browser%20ranges,encrypted%20bytes%20on%20a%20socket)) ([Life of a URLRequest](https://chromium.googlesource.com/chromium/src/+/HEAD/net/docs/life-of-a-url-request.md#:~:text=The%20Network%20Service%20and%20Mojo)). In modern versions, Chrome often runs a **Network Process**: a sandboxed utility process that hosts the network service. The network service exposes Mojo interfaces (in the `network::mojom` namespace) for operations like fetching URLs ([Life of a URLRequest](https://chromium.googlesource.com/chromium/src/+/HEAD/net/docs/life-of-a-url-request.md#:~:text=The%20network%20service%2C%20which%20lives,object%E2%80%99s%20methods%20are%20invoked%2C%20it)). Renderer processes do not open sockets directly; they make requests via Mojo IPC to the network service, which then uses the `//net` stack to perform the actual network IO. This out-of-process network model further isolates potentially vulnerable code (e.g., image parsing, cookie handling) from the renderer and even from the browser process. On desktop, the network service might still run in the browser process for performance, but on some platforms (like Android) it runs in a separate process by default ([Alex Xu على X: "How does Chrome work? The diagram below shows ...](https://x.com/alexxubyte/status/1691471011085172737?lang=ar#:~:text=Alex%20Xu%20%D8%B9%D9%84%D9%89%20X%3A%20,process%2C%20GPU%20process%2C%20and%20plugin)).

In summary, Chromium’s network subsystem (whether in the browser or a dedicated process) is a full-featured HTTP stack that fetches web content for the renderers. It ensures compliance with web protocols and enforces security policies (like same-origin checks for certain requests, CORS handling, etc.). If you modify the network stack (for instance, to change how HTTP headers are handled), you would be working in the `net/` directory or the `services/network` code, and the browser process (or network service) would incorporate those changes when serving resource requests.

### Inter-Process Communication (IPC) with Mojo

With so many processes, **Inter-Process Communication** is critical. Chromium uses a custom IPC framework called **Mojo** for message passing between processes. Mojo provides a set of **message pipes** and **interfaces** (defined in `.mojom` files) that different processes use to coordinate actions. For example, when a web page in a renderer needs to open a URL, it might call a Blink function that in turn sends a Mojo message to the browser process’s “Navigation” interface. The browser process then performs the action (via network stack) and replies via Mojo.

Key points about Chromium’s IPC (Mojo) system:

- Mojo is essentially a platform-agnostic RPC mechanism. Developers define interfaces (similar to WebIDL or protobuf) in `.mojom` files. The build generates stub code, and objects in different processes can call these methods as if they were local – under the hood Mojo sends the messages across processes.  
- Mojo can transmit basic types and complex structures (defined in the mojom), and also has the concept of passing handles (like a file descriptor or a shared memory region) between processes. This is used for things like transferring a decoded image from a utility process to a renderer, or a handle to a GPU context, etc.  
- Chromium previously had a legacy IPC system (called Chrome IPC) with manually written message macros. Mojo is the modern replacement and is used extensively in newer parts of Chrome (often called the **services** architecture). Many subsystems (network service, audio service, etc.) are implemented as services with Mojo interfaces, making it easier to run them in different processes.  
- The communication is asynchronous. For instance, the browser may send an IPC to a renderer to instruct it to create a new document or to run some script (e.g., in response to a user clicking a link). The renderer, in turn, sends IPCs for events like “this DOM element was clicked” or “this portion of the page is ready to paint.” These go through Mojo channels (which internally might use platform primitives like shared memory, named pipes, etc., depending on OS).  

From a developer perspective, you typically don’t have to deal with low-level Mojo details unless you are modifying how processes communicate or adding new cross-process features. Just be aware that almost all crossing of boundaries (e.g., renderer telling browser about something, or vice versa) is done via defined Mojo IPC calls ([Multi-process Architecture](https://www.chromium.org/developers/design-documents/multi-process-architecture/#:~:text=Each%20renderer%20process%20has%20a,or%20Chromium%27s%20legacy%20IPC%20system)). In the code, these often show up as calls to `…Host->Send(...)` or implementing a `Foo.mojom` interface in a process. For example, the **RenderProcessHost** in the browser holds the Mojo message pipe to communicate with the **RenderProcess** in the renderer ([Multi-process Architecture](https://www.chromium.org/developers/design-documents/multi-process-architecture/#:~:text=Each%20renderer%20process%20has%20a,or%20Chromium%27s%20legacy%20IPC%20system)). If you add a new feature that needs the renderer and browser to coordinate, you’d likely define a new Mojo interface for that.

### Sandboxing and Security

A cornerstone of Chromium’s architecture is **sandboxing**. The idea is to run risky components (like the rendering engine, which processes untrusted web content) in a process that has very limited operating system privileges ([
Chromium Blog: Multi-process Architecture
](https://blog.chromium.org/2008/09/multi-process-architecture.html#:~:text=Renderers,it%20suspects%20an%20exploit%20has)). If an attacker manages to exploit a vulnerability in Blink or V8, they only gain code execution in a sandboxed renderer process, which (ideally) cannot read your files, install programs, or snoop on other tabs.

Chromium’s sandbox implementation is OS-specific:

- **Windows:** Chrome’s sandbox on Windows is a user-mode sandbox that uses the OS security model (it does **not** require any custom kernel drivers) ([Chromium Docs - Sandbox](https://chromium.googlesource.com/chromium/src/+/main/docs/design/sandbox.md#:~:text=Sandbox%20Windows%20architecture)). The browser process acts as the **broker** and is launched with normal privileges. Renderer (and other) processes are launched as **target** processes with a **restricted token**, under a **Job Object**, on a separate **desktop**, and at low **integrity level** ([Chromium Docs - Sandbox](https://chromium.googlesource.com/chromium/src/+/main/docs/design/sandbox.md#:~:text=At%20its%20core%2C%20the%20sandbox,provided%20by%20four%20Windows%20mechanisms)). In practical terms, the renderer’s Windows process token is stripped of almost all rights: it can’t write to disk, can’t create windows on the user’s desktop, can’t access most OS resources. When the renderer needs to do something privileged (e.g. read a file for a `<input type=file>` upload), it must ask the browser process. The browser (broker) has a sandbox policy that decides if this action is allowed (for example, allowing file read only via a user prompt). If allowed, the browser process performs the action on behalf of the renderer and returns the result via IPC ([Chromium Docs - Sandbox](https://chromium.googlesource.com/chromium/src/+/main/docs/design/sandbox.md#:~:text=1,behalf%20of%20the%20target%20process)) ([Chromium Docs - Sandbox](https://chromium.googlesource.com/chromium/src/+/main/docs/design/sandbox.md#:~:text=1,The%20sandbox%20interceptions)). Most of the time, renderers don’t need such access; they just render content and communicate via safe IPCs. The sandbox is implemented by intercepting certain Windows API calls in the renderer and forcing them through the broker (for policy checks) ([Chromium Docs - Sandbox](https://chromium.googlesource.com/chromium/src/+/main/docs/design/sandbox.md#:~:text=The%20broker%20should%20always%20outlive,via%20IPC%20to%20the%20broker)) ([Chromium Docs - Sandbox](https://chromium.googlesource.com/chromium/src/+/main/docs/design/sandbox.md#:~:text=4)). This uses techniques like **API call hooking** and is all provided by Chromium’s sandbox library. Essentially, on Windows the renderer runs with an access token that has no capabilities, inside a Job that limits what it can do (e.g., no new processes), at low integrity (can’t write to higher integrity objects), and on an invisible desktop (can’t send UI messages to the real desktop). These layers make it extremely hard for a compromised renderer to affect the rest of the system ([Chromium Docs - Sandbox](https://chromium.googlesource.com/chromium/src/+/main/docs/design/sandbox.md#:~:text=mechanisms%3A)).  
- **Linux:** On Linux, Chromium uses a combination of namespaces (PID, network, etc.), seccomp-bpf system call filtering, and dropping privileges (using a setuid helper or cloning without certain capabilities) ([Secure Architecture - The Chromium Projects](https://www.chromium.org/Home/chromium-security/guts/#:~:text=Secure%20Architecture%20,site)). The renderer process is placed in a PID namespace (so it can’t see other processes), a new filesystem namespace (with limited access), and seccomp filters severely limit what syscalls it can use. Typically, Linux renderers cannot open sockets, cannot open files freely, etc. – they rely on the browser process (which has the privileges) to do those on their behalf, similar to Windows.  
- **Mac:** On macOS, Chrome’s sandbox uses the Seatbelt sandbox profiles (Apple’s sandbox facility). It loads a restrictive sandbox profile for renderers that blocks file system access, device access, etc.  
- **Android:** Android apps are sandboxed at the OS level per app, but Chrome for Android also uses additional sandboxing for renderers using the isolated process feature.  

In all cases, the **browser process is not sandboxed** (it needs full access to manage everything). So a core security principle is that *the browser process must handle untrusted data carefully*, since an exploit that jumps from renderer to browser (via an IPC exploit, for example) could break out of the sandbox. The Chromium team does extensive fuzzing and auditing of IPC interfaces and the browser code to harden it ([Review of Chromium IPC vulnerabilities | GitHub Security Lab](https://securitylab.github.com/resources/chromium-ipc-vulnerabilities/#:~:text=Review%20of%20Chromium%20IPC%20vulnerabilities,A%20remote%20code%20execution)). 

Other processes like the GPU process are also sandboxed (though the GPU process often has more privileges than a renderer, since it may need direct GPU driver access – on Windows, the GPU process has a slightly less restrictive token but still locked down). The network service process is similarly sandboxed (it might need socket access but little else). **Extension** processes run with the same privileges as renderers (they are essentially renderers for extension pages, with some extended API access but still subject to the sandbox for web content).

Overall, the sandbox means that merely *finding a bug* in Blink or V8 is not enough for a full Chrome exploit – an attacker would need a sandbox escape (a second vulnerability to break out of the sandbox). This layered approach (often called *“site isolation + sandbox”*) is what makes Chrome one of the more secure browsers ([Inside look at modern web browser (part 1)  |  Blog  |  Chrome for Developers](https://developer.chrome.com/blog/inside-browser-part1#:~:text=Another%20benefit%20of%20separating%20the,input%20like%20the%20renderer%20process)).

## Compiling and Modifying Chromium on Windows

Chromium is a massive C++ codebase, but it’s engineered with a build system that developers can set up on Windows fairly straightforwardly. Below is a step-by-step guide to setting up the build environment on Windows, fetching the source, building Chromium, and making/testing modifications to the code. We assume you’re using a 64-bit Windows 10 or later system.

### 1. Setup the Build Environment (Windows)

**System Requirements:** Ensure your machine meets the requirements. You’ll need a 64-bit Windows 10/11 OS, at least 8–16 GB of RAM (32+ GB recommended for faster builds), and **~100+ GB of free disk space** (the source repository and build files are very large) ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=System%20requirements)). An SSD and multi-core CPU will significantly speed up compilation. 

**Install Visual Studio:** Install **Visual Studio 2022** (Community or higher edition) with the **“Desktop development with C++” workload** ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=Chromium%20requires%20Visual%20Studio%202022,see%20below%20for%20ARM64%20instructions)). Make sure to include the **MFC/ATL support** component as well (Chromium requires ATL/MFC libraries) ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=Chromium%20requires%20Visual%20Studio%202022,see%20below%20for%20ARM64%20instructions)). The Visual Studio installer UI lets you select these; alternatively, you can install via command line with the appropriate flags (as shown in Chromium’s docs) ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=appropriate%20for%20you,see%20below%20for%20ARM64%20instructions)). You also need the **Windows 10 or 11 SDK** (VS installer can add this) ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=Required)). After installing, it’s recommended (but not strictly required) to install the Windows SDK Debugging Tools – these help in handling large PDB debug symbol files Chrome generates ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=Required)).

**Install Python:** Ensure you have Python 3 installed (though the Chromium depot tools bundle will bring its own Python). Having it in PATH is usually not necessary since depot tools includes a Python wrapper, but if you have a global Python, make sure it’s 64-bit and a relatively recent version.

### 2. Fetching the Source Code (Depot Tools)

Chromium’s source is hosted in a Git repository and uses Google’s **depot_tools** to manage the many dependencies. Follow these steps:

- **Get depot_tools:** Depot tools is a collection of scripts for fetching and building Chromium. Clone the `depot_tools` repo to your machine (for example, to `C:\src\depot_tools`): 

   ```shell
   C:\> mkdir C:\src
   C:\> cd C:\src
   C:\src> git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
   ``` 

  This will create a `depot_tools` directory with various scripts ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=From%20a%20command%20shell%2C%20navigate,For%20example%2C%20if%20you%20want)). Add this `depot_tools` path to your **PATH environment variable** (and ensure it’s added **before** any other Git or Python in your PATH) ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=Add%20depot_tools%20to%20the%20start,variable%20names%20are%20case%20insensitive)). You can edit the System Environment Variables on Windows to prepend `C:\src\depot_tools` to PATH. This is important because depot_tools comes with its own Git and Python wrappers that need to take precedence. 

- **Configure depot_tools for Windows:** Set the environment variable `DEPOT_TOOLS_WIN_TOOLCHAIN=0` in your user or system environment ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=match%20at%20L160%20Also%2C%20add,internal%20version)). This tells the tools *not* to try to download a Google-internal toolchain, and instead use the Visual Studio installation you set up. After setting PATH and this variable, open a **new** Command Prompt to ensure the changes take effect. You can test by running `where gn` or `where gclient` – it should show the tools from `depot_tools`. 

- **Fetch the Chromium code:** Choose a directory for the Chromium source (e.g. `C:\src\chromium`). In the Command Prompt, run: 

   ```shell
   C:\> mkdir C:\src\chromium && cd C:\src\chromium
   C:\src\chromium> fetch --no-history chromium
   ``` 

  This `fetch` command (provided by depot_tools) will pull down the Chromium source and all its dependencies. The `--no-history` flag is optional but recommended for faster fetch; it avoids downloading the entire Git history ([Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/3eb645cc/docs/windows_build_instructions.md#:~:text=%24%20fetch%20chromium)) (saving a lot of time and space). Without `--no-history`, expect a much larger download. The fetch can easily take 30 minutes to a few hours depending on your connection, as it downloads tens of gigabytes. When done, you will have a `src` subdirectory containing the main source tree ([Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/3eb645cc/docs/windows_build_instructions.md#:~:text=When%20,directory)). (If you run into problems, make sure Git is up to date, as depot_tools might have installed a specific Git – outdated Git can cause issues with the large repository.)

- **Git setup:** It’s a good idea to set your Git name/email before fetching (if you didn’t already) so you can make local commits. For example: `git config --global user.name "Your Name"` ([Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/3eb645cc/docs/windows_build_instructions.md#:~:text=First%2C%20configure%20Git%3A)). The Chromium docs also suggest `core.autocrlf=false` and `core.filemode=false` for consistency ([Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/3eb645cc/docs/windows_build_instructions.md#:~:text=%24%20git%20config%20,global%20branch.autosetuprebase%20always)), but if you use the provided tools, those might be set automatically.

After the fetch, you should have a `C:\src\chromium\src` directory. All commands below assume you’re working from the `src` directory (i.e., `cd C:\src\chromium\src`). 

### 3. Configuring the Build (GN and Ninja)

Chromium uses **GN** (Generate Ninja) to generate build files, and **Ninja** as the build tool ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=Chromium%20uses%20Ninja%20as%20its,To%20create%20a%20build%20directory)). The source comes with many BUILD.gn files describing how to build each component. We first need to create a build output directory and run GN to configure the build:

- **Generate build files with GN:** From the `src` directory, run: 

   ```shell
   C:\src\chromium\src> gn gen out\Default
   ``` 

  This creates a default output directory `out/Default` and generates Ninja build files in it ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=Chromium%20uses%20Ninja%20as%20its,To%20create%20a%20build%20directory)) ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=%24%20gn%20gen%20out)). By default, this will configure a **Debug** build with component builds (meaning Chrome is built as many separate DLLs, which is good for development) on the current platform (x64). You only need to run `gn gen` once per output directory. You can create other build dirs with different names/configs (e.g. `out\Release` for an optimized build) by running `gn gen out\Release --args="is_official_build=true is_debug=false ..."`. If you want to adjust build settings, you can run `gn args out\Default` to open an editor and set GN args (or specify `--args=...` in the gen command). For example, to make a release build you’d set `is_debug=false enable_nacl=false is_official_build=true dcheck_always_on=false` (there are preset `is_official_build` configs used by Google’s release builds). For most development purposes, the default Debug configuration is fine.

  **Tip:** The default build is extremely large and enables debugging for everything. To speed up build times, you can set some GN args before building. Common suggestions are: `is_component_build=true` (already true by default for Debug) so that the build is split into DLLs (making incremental linking faster) ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=%2A%20%60is_component_build%20%3D%20true%60%20,don%27t%20plan%20to%20debug%20blink)), and disabling optional components you don’t need (for instance, `enable_nacl=false` to skip Native Client) ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=%2A%20%60is_component_build%20%3D%20true%60%20,build%20times%20may%20get%20worse)). You can also lower symbol levels for Blink/V8 if you’re not debugging those (`blink_symbol_level=0`, `v8_symbol_level=0`) to reduce debug info size ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=%2A%20%60target_cpu%20%3D%20%22x86%22%60%20,don%27t%20plan%20to%20debug%20v8)). These can be set via `gn args`. Also, as noted in Chromium’s docs, faster disks and more CPU cores significantly help build speed ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=Faster%20builds)).

- **Ensure you have the right toolchain:** GN should automatically pick up the VS installation and use the bundled Clang compiler. Depot_tools manages the Clang toolchain (it will download a specific version of Clang on first build via a script). If GN or later steps complain about missing compilers, you may need to run `gclient runhooks` (which is run by `fetch` automatically) or fix environment issues. Normally, after `fetch chromium` and `gn gen`, the hooks that download Clang, etc., have already run.

At this point, you have a configured build directory with Ninja files ready.

### 4. Building Chromium with Ninja

Now you can compile the browser. Chromium’s build is huge, so the first build will take a long time (possibly hours). Ninja will utilize multiple cores to compile in parallel.

- **Start the build:** Run Ninja specifying the build directory and the Chrome target: 

   ```shell
   C:\src\chromium\src> ninja -C out\Default chrome
   ``` 

  This compiles the “chrome” target (the browser itself) in the `out/Default` directory ([Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/3eb645cc/docs/windows_build_instructions.md#:~:text=Build%20Chromium%20,using%20the%20command)). The `-C out\Default` tells Ninja which build output to use. The first time, this will compile thousands of files. Subsequent builds are incremental – Ninja will compile only files that changed or depend on changed files. (For convenience, `autoninja -C out\Default chrome` can be used – it’s a wrapper that automatically uses optimal parallelism and is aware of your system cores.)

  The build output will produce an executable **`chrome.exe`** (and many DLLs) in `out\Default`. The first build can easily consume 100 GB or more of disk (with all the object files and large PDB debug symbols). Ensure you have enough space. If the build succeeds, you’ll see a final link step for chrome.dll or chrome.exe and no error messages.

- **Optional: compile specific components or tests:** You don’t always need to build the entire browser. For example, if you are working on just one component (say, the network library), you can build a smaller target like `net_unittests`. You can list all build targets with `gn ls out\Default` ([Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/3eb645cc/docs/windows_build_instructions.md#:~:text=You%20can%20get%20a%20list,C%20out%2FDefault%20chrome%2Ftest%3Aunit_tests)). To build a target, run `ninja -C out\Default <target_name>`. Common targets include `chrome` (the browser), `chrome_public_test_support` (some test support libs), `unit_tests` (all unit tests), `content_shell` (a minimal content module based browser used for testing), etc. However, building `chrome` ensures all of Chromium is built, which is necessary if you plan to run the full browser with your changes.

### 5. Running and Testing your Build

Once built, you can run the Chromium build and also run tests:

- **Run the browser:** Launch the compiled browser via: 

   ```shell
   C:\src\chromium\src> out\Default\chrome.exe
   ``` 

  This will open Chromium (often identified as “Chromium” rather than “Google Chrome” since it’s the unbranded build). You can create a separate user profile for this build so it doesn’t interfere with your normal Chrome profile. When running from the build output, Chromium uses a distinct user-data directory by default (e.g., in `%LOCALAPPDATA%\Chromium\User Data\Default`). You can also pass flags, e.g., `out\Default\chrome.exe --user-data-dir=c:\temp\chromium-profile --enable-features=...` to test certain features. This is the full browser with all your local changes, so you can navigate to websites and see how your modifications behave.

- **Run tests:** Chromium has an extensive test suite. For example, to run basic unit tests, you can run the `unit_tests` binary:

   ```shell
   C:\src\chromium\src> out\Default\unit_tests.exe --gtest_filter="*Blink*"
   ``` 

  This will run the unit tests (you can filter which tests to run with `--gtest_filter` wildcard) ([Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/3eb645cc/docs/windows_build_instructions.md#:~:text=You%20can%20run%20the%20tests,gtest_filter%60%20arg%2C%20e.g)). There are also content tests, browser tests, etc., each with their own target (e.g., `content_unittests.exe`, `browser_tests.exe` which requires a special command to run, etc.). Running tests can help verify that your changes didn’t break anything. GoogleTest is used for C++ tests ([Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/3eb645cc/docs/windows_build_instructions.md#:~:text=%24%20out%5CDefault%5Cunit_tests.exe%20)). You can find test results or crashes in the output logs if something fails.

- **Iterate as needed:** If you make further changes to the code, simply re-run the ninja build command. Ninja will recompile the changed files and their dependencies. Thanks to GN’s dependency tracking, it won’t rebuild everything each time – only what’s needed. Still, some changes (like to core headers) can cause large rebuilds. Using the tips mentioned (component build, fewer symbols) can reduce rebuild times for iterative development ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=%2A%20%60is_component_build%20%3D%20true%60%20,don%27t%20plan%20to%20debug%20blink)).

### 6. Making Modifications to Core Components

With the build up and running, you can now experiment with Chromium’s internals. Here are some guidelines for modifying core components like Blink or the network stack:

- **Understanding the Code Structure:** Chromium’s source is large and organized into many directories. Key ones related to core browser internals include:
  - `//content`: The content module – high-level browser logic, multi-process glue, WebContents, etc.
  - `//third_party/blink`: Blink engine source (split into `renderer/core/`, `renderer/modules/`, etc. for DOM, and `renderer/platform/` for lower-level platform abstraction, among others).
  - `//v8`: V8 engine source code (though note that V8 is maintained upstream; you can modify it, but it’s a separate project).
  - `//net`: Networking library (HTTP, etc.).
  - `//services/network`: The Network Service implementation using the `net` stack.
  - `//ipc` and `//mojo`: IPC layer code.
  - `//chrome`: The browser UI layer (platform-specific code for the Chrome application – since we’re excluding UI, you may not touch this much for core changes).
  
  If you want to change rendering behavior, you will likely look at Blink’s code. For example, parsing behavior might be in `third_party/blink/renderer/core/html/parser/` or layout code under `.../core/layout/`. If you want to change something in how networking works, you might edit files under `net/` (for low-level changes) or `services/network` (for how the network service interacts). 

- **Making the change:** Open the files in your editor or IDE, and make your changes in C++ (or JavaScript, etc., depending on the component). For instance, you could modify a constant, add a logging `printf`, or alter a function’s logic. Because Chromium is so large, a good way to locate what to change is using search tools – the code search at <https://source.chromium.org> is extremely helpful ([Getting Around the Chromium Source Code Directory Structure](https://www.chromium.org/developers/how-tos/getting-around-the-chrome-source-code/#:~:text=Getting%20Around%20the%20Chromium%20Source,documentation%20is%20no%20longer%20accurate)). You can search for keywords or functions to find where in the source a behavior is implemented.

- **Build and run:** After editing, compile again with Ninja. If it’s a small change, the incremental build might take only a few seconds or minutes. Then launch `chrome.exe` from the out directory and navigate to a test page to see the effect of your change. For example, if you changed a rendering behavior (say how a certain CSS property is handled), load a page that uses that property and observe if it behaves differently. For network changes, you might use Developer Tools or a test server to see if network requests have the modified behavior.

- **Debugging:** If your change doesn’t work as expected, you can use a debugger. You can attach Visual Studio’s debugger to the running `chrome.exe` (or launch it under the debugger). You may also generate a Visual Studio project via GN to assist in debugging: run `gn gen --ide=vs out\Default` to create an `all.sln` solution ([Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/3eb645cc/docs/windows_build_instructions.md#:~:text=If%20you%20want%20to%20use,the%20get%20the%20code%20page)). Opening this in Visual Studio will let you browse the code and set breakpoints. Note that the solution will be huge (thousands of projects) and Visual Studio may be slow to load it. You can limit the generated projects by using GN’s `--filters` to include only certain paths ([Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/3eb645cc/docs/windows_build_instructions.md#:~:text=The%20generated%20solution%20will%20contain,show%20any%20source%20files%20is)) – for example, `gn gen --ide=vs --filters="//content/*;//third_party/blink/*" out\Default`. This creates a smaller solution focusing on content and Blink. Even without a full solution, Visual Studio’s **Debug -> Attach to Process** works fine; you just need the PDBs (which are generated in a Debug build) to get symbols. Logging (using `LOG(INFO) << "message";`) is another simple way to debug – logs will appear in the console or in debug output.

- **Testing your changes:** In addition to manual testing, consider running relevant unit tests. If you modified Blink’s parsing, run Blink layout tests or unit tests to see if you broke something. The Chromium project has **LayoutTests** (Web Platform Tests) that can be run via content_shell, and many unit test binaries. For example, after a network change, run `net_unittests.exe` to ensure all network tests pass. This helps verify that your modification doesn’t introduce regressions.

- **Reiterate and refine:** It’s common to go through multiple edit-build-test cycles. The component build and Ninja’s incremental compilation make this relatively efficient, but it can still be time consuming depending on the change. Use the tips from the docs (like enabling faster linking with `symbol_level` settings) if you find rebuilds too slow ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=%2A%20%60is_component_build%20%3D%20true%60%20,don%27t%20plan%20to%20debug%20blink)) ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=In%20order%20to%20speed%20up,requires%20recompiling%20everything)).

Remember, building Chromium on Windows is resource-intensive but very rewarding for understanding the browser. By exploring its subsystems (Blink, V8, network, etc.) and tweaking them, you’ll gain deep insight into how a modern browser works. Use official documentation and community guides for reference ([Content module](https://chromium.googlesource.com/chromium/src/+/HEAD/content/README.md#:~:text=The%20%E2%80%9Ccontent%E2%80%9D%20module%20is%20located,extensions%2Fautofill%2Fspelling%20etc)) ([Deep Dive into Chromium: A Comprehensive Analysis from Architecture Design to Core Code | by happyer | Medium](https://medium.com/@threehappyer/deep-dive-into-chromium-a-comprehensive-analysis-from-architecture-design-to-core-code-8cc8d3a328e3#:~:text=,rendered%20images%20on%20the%20screen)), and don’t hesitate to search the Chromium codebase for examples of how things are implemented. Good luck, and happy hacking on Chromium!

**Sources:**

- Chromium Multi-process Architecture ([Multi-process Architecture](https://www.chromium.org/developers/design-documents/multi-process-architecture/#:~:text=We%20refer%20to%20the%20main,interpreting%20and%20laying%20out%20HTML)) ([
Chromium Blog: Multi-process Architecture
](https://blog.chromium.org/2008/09/multi-process-architecture.html#:~:text=Renderers,it%20suspects%20an%20exploit%20has))  
- Chrome Developer Blog – *Inside look at modern web browser* (Architecture, Site Isolation) ([Inside look at modern web browser (part 1)  |  Blog  |  Chrome for Developers](https://developer.chrome.com/blog/inside-browser-part1#:~:text=At%20the%20top%20is%20the,see%20Site%20Isolation)) ([Inside look at modern web browser (part 1)  |  Blog  |  Chrome for Developers](https://developer.chrome.com/blog/inside-browser-part1#:~:text=Process%20and%20What%20it%20controls,multiple%20apps%20and%20draw%20them))  
- Chromium Content Module README ([Content module](https://chromium.googlesource.com/chromium/src/+/HEAD/content/README.md#:~:text=The%20%E2%80%9Ccontent%E2%80%9D%20module%20is%20located,extensions%2Fautofill%2Fspelling%20etc)) ([Content module](https://chromium.googlesource.com/chromium/src/+/HEAD/content/README.md#:~:text=See%20an%20older%20diagram%20at%3A,module))  
- Chromium Sandbox Design (Windows) ([Chromium Docs - Sandbox](https://chromium.googlesource.com/chromium/src/+/main/docs/design/sandbox.md#:~:text=1,behalf%20of%20the%20target%20process)) ([Chromium Docs - Sandbox](https://chromium.googlesource.com/chromium/src/+/main/docs/design/sandbox.md#:~:text=At%20its%20core%2C%20the%20sandbox,provided%20by%20four%20Windows%20mechanisms))  
- Chromium Networking (Net stack and Network Service) ([Network Stack](https://www.chromium.org/developers/design-documents/network-stack/#:~:text=The%20network%20stack%20is%20a,use%20a%20dedicated%20thread%2C%20and)) ([Life of a URLRequest](https://chromium.googlesource.com/chromium/src/+/HEAD/net/docs/life-of-a-url-request.md#:~:text=The%20Network%20Service%20and%20Mojo))  
- *Deep Dive into Chromium* (Medium) – Blink and V8 overview ([Deep Dive into Chromium: A Comprehensive Analysis from Architecture Design to Core Code | by happyer | Medium](https://medium.com/@threehappyer/deep-dive-into-chromium-a-comprehensive-analysis-from-architecture-design-to-core-code-8cc8d3a328e3#:~:text=,rendered%20images%20on%20the%20screen)) ([Deep Dive into Chromium: A Comprehensive Analysis from Architecture Design to Core Code | by happyer | Medium](https://medium.com/@threehappyer/deep-dive-into-chromium-a-comprehensive-analysis-from-architecture-design-to-core-code-8cc8d3a328e3#:~:text=V8%20is%20a%20high,main%20features%20of%20V8%20include))  
- Official Chromium Build Instructions (Windows) ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=Chromium%20requires%20Visual%20Studio%202022,see%20below%20for%20ARM64%20instructions)) ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=Add%20depot_tools%20to%20the%20start,variable%20names%20are%20case%20insensitive)) ([Chromium Docs - Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#:~:text=Chromium%20uses%20Ninja%20as%20its,To%20create%20a%20build%20directory))