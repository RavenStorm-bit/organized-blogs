Got it. I’ll analyze the source code of the most advanced and difficult-to-reverse obfuscation tool among those you listed—**Garble**—with a deep technical dive into how it works under the hood.

I'll provide an annotated source code guide covering its major components like identifier mangling, string literal obfuscation, and control-flow flattening, with clear explanations and references to specific files/functions. I’ll get back to you once the deep dive is ready.

# Garble: Obfuscation Tool for Go – Code Walkthrough

## Identifier Name Mangling

One of Garble’s core techniques is **identifier obfuscation**. It replaces as many meaningful names (functions, variables, types, etc.) as possible with short, opaque strings – typically base64-like hashes ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=,tiny%60%20flag%20is%20given)). For example, a function named `CalculateSum` might become something like `ab83jf` in the compiled binary. This mangling is deterministic per build: Garble computes a unique hash for each identifier based on the package context and a secret seed (the seed can be fixed or provided via `-seed` for reproducibility ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=By%20default%2C%20garble%20will%20obfuscate,those%20inputs%20is%20very%20hard))). The implementation uses Go’s AST and type information to traverse each identifier and assign a new name. 

In the transformation phase, Garble walks the AST of each file and for every `ast.Ident` (identifier node), decides whether to rename it. It leverages the Go `types` info to understand what each identifier represents. For instance, if the identifier is a function or variable that can be safely renamed, Garble calls an internal `hashWithPackage` function to produce a short hash name unique to that package ([github.com](https://github.com/burrowers/garble/raw/refs/heads/master/main.go#:~:text=%2B%20name%29%20,case%20%2Atypes.Func%3A%20if)). The snippet below (from Garble’s assembly transformer) illustrates this approach – it hashes an assembly label name using the package’s hash seed (called `GarbleActionID`): 

```go
if lpkg.ToObfuscate && !compilerIntrinsics[lpkg.ImportPath][name] {
    newName := hashWithPackage(lpkg, name)
    if flagDebug {
        log.Printf("asm name %q hashed with %x to %q", name, tf.curPkg.GarbleActionID, newName)
    }
    buf.WriteString(newName)
} else {
    buf.WriteString(name)
}
``` 

 ([github.com](https://github.com/burrowers/garble/raw/refs/heads/master/main.go#:~:text=string%28remaining,are%20laid%20out%20in%20modules))

Similar logic applies to Go identifiers. Garble skips or treats certain names specially. **Exported methods are not currently obfuscated**, because changing their names could break interface compliance or reflection (this is a known limitation) ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=,3)). For example, if a type implements an interface or is exported for external use, its method names stay intact. Struct field names are obfuscated when possible, but Garble uses a consistent scheme per struct so that all references to a given field (including reflective ones like via `reflect.Type.FieldByName`) remain consistent. In the code, there’s a specialized `hashWithStruct` used for struct field names ([github.com](https://github.com/burrowers/garble/raw/refs/heads/master/main.go#:~:text=match%20at%20L784%20%2B%20name,case%20%2Atypes.Func%3A%20if)). Garble’s debug logs (enabled via `-debug`) show messages like *“hashed with struct fields to …”* which indicate a field name was replaced consistently across the struct ([github.com](https://github.com/burrowers/garble/raw/refs/heads/master/main.go#:~:text=match%20at%20L784%20%2B%20name,case%20%2Atypes.Func%3A%20if)). Identifiers that the Go runtime expects by name (e.g. certain runtime or cgo internals) are left untouched by checks like `compilerIntrinsics` in the code above. Overall, Garble aggressively renames user-defined identifiers to nonsensical names, removing useful hints from the binary ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=,tiny%60%20flag%20is%20given)).

## Package Path Obfuscation

Garble also **obfuscates package import paths** to hide module or project names. In Go binaries, package paths (like `github.com/username/project/pkg`) can appear in panics, stack traces, or reflect data. Garble replaces these with short hashes as well ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=,tiny%60%20flag%20is%20given)). Technically, this is done by altering the package path that the Go compiler sees for each package. When Garble invokes the compiler for a package, it overrides the `-p` flag (which sets the package import path) with an obfuscated path string. For example, if compiling package `example.com/foo/bar`, Garble might set the compiler flag `-p=ab83jf` (some hash) for that package. In the code, during the **toolexec** compile hook, Garble does: 

```go
flags = flagSetValue(flags, "-p", tf.curPkg.obfuscatedImportPath())
...
file.Name.Name = tf.curPkg.obfuscatedPackageName()
``` 

 ([github.com](https://github.com/burrowers/garble/raw/refs/heads/master/main.go#:~:text=requiredPkgs,tf.transformDirectives%28file.Comments%29%20file)) 

This ensures that the compiled package thinks its import path is the hashed value. All other packages that import it will be adjusted to import that hash instead of the real path. Garble’s logic updates the import configuration accordingly so that when package A (obfuscated) imports package B, it uses B’s obfuscated path. This is done by rewriting the `importcfg` file entries (`importmap oldPath=newPath`) for the compiler ([github.com](https://github.com/burrowers/garble/raw/refs/heads/master/main.go#:~:text=match%20at%20L505%20here,if%20err%20%21%3D%20nil)). Garble also directly edits the AST of source files to set the `package` declaration name to a fake name (ensuring any `reflect` on package names won’t leak the real name) ([github.com](https://github.com/burrowers/garble/raw/refs/heads/master/main.go#:~:text=stripRuntime%28basename%2C%20file%29%20tf.useAllImports%28file%29%20,writeSourceFile%28basename%2C%20basename%2C%20src%29%3B%20err)). 

Moreover, Garble removes or garbles any file path information embedded in the binary. It passes `-trimpath` to the compiler and linker (removing build paths), and it even uses `//line` directives to hide original filenames ([github.com](https://github.com/burrowers/garble/raw/refs/heads/master/main.go#:~:text=err%20%3A%3D%20printFile%28tf,flags)). For example, after Garble’s transformation, the Go source files are written to a temporary directory with hashed path names, and `//line` comments are injected so that any file references in debug data point to fake filenames ([github.com](https://github.com/burrowers/garble/raw/refs/heads/master/main.go#:~:text=err%20%3A%3D%20printFile%28tf,flags)). As a result, things like panic stack traces will show scrambled package paths and filenames instead of the originals.

Garble’s build process also strips module metadata. Normally, Go binaries may include the module path and version. Garble removes the module path info entirely ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=,tiny%60%20flag%20is%20given)). In fact, Garble even patches the Go linker to eliminate the `module lookup` section and other build details. (On startup, Garble uses a small patch on the linker binary to neuter module version info and build metadata – this is why Garble currently requires the `git` tool to apply this patch at runtime ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=,87)).) The end result is that after using Garble, the binary contains **no readable references to the original package names or file paths** – only the short hashed substitutes ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=,tiny%60%20flag%20is%20given)).

## Literal and String Obfuscation (`-literals` flag)

By default, even if names are stripped, a compiled Go binary might still reveal constant values like strings or numbers. Garble offers an opt-in **literal obfuscation** mode (enabled with **`-literals`**) to hide literal values such as strings. When this flag is on, Garble transforms every literal string (and certain other literals) into a piece of code that computes the same value at runtime instead of storing it in plaintext ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=Literal%20obfuscation)). In other words, a string like `"SECRET_KEY"` won’t appear in the binary; instead, Garble might emit something like:

```go
var s = func() string {
    // e.g. reconstruct "SECRET_KEY" at runtime
    data := []byte{0x14, 0x3F, 0x2A, ...}       // encrypted bytes
    key  := []byte{0x73, 0xA1, 0xC4, ...}       // key bytes
    for i := range data { data[i] ^= key[i] }   // simple XOR decrypt
    return string(data)
}()
``` 

*(The actual code varies, but the concept is that the literal is “encrypted” or encoded so it isn’t a constant.)* According to Garble’s documentation, **literal expressions are replaced with more complex expressions that yield the same value at runtime** ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=Using%20the%20%60,depending%20on%20the%20input%20code)). This includes strings, and can also include numbers or composite literals. Crucially, any string set via `-X ldflags` (linker-injected values) is handled as well ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=Using%20the%20%60,depending%20on%20the%20input%20code)). Garble detects linker-injected strings and ensures those are encoded so that the provided value doesn’t appear in cleartext in the binary either.

Internally, Garble’s `internal/literals` package provides multiple obfuscation strategies for literals. In the source, an `Obfuscators` list contains several techniques: **simple**, **swap**, **split**, **shuffle**, and **seed** ([literals package - mvdan.cc/garble/internal/literals - Go Packages](https://pkg.go.dev/mvdan.cc/garble/internal/literals#:~:text=%2F%2F%20Obfuscators%20contains%20all%20types,)). Garble will randomly choose one of these for each literal (using a PRNG seeded for deterministic output) ([GoStringUngarbler: Deobfuscating Strings in Garbled Binaries | Google Cloud Blog](https://cloud.google.com/blog/topics/threat-intelligence/gostringungarbler-deobfuscating-strings-in-garbled-binaries#:~:text=While%20garble%20can%20apply%20a,function%2C%20thwarting%20static%20string%20analysis)). For example: 

- **“Simple” (stack) transformation:** Generate a random key the same length as the string and apply a reversible operation (like XOR, ADD, NOT) on each byte ([GoStringUngarbler: Deobfuscating Strings in Garbled Binaries | Google Cloud Blog](https://cloud.google.com/blog/topics/threat-intelligence/gostringungarbler-deobfuscating-strings-in-garbled-binaries#:~:text=The%20obfuscator%20begins%20by%20generating,XOR)). The runtime code XORs the data with the key to recover the original string (both the encrypted data and key are embedded as byte arrays in the function). This results in a short loop or sequence of operations in the binary instead of a static string.  
- **Swap transformation:** Randomly swap pairs of characters in the string and record the swap positions. At runtime, swap them back. The garbled code will include instructions to unscramble the character order according to the recorded positions ([GoStringUngarbler: Deobfuscating Strings in Garbled Binaries | Google Cloud Blog](https://cloud.google.com/blog/topics/threat-intelligence/gostringungarbler-deobfuscating-strings-in-garbled-binaries#:~:text=Figure%203%3A%20Swap%20transformation%20implementation)) ([GoStringUngarbler: Deobfuscating Strings in Garbled Binaries | Google Cloud Blog](https://cloud.google.com/blog/topics/threat-intelligence/gostringungarbler-deobfuscating-strings-in-garbled-binaries#:~:text=The%20transformation%20begins%20by%20generating,a%20random%20number%20of%20additional)). This breaks up recognizable substrings in the binary.  
- **Shuffle transformation:** More elaborate – split the string into pieces, possibly XOR or encode pieces, and scatter them. The decrypting function uses two keys: one for content and one for ordering ([GoStringUngarbler: Deobfuscating Strings in Garbled Binaries | Google Cloud Blog](https://cloud.google.com/blog/topics/threat-intelligence/gostringungarbler-deobfuscating-strings-in-garbled-binaries#:~:text=match%20at%20L364%20Figure%205%3A,Shuffle%20transformation%20implementation)). This makes the bytes appear out-of-order in memory until the function reassembles them.  
- **Seeded transformation:** Apply an evolving encryption: start with a random seed and for each byte, encrypt it (e.g. XOR with seed or some operation), then update the seed based on that byte ([GoStringUngarbler: Deobfuscating Strings in Garbled Binaries | Google Cloud Blog](https://cloud.google.com/blog/topics/threat-intelligence/gostringungarbler-deobfuscating-strings-in-garbled-binaries#:~:text=Figure%207%3A%20Seed%20transformation%20implementation)). The decryption routine mirrors this process, making it look like a chain of computations rather than a static data table.

All these methods ensure the literal value isn’t stored verbatim. Instead of a load from a read-only data section, an analyst sees a computed value, which is much harder to decipher statically ([GoStringUngarbler: Deobfuscating Strings in Garbled Binaries | Google Cloud Blog](https://cloud.google.com/blog/topics/threat-intelligence/gostringungarbler-deobfuscating-strings-in-garbled-binaries#:~:text=binaries%2C%20function%20name%20mangling%2C%20and,encrypted%20strings)). (The Google Cloud **Mandiant** team notes that Garble’s string encryption, while not extremely complex, “significantly hinders static analysis” ([GoStringUngarbler: Deobfuscating Strings in Garbled Binaries | Google Cloud Blog](https://cloud.google.com/blog/topics/threat-intelligence/gostringungarbler-deobfuscating-strings-in-garbled-binaries#:~:text=advancements%20in%20Go%20analysis%20from,name%20mangling%2C%20and%20encrypted%20strings)).) Garble integrates this by running a literal obfuscation pass on each AST file after type-checking. In the code, we see a call to `literals.Obfuscate(tf.obfRand, file, tf.info, tf.linkerVariableStrings)` which returns a new AST where any eligible literal is replaced with a synthesized decrypting function call ([github.com](https://github.com/burrowers/garble/raw/refs/heads/master/main.go#:~:text=literals,Name%20if%20name)). This is done late in the compile transform, so that it doesn’t interfere with compile-time constants (any literal used in a `const` context is left as-is, since those must be known at compile time and cannot be turned into code) ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=Literals%20used%20in%20constant%20expressions,declaration%2C%20for%20example)). Because this transformation can bloat the code or slow it down (each literal becomes a mini function), it’s optional – developers opt in via `-literals` if they prioritize string hiding over a bit of performance ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=Using%20the%20%60,depending%20on%20the%20input%20code)).

*(Fun fact: since the transformations are deterministic given the seed, tools have been developed to **reverse** Garble’s string obfuscation. For example, Mandiant’s “GoStringUngarbler” can scan a garbled binary and recover the original strings by emulating the decryption routines ([GoStringUngarbler: Deobfuscating Strings in Garbled Binaries | Google Cloud Blog](https://cloud.google.com/blog/topics/threat-intelligence/gostringungarbler-deobfuscating-strings-in-garbled-binaries#:~:text=GoStringUngarbler%20is%20now%20available%20as,encountering%20samples%20obfuscated%20with%20garble%27s)) ([GoStringUngarbler: Deobfuscating Strings in Garbled Binaries | Google Cloud Blog](https://cloud.google.com/blog/topics/threat-intelligence/gostringungarbler-deobfuscating-strings-in-garbled-binaries#:~:text=For%20each%20string%2C%20the%20obfuscating,greater%20detail%20in%20subsequent%20sections)).)*

## Control-Flow Flattening (`//garble:controlflow`)

Garble includes an **experimental** feature for control-flow obfuscation, activated by a special source directive. If a function’s doc comment contains the directive `//garble:controlflow`, Garble will apply **control-flow flattening** to that function’s logic. (This feature is off by default – one must opt in for each function, and also enable the environment flag `GARBLE_EXPERIMENTAL_CONTROLFLOW=1` to activate the feature ([garble/docs/CONTROLFLOW.md at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/docs/CONTROLFLOW.md#:~:text=,GARBLE_EXPERIMENTAL_CONTROLFLOW%3D1)).) Control-flow flattening is a transformation that makes a function’s *execution flow* harder to understand by eliminating natural structures like loops and conditionals, and replacing them with a **dispatcher** loop that manually controls which block of code runs next ([garble/docs/CONTROLFLOW.md at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/docs/CONTROLFLOW.md#:~:text=,used%20in%20combination%20with%20flattening)) ([garble/docs/CONTROLFLOW.md at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/docs/CONTROLFLOW.md#:~:text=Block%20splitting%20splits%20the%20largest,splitting%20stops)). In a flattened function, all the original basic blocks of code are placed at the same level, and a synthetic state variable (dispatcher) decides the sequence in which those blocks execute ([Control Flow Flattening – Myst!qu3 S@lt](https://sreelakshmip.wordpress.com/2017/12/14/control-flow-flattening/#:~:text=,the%20enclosing%20loop%20and%20selection)). This is a known obfuscation technique (used in other obfuscators like Tigress for C, for example). The effect is that static analysis can no longer see high-level constructs (like “while loop” or “if-else”); instead, it sees a loop/switch that jumps to case labels in an opaque order, guided by a mutated state variable.

Garble’s implementation of this is notable because it operates on the SSA (Static Single Assignment) form of the function, rather than on the raw AST. When a package is being obfuscated, Garble will first compile the code in-memory to SSA to get a detailed view of its control-flow graph. For each function marked with the controlflow directive, Garble performs the following steps (summarized from Garble’s docs ([garble/docs/CONTROLFLOW.md at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/docs/CONTROLFLOW.md#:~:text=1.%20Collect%20functions%20with%20,Converts%20go%2Fssa%20back%20into%20go%2Fast))):

1. **Collect the function** – Identify the target function(s) via the `//garble:controlflow` comment ([garble/internal/ctrlflow/ctrlflow.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/internal/ctrlflow/ctrlflow.go#:~:text=for%20_%2C%20comment%20%3A%3D%20range,List)). Garble finds these in the AST and obtains their SSA representation ([garble/internal/ctrlflow/ctrlflow.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/internal/ctrlflow/ctrlflow.go#:~:text=path%2C%20_%20%3A%3D%20astutil,Pos)). It then removes the original function body from the AST (replacing it with an empty stub named `_` to effectively hide it) ([garble/internal/ctrlflow/ctrlflow.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/internal/ctrlflow/ctrlflow.go#:~:text=ssaFuncs%20%3D%20append)).  
2. **Build SSA and CFG** – Construct the function’s control-flow graph in SSA form.  
3. **Block splitting (optional)** – If the directive specifies `block_splits=N`, the largest basic blocks are split up to N times ([garble/internal/ctrlflow/ctrlflow.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/internal/ctrlflow/ctrlflow.go#:~:text=for%20range%20split%20)). This introduces additional “fake” branching structure even in straight-line code, which increases the complexity of the final flow ([garble/docs/CONTROLFLOW.md at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/docs/CONTROLFLOW.md#:~:text=Block%20splitting%20splits%20the%20largest,splitting%20stops)) ([garble/docs/CONTROLFLOW.md at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/docs/CONTROLFLOW.md#:~:text=%2F%2Fgarble%3Acontrolflow%20flatten_passes%3D0%20junk_jumps%3D0%20block_splits%3Dmax%20func,)). (In practice, this will insert extra jump points in long sequences of instructions so that the flattened version has more switch cases and jumps than strictly necessary.)  
4. **Junk jumps (optional)** – If `junk_jumps=M` is set, the tool will insert up to M bogus jump instructions in the SSA (these are jumps that go to the next instruction or do nothing useful) ([garble/internal/ctrlflow/ctrlflow.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/internal/ctrlflow/ctrlflow.go#:~:text=if%20junkCount%20)). These add confusion in the flattened graph – extra case labels that are logically redundant but make static analysis harder.  
5. **Control-flow flattening** – The main transformation: Garble creates a new CFG structure where all original basic blocks are now housed under a single loop. A new **dispatcher variable** (state variable) is introduced. The flattened code typically looks like a `for { switch(state) { case ...: ... } }` construct. Inside the switch, each original block becomes a `case` that executes that block’s code and then sets `state` to the next block’s label. All branches (`if`/`else`, `switch`) are replaced by assignments to the state variable. The loop continues until a special state indicates the end (e.g., a return sets state to 0 and the loop breaks) ([Control Flow Flattening – Myst!qu3 S@lt](https://sreelakshmip.wordpress.com/2017/12/14/control-flow-flattening/#:~:text=,the%20enclosing%20loop%20and%20selection)) ([Control Flow Flattening – Myst!qu3 S@lt](https://sreelakshmip.wordpress.com/2017/12/14/control-flow-flattening/#:~:text=int%20cond%20%3D%201%3B%20while,cond%20%21%3D%200)). In effect, **all basic blocks now share a single direct predecessor (the loop) and successor, flattening the hierarchy** ([Control Flow Flattening – Myst!qu3 S@lt](https://sreelakshmip.wordpress.com/2017/12/14/control-flow-flattening/#:~:text=The%20control%20flow%20flattening%20is,changes%20the%20dispatcher%20variable%20through)) ([Control Flow Flattening – Myst!qu3 S@lt](https://sreelakshmip.wordpress.com/2017/12/14/control-flow-flattening/#:~:text=The%20idea%20behind%20the%20control,block%20will%20be%20called%20next)). This makes the execution order difficult to discern without running the code.  
6. **Control-flow hardening (optional)** – If the directive includes `flatten_hardening` options, Garble will apply additional obfuscation to the dispatcher logic. For example, it can introduce opaque predicates or arithmetic that complicate how the next state is computed. The code shows a `dispatcherHardening` that can inject some code around the dispatcher values ([garble/internal/ctrlflow/ctrlflow.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/internal/ctrlflow/ctrlflow.go#:~:text=if%20len%28flattenHardening%29%20,0)) ([garble/internal/ctrlflow/ctrlflow.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/internal/ctrlflow/ctrlflow.go#:~:text=ssaRemap%20%3A%3D%20make%28map)). This further complicates reverse-engineering by making the state transitions less obvious.  
7. **Trash blocks (optional)** – If `trash_blocks=T` is specified, Garble injects *completely bogus basic blocks* into the SSA that are never actually reached, but are woven into the control-flow structure ([garble/internal/ctrlflow/ctrlflow.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/internal/ctrlflow/ctrlflow.go#:~:text=flattenHardening%20%3A%3D%20params.StringSlice%28)) ([garble/internal/ctrlflow/ctrlflow.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/internal/ctrlflow/ctrlflow.go#:~:text=if%20trashBlockCount%20)). These blocks contain nonsense computations (`math/rand` is used to generate them randomly) to bloat the function with dead code. The flattened dispatcher will include cases for these trash blocks as if they were real, confusing static analysis tools.  
8. **SSA to AST conversion** – After applying all the above transforms on the SSA, Garble converts the modified SSA back into a Go AST (using an internal `ssa2ast` tool). It produces a brand new `ast.File` containing the flattened function definition ([garble/internal/ctrlflow/ctrlflow.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/internal/ctrlflow/ctrlflow.go#:~:text=newFile%20%3D%20%26ast.File)) ([garble/internal/ctrlflow/ctrlflow.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/internal/ctrlflow/ctrlflow.go#:~:text=astFunc%2C%20err%20%3A%3D%20ssa2ast)). The new function has the same signature as the original and (critically) the same name. Garble inserts this new function into the package’s AST (in a new generated file named `GARBLE_controlflow.go`) ([garble/internal/ctrlflow/ctrlflow.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/internal/ctrlflow/ctrlflow.go#:~:text=const%20)) ([garble/internal/ctrlflow/ctrlflow.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/internal/ctrlflow/ctrlflow.go#:~:text=newFile%20%3D%20%26ast.File)). Because the original was removed (renamed to `_`), this new definition takes its place. All calls to the function now resolve to the obfuscated version seamlessly.

After these steps, the package is compiled with the obfuscated function. The **effect on the binary** is that the function’s body now looks like a big loop/switch with goto-like behavior, and any natural structure is lost. To illustrate, Garble’s documentation shows even a simple linear code becomes a tangle of labeled blocks and gotos when flattened ([garble/docs/CONTROLFLOW.md at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/docs/CONTROLFLOW.md#:~:text=Result%3A)) ([garble/docs/CONTROLFLOW.md at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/docs/CONTROLFLOW.md#:~:text=_s2a_l2%3A%20%7B%20println%28,goto%20_s2a_l1)). In more complex functions with nesting and conditionals, flattening makes the logic extremely difficult to follow by reading the disassembly or decompiled output. The figure below conceptually shows how a normal control-flow graph (left) is transformed by flattening (right):

 ([Control Flow Flattening – Myst!qu3 S@lt](https://sreelakshmip.wordpress.com/2017/12/14/control-flow-flattening/)) *Basic concept of control-flow flattening: original flow graph (left) vs. flattened dispatcher loop (right). All basic blocks (green, purple, pink, yellow) now appear in one level with a dispatcher (red) controlling the flow.* 

Garble allows some customization via the directive parameters: you can increase passes of flattening (to re-flatten any residual structure multiple times), add junk jumps, etc., as described above ([garble/internal/ctrlflow/ctrlflow.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/internal/ctrlflow/ctrlflow.go#:~:text=params%20%3A%3D%20ssaParams)) ([garble/internal/ctrlflow/ctrlflow.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/internal/ctrlflow/ctrlflow.go#:~:text=for%20range%20split%20)) ([garble/internal/ctrlflow/ctrlflow.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/internal/ctrlflow/ctrlflow.go#:~:text=if%20junkCount%20)). By default, `//garble:controlflow` with no parameters does one flattening pass with no junk or trash, which is already effective. Multiple passes are rarely needed beyond making the output even more verbose (the documentation warns that more than 3 passes is usually impractical) ([garble/internal/ctrlflow/ctrlflow.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/internal/ctrlflow/ctrlflow.go#:~:text=%2F%2F%20flatten_passes%20,not%20recommended%20in%20most%20cases)). All of this happens only if the special directive is present; other functions are left as-is (so you can choose which critical functions to obfuscate in this manner). The control-flow flattening feature is still experimental – it’s not enabled by default and may evolve, but it represents a “deep” obfuscation technique in Garble’s arsenal beyond the name and string encryption.

*(It’s worth noting that flattened code remains functionally correct and produces identical results as the original – Garble’s transformations preserve semantics. The obfuscation only affects readability. However, such transformations can make the code slower and larger. Flattening, for instance, adds overhead of the dispatch loop and disables some compiler optimizations. So, developers use it sparingly on sensitive functions.)*

## Build Integration with the Go Toolchain

Garble is designed to work as a wrapper around the standard Go build system ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=Obfuscate%20Go%20code%20by%20wrapping,5%20or%20later)) ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=,obfuscate%20panic%20stack%20traces)). Rather than re-implementing a Go compiler, Garble orchestrates the real Go compiler (`cmd/compile`) and linker (`cmd/link`) behind the scenes, intercepting their inputs and outputs to apply transformations. This integration is cleverly done using Go’s `-toolexec` feature. When you run `garble build ...`, the Garble program invokes the `go build` command internally with `-toolexec=garble` (along with some flags) ([garble/main.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/main.go#:~:text=var%20toolexecFlag%20strings)) ([garble/main.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/main.go#:~:text=toolexecFlag)). This means: *for each compile, assemble, or link action that Go needs to perform, it will call the Garble binary instead*, with the original tool’s name and arguments. Garble’s main function knows to detect this “toolexec” mode – if it’s invoked with, say, `garble toolexec compile ...`, it will load its obfuscation logic instead of acting like a normal `go` command ([garble/main.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/main.go#:~:text=func%20mainErr%28args%20%5B%5Dstring%29%20error%20)) ([garble/main.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/main.go#:~:text=case%20)).

To coordinate information between the top-level Garble process and each tool invocation, Garble uses a shared data structure (a cache of package info and decisions). On startup, Garble runs `go list -json` on the packages to build, gathering metadata like the import graph, package names, etc. It then decides on obfuscation details: for example, generating the hash seeds for each package, and determining each package’s obfuscated import path and hashed names for identifiers. This information is stored in an internal `sharedCache`. Garble then serializes this to a temporary file/directory and sets an env var `GARBLE_SHARED` so that child processes can access it ([garble/main.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/main.go#:~:text=%2F%2F%20Here%20is%20the%20only,place%20we%20initialize%20the%20cache)) ([garble/main.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/main.go#:~:text=sharedTempDir%2C%20err%20%3D%20saveSharedCache)). Each `garble toolexec` invocation (for a specific compile/link task) will open this cache (via `loadSharedCache`) to get the necessary data about what to do ([garble/main.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/main.go#:~:text=%2F%2F%20We%27re%20in%20a%20toolexec,directly%20called%20by%20the%20user)) ([garble/main.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/main.go#:~:text=var%20tf%20transformer)). The Go tool also provides the environment variable `TOOLEXEC_IMPORTPATH`, which tells Garble *which package* is being compiled in that invocation ([garble/main.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/main.go#:~:text=var%20tf%20transformer)). Garble uses that as a key to look up the package’s obfuscation info (the `listedPackage` record).

Depending on the tool being invoked, Garble then applies the appropriate transformations:

- **Compile (`garble toolexec compile`)** – This is the most complex case. Garble reads the original Go source files (the arguments passed to compile) and parses them into an AST (using `go/parser`). It then performs the obfuscation passes described above: renaming identifiers (using the precomputed maps and hash seeds), literal encryption (if `-literals` is enabled, calling `literals.Obfuscate` on the AST), embedding any new flattened functions (if control-flow flattening was requested, the new AST from `ctrlflow.Obfuscate` is merged in) ([github.com](https://github.com/burrowers/garble/raw/refs/heads/master/main.go#:~:text=cache%20to%20hit,path%2C%20err)) ([github.com](https://github.com/burrowers/garble/raw/refs/heads/master/main.go#:~:text=tf,return)), and so on. Essentially, Garble transforms the AST of the package *in memory* before compilation. After transformation, Garble pretty-prints the AST back to Go source code (these are the “obfuscated” source files). It writes these files to a temporary build directory (`sharedTempDir`) that mimics the package’s import path structure ([github.com](https://github.com/burrowers/garble/raw/refs/heads/master/main.go#:~:text=following%20curPkg%27s%20%2F%2F%20import%20path%2C,%2F%2F%20Assembly%20files)) ([github.com](https://github.com/burrowers/garble/raw/refs/heads/master/main.go#:~:text=do%20not%20support%20line%20directives,mainPackage)). (It also outputs a copy to a `-debugdir` if that flag is set, so the developer can inspect the obfuscated source). During this print phase, Garble uses special settings like adding `//line` directives so that the compiler doesn’t attribute errors to the temp file paths or reveal them in output ([github.com](https://github.com/burrowers/garble/raw/refs/heads/master/main.go#:~:text=err%20%3A%3D%20printFile%28tf,flags)). Once the modified source files are ready, Garble invokes the real Go compiler (`compile`) with the adjusted flags. The file paths given to the compiler now point to Garble’s generated code in the temp dir ([github.com](https://github.com/burrowers/garble/raw/refs/heads/master/main.go#:~:text=use%20the%20obfuscated%20import%20path,err%20%7D%20return)), and flags like `-p` (package path) and `-importcfg` (import mappings) are updated to use obfuscated paths ([github.com](https://github.com/burrowers/garble/raw/refs/heads/master/main.go#:~:text=requiredPkgs,tf.transformDirectives%28file.Comments%29%20file)) ([github.com](https://github.com/burrowers/garble/raw/refs/heads/master/main.go#:~:text=alterTrimpath%28flags%29%20newImportCfg%2C%20err%20%3A%3D%20tf,if%20basename)). The compiler then produces an object (.o or .a) for the package as usual, but this object now contains only the obfuscated names and data. Garble intercepts the compiler’s version output query (`-V=full`) as well, ensuring it doesn’t confuse Go’s build caching by injecting its own consistent build ID ([garble/main.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/main.go#:~:text=)) (so that two builds with the same inputs produce the same hash). 

- **Assemble (`garble toolexec asm`)** – If there are any assembly (.s) files (common in standard library or low-level packages), Garble filters those too. It reads each .s file and renames any symbols or references to match the obfuscated names. For instance, if a Go function `Foo` was renamed to `ab83jf`, the assembler directive `TEXT ·Foo(SB)` would be changed to `TEXT ·ab83jf(SB)`. The code uses a similar `hashWithPackage` logic on symbol names, skipping ones that are known intrinsics or must remain (via the `compilerIntrinsics` check) ([github.com](https://github.com/burrowers/garble/raw/refs/heads/master/main.go#:~:text=string%28remaining,are%20laid%20out%20in%20modules)). After processing, Garble writes out new .s files in the temp directory and calls the assembler with those. It also sets the `-p` flag for the assembler so that even in object metadata, the package path is hashed ([garble/main.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/main.go#:~:text=%2F%2F%20When%20assembling%2C%20the%20import,into%20the%20output%20object%20file)).

- **Link (`garble toolexec link`)** – Finally, when all packages are compiled, Go calls the linker to produce the final executable. Garble’s link hook performs a few last obfuscation steps. First, it uses an internal patcher to modify the linker binary’s behavior. Specifically, Garble’s `internal/linker` package can produce a patched version of the Go linker that *omits certain metadata* (like build info, module data) and can accept Garble’s special environment for stripping runtime signals etc. Garble obtains this patched linker (caching it per Go version) and uses it in place of the real linker ([garble/main.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/main.go#:~:text=if%20tool%20%3D%3D%20)) ([garble/main.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/main.go#:~:text=executablePath%20%3D%20modifiedLinkPath)). It sets environment variables (`GARBLE_LINK_X` flags) that the patched linker will recognize – for example, `GARBLE_TINY=true` if `-tiny` mode is on, along with two magic constants used to replace the panic message formats (the `MagicValueEnv` and `EntryOffKeyEnv` which correspond to constants used in the runtime’s panic table) ([garble/main.go at master · burrowers/garble · GitHub](https://github.com/burrowers/garble/blob/master/main.go#:~:text=os)). These ensure that in *tiny mode*, any references to the original program (like the panic text “unexpected fault address”) are either removed or replaced with dummy values. Garble also filters the link arguments for `-X name=value` (linker variable injection): it duplicates each such flag to refer to the obfuscated name of the variable as well, so that even though the variable was renamed, the value is properly set ([github.com](https://github.com/burrowers/garble/raw/refs/heads/master/main.go#:~:text=flagValueIter%28flags%2C%20%22,i%2B1)). If `-literals` is on, it will also have encoded that value in the binary and the init code will decode it, as discussed. After setting all that up, Garble launches the real (patched) linker with the (by now highly obfuscated) object files. The resulting binary is functionally the same as a normal build, but it contains minimal metadata – symbols are stripped (`-ldflags "-w -s"` is used by default ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=The%20tool%20wraps%20calls%20to,Go%20build%2C%20in%20order%20to))), module info is gone, names are hashed, file/line info is scrubbed, and strings are encrypted if requested.

Garble’s close coupling with the Go toolchain means it benefits from Go’s build caching and reproducibility. The obfuscation process is deterministic given the same inputs and seed, so the Go build cache can cache garbled package builds as well. In fact, Garble computes a unique **“Garble Action ID”** for each package that incorporates the package’s content hash, the Go compiler version, the Garble version, and the obfuscation seed ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=By%20default%2C%20garble%20will%20obfuscate,those%20inputs%20is%20very%20hard)). This ID is used to tag the cache. Garble maintains its own on-disk cache (`~/.cache/garble` by default) to store the resulting obfuscated package .a files ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=Garble%20also%20makes%20use%20of,GARBLE_CACHE)). On a subsequent build of the same code, if nothing relevant changed, Garble can skip re-obfuscating that package and reuse the cached artifact (it loads the cached package info from the shared cache file, and the compile step will find the .a in Go’s cache) ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=Garble%20obfuscates%20one%20package%20at,obfuscate%20modified%20code)) ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=Garble%20also%20makes%20use%20of,GARBLE_CACHE)). Garble’s `sharedCache` mechanism also stores the mapping from original names to hashed names so that the same names are used consistently across builds (unless the seed or code changes). This caching makes Garble reasonably fast – the first build with Garble may take roughly twice as long as a normal build (since it effectively compiles the code twice: once internally for analysis and once for output), but subsequent builds are incremental ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=,obfuscate%20modified%20code)). It also enables the companion command `garble reverse` to work: because the transformations are deterministic, `garble reverse` can take an obfuscated stack trace and, given the original source or the debug mapping, reverse the hashed names back to originals for debugging.

To summarize, Garble piggybacks on the Go toolchain in a two-phase process: (1) it runs the standard build to gather info and plan obfuscations, and (2) it runs the actual compile/link steps with those obfuscations injected via the `-toolexec` hook. This design means Garble naturally supports Go modules, build tags, and caching, and it stays compatible with new Go versions (it effectively “speaks Go’s build protocol”). The result is a seamless experience – you use `garble build` just like `go build`, and behind the scenes it produces a binary with scrubbed names, paths, and literals. The clever use of AST transformations and toolchain hooks is what allows Garble to implement these advanced obfuscation features without forking the Go compiler itself. ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=,obfuscate%20panic%20stack%20traces)) ([GitHub - burrowers/garble: Obfuscate Go builds](https://github.com/burrowers/garble#:~:text=Garble%20obfuscates%20one%20package%20at,obfuscate%20modified%20code))

