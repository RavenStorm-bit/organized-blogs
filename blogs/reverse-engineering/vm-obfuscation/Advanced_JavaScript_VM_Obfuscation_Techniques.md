Perfect. I will dive into advanced JavaScript VM-based obfuscation techniques—focusing on how these custom virtual machines are constructed, how bytecode is interpreted, and how analysts reverse-engineer and devirtualize them. I'll include step-by-step technical examples of reversing such obfuscators, prioritize any academic papers or blog posts from advanced reverse engineers, and gather the most cutting-edge information available.

I'll let you know once I’ve assembled a detailed breakdown and findings.

# Advanced JavaScript Virtualization-based Obfuscation Techniques

JavaScript virtualization-based obfuscation is an advanced code protection technique that embeds a **custom virtual machine (VM)** in the JavaScript code to execute the real program logic in an encoded form. Unlike simpler obfuscation (e.g. renaming identifiers or basic control-flow tricks), virtualization transforms the original code into a **pseudo-machine code (bytecode)** and provides a software interpreter to execute it ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=Virtualization%20obfuscation%20is%20a%20state,thereby%20executing%20the%20actual%20code)). This added layer makes reverse engineering significantly harder, as attackers must first decipher the VM and its instruction set before they can understand the underlying program ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=Since%20the%20bytecode%20is%20executed,to%20analyze%20the%20actual%20bytecode)). In recent years (circa 2018–2024), such JS VMs have been observed in the wild protecting web applications (e.g. anti-bot scripts, cryptors) and have been the subject of intense reverse-engineering efforts by security researchers.

## Comparing Traditional Obfuscation vs. Virtualization

To appreciate the complexity of virtualization-based obfuscation, it helps to contrast it with more common JavaScript obfuscation techniques:

| Obfuscation Technique           | Characteristics                                                  | Reverse Engineering Difficulty           |
|---------------------------------|------------------------------------------------------------------|------------------------------------------|
| **Control-Flow Flattening**     | Hides program flow by routing through a dispatcher loop. The code is restructured into a flat state machine with a central switch/if controlling which original block executes next. However, each case in the dispatcher still corresponds *one-to-one* with an original code block ([Writing Disassemblers for VM-based Obfuscators](https://synthesis.to/2021/10/21/vm_based_obfuscation.html#:~:text=directs%20the%20control%20flow%20to,virtual%20addition%20or%20push%2Fpop%20instructions)). In essence, the logic isn’t transformed, only the flow is obscured. | **Medium:** A determined analyst can often recognize the dispatcher pattern and map the cases back to the original logic. Automated deobfuscation is feasible since the semantics of each block are intact. |
| **VM-Based Obfuscation**        | Translates the entire code into a **custom bytecode** and runs it on an **embedded virtual machine** (interpreter). The original code never executes directly; it exists only as bytecode instructions handled by the VM ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=Virtualization%20obfuscation%20is%20a%20state,thereby%20executing%20the%20actual%20code)). There is no 1:1 correspondence between bytecode instructions and original source constructs – the logic is **virtualized** into a new form. Often combined with other techniques (e.g. junk code insertion, opaque predicates) to further hide the VM internals. | **Very High:** The reverse-engineer must reconstruct the VM’s architecture and **instruction set** to interpret the bytecode ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=Since%20the%20bytecode%20is%20executed,to%20analyze%20the%20actual%20bytecode)). This means analyzing a custom “processor” implemented in JS. Generic deobfuscation tools struggle because each VM is unique. |

*Table 1: Traditional vs. virtualization-based obfuscation in JavaScript.*

In summary, virtualization obfuscation is considered a *state-of-the-art* approach – it creates a unique execution environment for the code, raising the bar for reverse engineering. Next, we dive into how these custom JS VMs are designed under the hood.

## How JavaScript Virtualization Obfuscators Work

**Virtualization-based obfuscation** works by compiling or transpiling the original JavaScript into a **bytecode**, and bundling a **virtual machine interpreter** that can execute this bytecode. When the protected script runs, it initializes the VM and feeds the bytecode to it, so that the VM *interprets the bytecode instruction-by-instruction* to carry out the original logic ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=Virtualization%20obfuscation%20is%20a%20state,thereby%20executing%20the%20actual%20code)). Crucially, at no point is the original code de-obfuscated in memory; execution happens via the VM, meaning an analyst can’t simply dump a deobfuscated script – they would have to *emulate or reverse-engineer the VM itself* ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=Since%20the%20bytecode%20is%20executed,to%20analyze%20the%20actual%20bytecode)).

### Bytecode and Instruction Set Design

The **bytecode** is typically a sequence of bytes (or sometimes larger words) that represent a program in the VM’s *custom instruction set*. Each instruction consists of an **opcode** (operation code) often 1 byte in size, followed by zero or more **operands** encoded immediately after it ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=,strings%2C%20numbers%2C%20arrays%20or%20registers)). Operands might be immediate values (e.g. a number or an index) or references to VM-internal structures like registers. The VM’s designer can invent any instruction set architecture (ISA) they wish – the more “exotic” or unique, the harder it will be to analyze.

- **Example:** A simple VM might define opcodes for basic operations. For instance, an opcode `0x65` (101 in decimal) might mean “ADD”, expecting three operands: a destination register and two source registers. In the bytecode, this could appear as bytes: `[0x65, 0x02, 0x00, 0x01]` meaning `R2 = R0 + R1`. The VM interpreter would decode `0x65` to the ADD handler, then read the next three bytes as operand indices 2, 0, 1 and perform the addition ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=%2F%2F%20const%20OP%20%3D%20,getReg%28src1%29%29%3B)). This design is analogous to assembly language, but with a **custom** register set and operations.

The bytecode format can vary. Some VMs are **register-based** (like a CPU with a fixed number of virtual registers), others are **stack-based** (relying on pushing/popping values on an operand stack). For example, a register-based bytecode might explicitly specify destination and source registers for an ADD, whereas a stack-based bytecode might have opcodes that implicitly operate on the top of a stack (pop two values, add, push result). Each approach has implications for performance and complexity:

- *Register-based VM:* Maintains an array (or object) of virtual registers. Instructions explicitly refer to registers by index. This can make the bytecode a bit larger (since register indices are operands) but more closely resembles a real CPU ISA ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=,strings%2C%20numbers%2C%20arrays%20or%20registers)). It also means the VM needs to allocate and manage this register file during execution ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=The%20VM%20in%20Rusty,is%20called)).
- *Stack-based VM:* Maintains a value stack. Instructions implicitly use the stack top. For instance, an opcode for ADD would pop the top two values and push their sum, with no operand indices needed. This leads to compact bytecode but the semantics of each opcode depend on stack state. Many real-world JS VMs (TikTok’s, described later) use a stack model where `_0x4f176d` array was the operand stack and `_0x53c743` was its pointer (stack index) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=The%20usage%20of%20,The%20instructions%20do%20things%20like)).

In addition to computational opcodes (math, logic, etc.), the ISA typically includes opcodes for **loading constants**. For example, opcodes may load an immediate number or a constant string into a register/stack. In one real case, the VM had opcodes 3 and 4 dedicated to pushing 8-bit or 16-bit immediate integers onto its stack (sign-extended to handle negative numbers) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=%7D%20else%20,16%29%20%3E%3E%2016)). There may also be opcodes for special constants like pushing `true`, `false`, or `null`. Indeed, researchers found one VM where the lowest opcode values corresponded to pushing `true/false/null` onto the stack ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=do%20things%20like%3A)). By designing a limited set of atomic instructions, the VM can combine them to express any high-level logic.

**Bytecode encoding:** To hide the bytecode from casual observation, it’s often stored in an obfuscated form (e.g. as a long string or array that gets decoded at runtime). Some obfuscators base64-encode the bytecode or encrypt it. For instance, one custom VM used by TikTok shipped the bytecode as a long hex string literal, which a decoder function converted into an array of instruction bytes ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=Each%20function%20call%20that%20looks,Veritas%E2%80%99%20post%20at%20the%20beginning)). Another (Kasada’s VM for Nike) packed the bytecode in a strange numeric base: they had a custom decoder using a hardcoded alphabet (a mix of letters and digits) to convert an input string into an array of bytes ([Devirtualizing Nike.com's Bot Protection (Part 1) | nullpt.rs](https://www.nullpt.rs/devirtualizing-nike-vm-1#:~:text=We%20now%20find%20the%20function,is%20in%20a%20different%20scope)). These decoding steps run before the interpreter starts, producing the raw bytecode array that the VM will walk through.

### The VM Interpreter: Dispatch Loop and Handlers

At the heart of the virtualization is the **VM interpreter**, which fetches each opcode from the bytecode and executes the corresponding handler (the code that implements that virtual instruction’s behavior). This is often called a **fetch-decode-execute loop**. In JavaScript, this can be implemented in various ways, but two common patterns are:

- **Lookup Table of Handlers:** The VM defines an object or array `ops` where each opcode value indexes to a handler function. The interpreter loop then does something like: `let opcode = bytecode[pc++]; ops[opcode](vmContext);` repeatedly ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=run%28%29%20%7B%20while%28this.regs%5BREGS.BYTECODE_PTR%5D%20,)). Each handler function knows how to read any additional operand bytes (via helper methods like `vm.getByte()` to advance the bytecode pointer) and perform the operation. This design is straightforward: it resembles a large switch-case but uses function indirection. For example, in a tutorial VM, `ops[101]` was a function implementing the ADD operation shown earlier ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=%2F%2F%20const%20OP%20%3D%20,getReg%28src1%29%29%3B)).

- **Nested if/switch Dispatcher:** Instead of an explicit handler table, some obfuscators embed the dispatch logic as a massive nested if-else or switch statement on the opcode variable ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=for%20%28var%20_0x28b3ac%20%3D%20,4%29)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=%7D%20else%20,%2F%2F%20omitted)). This can be a side-effect of heavy minification or an attempt to prevent easy handler extraction. In TikTok’s VM, for instance, the interpreter was one giant `for(;;)` loop containing a cascade of `if` checks to determine which range the opcode falls into, and then executing the appropriate code block ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=if%20%28_0xd2004%20,else)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=_0xb14b3d%20%3D%20%28_0x146ed2%5B_0x3178c9%5D%20,)). Each block handled a group of opcodes. This nested style makes the control flow graph less obvious (and complicates automated analysis) but functionally it’s the same idea: read an opcode and jump to the code for that opcode.

Regardless of implementation, the interpreter acts as a **dispatcher**: it reads the next opcode, transfers control to the handler for that opcode, then loops back. Visually, if you examine the VM’s own code structure, you’d see a looping construct that repeatedly branches into handler code and back – somewhat similar to a flattened state machine. Researchers note that this looks superficially like control-flow flattening, but with a crucial difference: instead of dispatching original code blocks, it’s dispatching *virtual instructions* that often have no direct 1:1 mapping to the original source ([Writing Disassemblers for VM-based Obfuscators](https://synthesis.to/2021/10/21/vm_based_obfuscation.html#:~:text=We%20see%20a%20control,virtual%20addition%20or%20push%2Fpop%20instructions)). Each handler might be doing a very low-level task (e.g. “add two numbers,” “push constant,” “call function”) which only collectively form the original logic when a sequence of them runs.

**Handler functions** (or code blocks) implement the semantics of each opcode. These are essentially the **micro-code** of the protected program. Handlers can do arbitrary JavaScript operations: arithmetic, memory lookups, method calls, etc., but through the lens of the VM’s state. For example, a handler for a binary operation might pop two values from the VM’s stack and push the result. A handler for a property access might take an object reference and a property name (both perhaps loaded earlier into specific registers) and perform the equivalent of `obj[prop]` in real JS. Handlers often rely on helper methods in the VM context, like `vm.getReg(index)` and `vm.setReg(index, value)` for register access, or `vm._loadLongNum()` to read multi-byte literals from the bytecode stream ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=On%20the%20JS%20side%20a,register%20which%20enables%20easy%20access)).

**Example (Handler):** Below is a simplified pseudocode of a virtual ADD instruction from a register-based VM:

```javascript
// Opcode 0x65: ADD reg[src1] + reg[src2] -> reg[dst]
this.ops[0x65] = function(vm) {
    const dst = vm.getByte();      // operand: destination register index
    const src1 = vm.getByte();     // operand: source1 register index
    const src2 = vm.getByte();     // operand: source2 register index
    vm.setReg(dst, vm.getReg(src1) + vm.getReg(src2));
};
```

*Cited in text:* This corresponds to how an ADD handler was defined in a real project’s VM: the handler reads three operand bytes (dst, src0, src1) and then performs the addition and stores the result ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=%2F%2F%20const%20OP%20%3D%20,getReg%28src1%29%29%3B)). The interpreter would call this function whenever it encounters opcode 0x65 in the bytecode.

Handlers for other operations might be more involved – e.g. a handler for a function call could trigger a new nested VM execution (see below), and a handler for a conditional jump would adjust the bytecode pointer to skip or loop as needed ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=On%20the%20JS%20side%20a,register%20which%20enables%20easy%20access)).

### VM State and Memory Emulation

A JS VM needs to maintain its own **execution state** to model computation independently of the JavaScript runtime. Key components of VM state include:

- **Virtual Registers / Stack:** As mentioned, a register-based VM will allocate a set of registers. For example, Johannes Willbold’s demo VM uses an array `vm.regs[]` to represent registers (some entries hold general values, others may hold special values like the program counter) ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=The%20VM%20in%20Rusty,is%20called)). A stack-based VM will use an array as a stack. In TikTok’s obfuscation, they observed an array `_0x4f176d` being used with an index `_0x53c743` as a push-down stack for operands and temporary values ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=The%20usage%20of%20,The%20instructions%20do%20things%20like)). The handlers manipulate this stack (push, pop, etc.) as they compute.

- **Program Counter (Instruction Pointer):** The VM keeps track of the current position in bytecode. Commonly, this is an integer index (like `pc` or in TikTok’s case `_0x3178c9`) that points into the bytecode array ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=as%20an%20instruction%20that%20controls,is%20our%20instruction%20pointer)). With each fetched opcode and operands, this pointer advances. Jump instructions will set this pointer to a new value (for example, a JUMP handler might read a 32-bit offset from the bytecode and assign it to the PC register to redirect execution ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=On%20the%20JS%20side%20a,register%20which%20enables%20easy%20access))). In some implementations, the PC is stored in a dedicated register slot (e.g. register 0 or a special field) for convenience ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=The%20VM%20in%20Rusty,is%20called)).

- **Constant Pools:** Often the bytecode will not contain raw string literals or large constants in-line, as those would be bulky. Instead, obfuscators may separate a **constant pool** (an array of strings or numbers) that the bytecode can reference by index. In the TikTok VM, the string decoder function actually extracted two things from the encoded blob: a set of strings and the list of instruction bytes ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=order,and%20a%20list%20of%20instructions)). One of the identified virtual opcodes (`deref.get`) was used to fetch a string from that list by index ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=do%20things%20like%3A)). This is analogous to how Java or .NET bytecode works – constants are stored once and referred to by ID.

- **Virtual Call Stack / Scope:** To support **function calls** and local scopes within the virtualized code, the VM must emulate call/return behavior. A simple strategy (as described by Willbold) is to have the CALL opcode **save the current state** (all registers, or at least the PC and any callee-saved registers) onto a stack, then jump to the function’s bytecode offset ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=One%20approach%20to%20implement%20functions,to%20worry%20about%20them%20separately)) ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=var%20returnData%20%3D%20vm,1)). Upon encountering a RETURN opcode, the VM restores the saved register state (except maybe some designated return value register) and resumes execution after the call ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=let%20returnToReg%20%3D%20returnData)) ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=vm,with%20exceptions%29)). In other words, the VM maintains its own call stack of frames, similar to how a real CPU manages call/return. More sophisticated designs might incorporate separate **virtual stack frames** for each call, handling local variable scope by isolating registers per frame, etc. In practice, many obfuscators simplify by using a single set of registers and saving/restoring around calls, or even by avoiding deep function virtualization and only virtualizing the top-level algorithm.

- **Integration with Real JS Environment:** Since the VM operates in an isolated manner, it needs a controlled way to interact with real JavaScript APIs or objects (for example, to call `window.fetch` or access `document.cookie`). Obfuscators handle this by providing **“bridge” opcodes or objects**. A common pattern is passing a mapping of indices to actual values at VM initialization. For instance, TikTok’s VM was invoked with an object that had getters for numeric properties `0x0`, `0x1`, `0x2`, etc., each returning a real browser API (like `window`, `URL`, `XMLHttpRequest`, `setTimeout`, `document`, etc.) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=,return%20XMLHttpRequest)). The VM had opcodes that could access this object: e.g. an opcode to “get property X from the environment object” – effectively retrieving a real DOM or JavaScript API reference. In TikTok’s case, property `0` of that object yielded the `window` object ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=,return%20XMLHttpRequest)). Some entries were even linked to other virtual machines’ outputs (e.g. one property returned a variable `_0x4f2925` which was set by a different VM) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=0x7%3A%20Object%2C%20get%200x8%28%29%20,return%20_0x553701)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=It%E2%80%99s%20used%20to%20allow%20the,anything%20that%20JS%20can%20do)). Using such an environment mapping, the VM can invoke browser functionality or share state between multiple VM instances while keeping those interactions abstracted behind virtual instructions (like a `deref.get` to load from the environment, or a `deref.set` to write to it). This design essentially **emulates memory and global variables** for the VM in a controlled way. It also makes analysis trickier – rather than seeing a direct call to `window.alert`, you might see something like `deref.get 0x0; deref.get 0x5; call` which means “get window, get some function, call it,” etc., requiring the analyst to resolve what index corresponds to what object.

- **Flags and Conditionals:** Some VMs may emulate CPU flags or use special registers for condition codes. For example, an opcode for “equals” might set an internal flag register to 1 or 0, and a subsequent conditional jump opcode will check that flag. Others might simplify by directly pushing boolean results onto the stack and having conditional jump instructions consume a value (pop a boolean and decide to jump or not). The design varies, but the goal is to represent high-level `if/else` and looping constructs in terms of low-level VM operations (compare, branch).

- **Anti-Debugging and Integrity Checks:** High-end obfuscators often integrate anti-debug or anti-tamper checks into the virtualized code. The VM might include special opcodes that, for example, perform timing checks or environment verifications. If analysis or debugging is detected, these can divert execution or corrupt the VM state. For instance, one description notes that JS virtualization can *“modify the behavior of certain code paths or introduce artificial delays to slow down the analysis process”* ([Analysis of JS Virtualization - JS Virtualization](https://blog.jsvmp.com/js-virtualization/#:~:text=scrambling%2C%20control%20flow%20flattening%2C%20and,)). Another trick is to have the VM’s main loop wrapped in a `try/catch` – legitimate VM exits or certain conditions might throw exceptions that are caught to break out of the interpreter loop (making it harder to simply run the code stepwise in a debugger) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=,excluded%20for%20brevity)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=%7D%20catch%20%28_0x9843fc%29%20,excluded%20for%20brevity)). Obfuscators also often obfuscate the **interpreter code itself** (using traditional techniques on it) to make static analysis of handlers difficult. For example, an open-source virtualizer notes that if you leave the VM class unobfuscated (with clear opcode names, etc.), it becomes *“trivial to reverse engineer”* – so they recommend applying an additional layer of obfuscation to the VM implementation ([GitHub - aesthetic0001/js-virtualizer: Virtualization-based obfuscation for javascript](https://github.com/aesthetic0001/js-virtualizer#:~:text=Warning)).

- **Performance Considerations:** Running code in a VM is inherently slower than native JavaScript execution (since each bytecode instruction may correspond to many JS operations). Obfuscators must balance security and speed. Some opt to virtualize only critical segments (e.g. an anti-debug routine or a licensing check) rather than the entire codebase. Others try to mitigate overhead by using faster technology; notably, using **WebAssembly** for the interpreter. A recent approach is to compile the VM (or parts of it) from C/C++ to WebAssembly and embed that in the page ([Analysis of JS Virtualization - JS Virtualization](https://blog.jsvmp.com/js-virtualization/#:~:text=bypass%20protection,loading%20into%20the%20target%20application)). WebAssembly runs at near-native speed in browsers and is harder to inspect than raw JS. The JSVMP protector, for example, mentions implementing the interpreter core in C++ and then using Emscripten to produce a WASM module, specifically to *“ensure security”* and performance ([Analysis of JS Virtualization - JS Virtualization](https://blog.jsvmp.com/js-virtualization/#:~:text=bypass%20protection,loading%20into%20the%20target%20application)). This means the bytecode handling happens in a low-level binary module, not easily debuggable via browser devtools. Such hybrid JS/WASM virtualization is cutting-edge and significantly complicates reverse engineering (one must disassemble WebAssembly or instrument at the boundaries where control passes back to JavaScript).

### Summary of a VM’s Components

To summarize, a typical JavaScript VM-based obfuscator includes:

- **VM Initialization:** sets up the virtual context (e.g. allocate registers/stack, decode the bytecode, load environment objects) ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=The%20VM%20in%20Rusty,is%20called)) ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=%2F%2F%20this.ops%5B...%5D%20%3D%20function%28vm%29%20,BYTECODE_PTR%2C%200)).
- **Dispatcher Loop:** a continuous loop that fetches opcodes and dispatches to handler code until a termination condition (end of bytecode or an explicit VM-exit instruction) ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=run%28%29%20%7B%20while%28this.regs%5BREGS.BYTECODE_PTR%5D%20,)).
- **Instruction Handlers:** implementations of each custom opcode’s behavior (arithmetic, data movement, function calls, property access, etc.) ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=%2F%2F%20const%20OP%20%3D%20,getReg%28src1%29%29%3B)).
- **VM Context/State:** structures holding the execution state (virtual registers, stack, program counter, etc.) and any auxiliary data (constant pool, environment mappings).
- **VM Exit:** a mechanism to return from the virtualized code back to normal JavaScript (for example, an opcode that restores any modified real state and breaks the interpreter loop, or simply running the loop until bytecode end) ([Writing Disassemblers for VM-based Obfuscators](https://synthesis.to/2021/10/21/vm_based_obfuscation.html#:~:text=On%20a%20high,flow%20graph%20as%20follows)).

Because the VM is distributed along with the program, *each instance of virtualization can be completely custom*. One obfuscator might have, say, 50 opcodes with a mix of stack/register behavior, while another might have 100 opcodes and a very different strategy. This variability is exactly why automated deobfuscation is difficult – generic tools don’t know the “language” the bytecode is written in.

## Case Studies: VM-Based Obfuscation in the Wild (2019–2023)

Virtualization obfuscation is not just theoretical. In the last few years, multiple high-profile web applications and libraries have employed custom VMs for protection. Below are a few notable examples and their characteristics:

| Use-Case and Context                | Virtual Machine Characteristics                                                                                                                                     | Reverse Engineering Insights                                                                    |
|-------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------|
| **TikTok Web Client (2022)** <br>*(Anti-scraping & Telemetry)* | Deployed multiple *JS virtual machines* embedded in their web app (`webmssdk.js`). Each VM call is invoked by a stub like `func(encodedBytecode, envObj, undefined)`, where the first argument is a long hex string of bytecode ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=Each%20function%20call%20that%20looks,Veritas%E2%80%99%20post%20at%20the%20beginning)) and the second is an environment object mapping numeric keys to real browser objects (e.g. `0x0 → window`, `0x1 → URL`, `0x2 → XMLHttpRequest`, etc.) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=,return%20XMLHttpRequest)). The VM uses a **stack-based architecture**: it maintains an array as a value stack (`_0x4f176d`) with a stack pointer (`_0x53c743`) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=The%20usage%20of%20,The%20instructions%20do%20things%20like)). The interpreter loop is implemented as a giant `for(;;)` with nested `if`/`else` dispatching on the opcode value ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=if%20%28_0xd2004%20,else)). Dozens of opcodes were identified, including ones to push constants (booleans, null, 8/16-bit immediates) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=%7D%20else%20,16%29%20%3E%3E%2016)), to load strings from a decoded constants table, to get/set properties via the env object (think `deref.get`/`deref.set` for global vars) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=do%20things%20like%3A)), and to call functions. The VMs encapsulate many of TikTok’s telemetry and anti-bot routines (like fingerprinting canvas, building query params, etc.), so that the logic is hidden from anyone viewing the raw JS. | A collaboration of researchers published a two-part analysis of TikTok’s VM obfuscation. In Part 1, *“Veritas”* described how the bytecode is decrypted and noted that many site features are handled by these hidden VM modules ([Reverse Engineering Tiktok's VM Obfuscation (Part 1) | nullpt.rs](https://www.nullpt.rs/reverse-engineering-tiktok-vm-1#:~:text=executed%20by%20TikTok%27s%20custom%20virtual,fingerprinting%20in%20their%20own%20ways)). In Part 2, Ibiyemi Abiodun went further, extracting all VM functions, flattening the nested dispatch conditionals via a custom Babel script, and systematically deducing each opcode’s function ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=The%20first%20one%20was%20a,highly%20nested%20to%20reduce%20the)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=if%20%28instruction%20,stack%5B%2B%2BstackPtr%5D%20%3D%20true)). For example, they mapped out that opcodes `<2` push `true/false` and opcodes `3`/`4` push small signed immediates ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=%7D%20else%20,16%29%20%3E%3E%2016)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=do%20things%20like%3A)). They then wrote a **disassembler** that prints the bytecode in a readable assembly-like format (e.g. showing `deref.get 0x01, 0x01` instead of raw bytes) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=The%20last%20three%20variables%20declared,the%20instructions%20I%E2%80%99ve%20identified%20here)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=off%20%20hex%20dec%20instr,3)). This allowed them to start reconstructing higher-level logic of the virtualized code. The effort highlights the complexity: TikTok’s VM had ~80+ opcodes, and understanding it took significant manual and scripted analysis over months. |
| **Nike/Kasada Bot Protection (2023)** <br>*(Browser Fingerprinting)* | Nike’s login page included a script by Kasada (a bot mitigation provider) that was fully virtualized ([Devirtualizing Nike.com's Bot Protection (Part 1) | nullpt.rs](https://www.nullpt.rs/devirtualizing-nike-vm-1#:~:text=required%20to%20protect%20code,to%20protect%20Nike%27s%20web%20assets)). The protected code (responsible for generating a fingerprint and solving challenges) is stored as a byte sequence that is derived from a long string each time. The initialization function `eEA(t, a, n)` decodes the string via a custom routine (`A.default.u(n)`) that uses a hardcoded base-62 alphabet and some math to produce an array of bytecode ([Devirtualizing Nike.com's Bot Protection (Part 1) | nullpt.rs](https://www.nullpt.rs/devirtualizing-nike-vm-1#:~:text=We%20now%20find%20the%20function,is%20in%20a%20different%20scope)) ([Devirtualizing Nike.com's Bot Protection (Part 1) | nullpt.rs](https://www.nullpt.rs/devirtualizing-nike-vm-1#:~:text=t.P%20%3D%20%7B%20V%3A%20,W%3A%2050)). The VM architecture here appears **register-based**: it defines a set of virtual registers and uses numeric opcode values that correspond to operations involving those registers. The bytecode “program” is essentially an array of opcodes and operands (“opcode indices, register numbers, and other encoded information”) that a custom interpreter executes ([Devirtualizing Nike.com's Bot Protection (Part 1) | nullpt.rs](https://www.nullpt.rs/devirtualizing-nike-vm-1#:~:text=%E2%80%9Cprogram%E2%80%9D%20of%20sorts%2C%20running%20inside,machine%20is%20run%2C%20telling%20the)). As the VM runs, it updates an internal state (`t.g` array) where `t.g[0]` acted as the instruction pointer (incrementing as the VM executes) ([Devirtualizing Nike.com's Bot Protection (Part 1) | nullpt.rs](https://www.nullpt.rs/devirtualizing-nike-vm-1#:~:text=%E2%80%9Cprogram%E2%80%9D%20of%20sorts%2C%20running%20inside,machine%20is%20run%2C%20telling%20the)). The virtualization is thorough – even simple operations like XORing some bytes or reading browser properties are done via VM instructions. | A detailed reverse-engineering write-up by *“umasi”* on nullpt.rs (Part 1 of *“Devirtualizing Nike.com’s Bot Protection”*) walks through understanding this VM ([Devirtualizing Nike.com's Bot Protection (Part 1) | nullpt.rs](https://www.nullpt.rs/devirtualizing-nike-vm-1#:~:text=obfuscation%3A%20the%20implementation%20of%20custom,to%20protect%20Nike%27s%20web%20assets)). The author first mapped out the **script structure** to locate the entry point (`eEA`) and then used runtime breakpoints to find the decode function for the bytecode ([Devirtualizing Nike.com's Bot Protection (Part 1) | nullpt.rs](https://www.nullpt.rs/devirtualizing-nike-vm-1#:~:text=As%20the%20definition%20of%20,function%20definition%2C%20as%20demonstrated%20below)). After dumping the bytecode, they identified how strings were stored and accessed (a chunk of the bytecode array is carved out as a string table) ([Devirtualizing Nike.com's Bot Protection (Part 1) | nullpt.rs](https://www.nullpt.rs/devirtualizing-nike-vm-1#:~:text=Further%20down%20the%20body%20of,r)). By observing the VM’s memory (`t.g` structure) and how it changes, the author confirms the role of registers and the instruction pointer ([Devirtualizing Nike.com's Bot Protection (Part 1) | nullpt.rs](https://www.nullpt.rs/devirtualizing-nike-vm-1#:~:text=%E2%80%9Cprogram%E2%80%9D%20of%20sorts%2C%20running%20inside,machine%20is%20run%2C%20telling%20the)). Part 1 focuses on decoding the bytecode and understanding its format (including how certain bytes encode register reads/writes). The upcoming Part 2 (planned) is expected to tackle the actual opcode semantics ([Devirtualizing Nike.com's Bot Protection (Part 1) | nullpt.rs](https://www.nullpt.rs/devirtualizing-nike-vm-1#:~:text=the%20VM%27s%20opcodes%20and%20registers,for%20the%20VM%27s%20unique%20language)), potentially by building a *custom emulator or decompiler* for the VM. The key takeaway is the methodical approach: breakpoints to intercept the VM setup, static analysis of the decoding routine to get bytecode, then iterative analysis of each virtual instruction’s effect on the virtual registers. |
| **JSVMP Commercial Obfuscator (2023)** <br>*(General Code Protection)* | JSVMP is a third-party JS protection service that explicitly offers **virtualization-based obfuscation** (advertised as “one-click VMP encryption” for JavaScript). Its approach combines standard JS AST transformations with a **WebAssembly-based VM**. The JavaScript source is converted into a custom bytecode (via AST traversal and instruction splitting) ([Code Protection (JSJIAMI) Techniques and WebAssembly - JSVMP一键加密](https://blog.jsvmp.com/jsjiami/#:~:text=To%20address%20the%20shortcomings%20of,the%20target%20code%20during%20execution)), and a **WASM module** implements the VM interpreter to execute this bytecode ([Code Protection (JSJIAMI) Techniques and WebAssembly - JSVMP一键加密](https://blog.jsvmp.com/jsjiami/#:~:text=propose%20a%20JavaScript%20code%20virtualization,functionality%20and%20logical%20structure%20of)) ([Analysis of JS Virtualization - JS Virtualization](https://blog.jsvmp.com/js-virtualization/#:~:text=bypass%20protection,loading%20into%20the%20target%20application)). The virtual instruction set is designed not to leak or interact with the real JS environment directly; instead, a `VMContext` maps any needed JS functionality into the virtual world at startup ([Analysis of JS Virtualization - JS Virtualization](https://blog.jsvmp.com/js-virtualization/#:~:text=By%20using%20a%20virtual%20instruction,During%20execution)). Because the core execution runs in WASM, it’s significantly faster than a pure JS VM and also opaque to typical JS debuggers. | Being a commercial product, details are derived from vendor whitepapers rather than community reversing. JSVMP’s documentation describes a classic VM design (with components like `VMContext`, `VMInit`, `Dispatcher`, `Handler` functions) ([Analysis of JS Virtualization - JS Virtualization](https://blog.jsvmp.com/js-virtualization/#:~:text=JS%20virtualization%20protection%20involves%20using,Bytecode%20Interpreter)), but with the twist that *the “core logic is implemented in C/C++ and then compiled to WebAssembly”* for security ([Analysis of JS Virtualization - JS Virtualization](https://blog.jsvmp.com/js-virtualization/#:~:text=bypass%20protection,loading%20into%20the%20target%20application)). This means a reverse-engineer would have to analyze a WASM binary to understand the VM internals – a far more difficult task than reading JavaScript handlers. As of this writing, no public report of fully breaking JSVMP’s protection exists, which underscores the effectiveness of combining virtualization with native-level obfuscation. Researchers would likely need to use advanced techniques (WASM decompilation or hooking the browser’s WASM runtime) to approach devirtualizing such a target. |

*Table 2: Examples of JavaScript virtualization-based obfuscation in real scenarios (with their reverse engineering analyses).*

These case studies illustrate both the **ingenuity of obfuscation** and the **resourcefulness of analysts**. In each case, the virtual machine had a bespoke design: TikTok’s multiple VMs cooperatively hiding sensitive logic, Nike’s VM protecting an anti-bot algorithm, and a commercial tool pushing the envelope with WebAssembly. Next, we discuss how reverse engineers tackle such challenges in practice.

## Reverse Engineering and Devirtualization Techniques

Reversing a virtualized JavaScript is a daunting task. Essentially, the analyst must become an interpreter of the custom bytecode – effectively reversing what the obfuscator did by constructing a deobfuscator. This often involves a mix of **static analysis** (reading and reasoning about the code) and **dynamic analysis** (running the code in a controlled way to observe behavior). Here, we outline common strategies, tools, and methodologies used by experts to devirtualize JS obfuscators:

### 1. Recognizing the Presence of a VM

The first step is often identifying that virtualization is in use. Signs include large opaque data blobs (huge hex or base64 strings), unusual functions that take a big string and an object and return nothing obvious, or code that defines a big switch/if with many numeric cases. If you see code that sets up arrays or objects with lots of numeric keys or strange loops indexing into big arrays, that might be the VM at work. In the Nike example, once the analyst saw `for(var r = typeof n == "string" ? A.default.u(n) : n, i = r.length, ... )` (which decodes a string to array `r`) and later usage of `r[...]` as bytes ([Devirtualizing Nike.com's Bot Protection (Part 1) | nullpt.rs](https://www.nullpt.rs/devirtualizing-nike-vm-1#:~:text=for%20%28var%20r%20%3D%20,Math.random)) ([Devirtualizing Nike.com's Bot Protection (Part 1) | nullpt.rs](https://www.nullpt.rs/devirtualizing-nike-vm-1#:~:text=Further%20down%20the%20body%20of,r)), it became clear `r` is a bytecode array and the code is stepping through it. Similarly, TikTok’s `_0x4c03ae(hexString, {...}, undefined)` pattern ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=Each%20function%20call%20that%20looks,Veritas%E2%80%99%20post%20at%20the%20beginning)) was a giveaway – passing a giant hex literal to a function is not normal, hinting that it’s data for something (in this case, the VM).

### 2. Dumping or Extracting the Bytecode

Since the bytecode is typically stored in encoded form, a crucial step is to **retrieve a usable form of it**. Analysts use a few techniques:

- **Reimplement the Decoder:** If the obfuscation uses a routine to decode the bytecode (like a custom base or XOR decoding), one can extract that routine and run it separately to get the bytes. For Nike’s case, once the function `A.default.u(n)` was identified as the decoder, the author used breakpoints to find its definition and then understood it by reading the deobfuscated source ([Devirtualizing Nike.com's Bot Protection (Part 1) | nullpt.rs](https://www.nullpt.rs/devirtualizing-nike-vm-1#:~:text=As%20the%20definition%20of%20,function%20definition%2C%20as%20demonstrated%20below)) ([Devirtualizing Nike.com's Bot Protection (Part 1) | nullpt.rs](https://www.nullpt.rs/devirtualizing-nike-vm-1#:~:text=We%20now%20find%20the%20function,is%20in%20a%20different%20scope)). It turned out to be a base-62 decoder, which they could replicate to decode any bytecode string offline.

- **Instrument the Code:** Another approach is to let the code run its own decoder and intercept the result. For example, an analyst might insert a `console.log` or breakpoint right after the bytecode is decoded but before it’s executed. In a browser, one can prettify the code and set a breakpoint at the line where the VM starts executing (or in the first handler), then inspect the array that holds the bytecode. This requires understanding roughly where that happens – often by searching for patterns like large loops or usage of data that looks like bytecode. In a controlled environment (like Node.js), you can monkey-patch functions. For instance, if you identify a function that returns the decoded bytecode array, you could override it to capture the output.

TikTok’s analysts mentioned using Babel (a JavaScript parser/transformer) to automatically run the initial decryption of the VM code and format it with Prettier ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=I%20replicated%20Veritas%E2%80%99s%20work%20in,file%20that%20looked%20like%20this)). This gave them a readable JS file where they could spot the array of instructions and the structure of the interpreter. In summary, getting the bytecode is about neutralizing that first layer of encoding.

### 3. Analyzing the VM Interpreter Structure

With the bytecode in hand and the interpreter code accessible (albeit obfuscated), the next step is to map out the VM’s operation. A direct approach is **static code analysis** of the interpreter function:

- **Format and Simplify:** Tools like Prettier can re-indent and line-break the minified code. Then, using an AST (Abstract Syntax Tree) manipulation (with Babel or similar), one can try to simplify the control flow. In TikTok’s case, Ibiyemi wrote a Babel plugin to rewrite the nested if-else dispatch into a more human-friendly form ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=The%20solution%20was%20,This%20one%20does%20its%20best)). The idea was to use knowledge across the multiple VM instances: since each VM had similar structure but only a subset of opcodes active, comparing them helped infer the full range of opcodes. For example, if one copy had `if (instruction < 3)` and another had `if (instruction < 2)`, you deduce that opcode 2 was used in one but not the other ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=if%20one%20VM%20tests%20,in%20every%20VM%20and%20intersected)). By merging such conditions, they reconstructed a combined dispatcher logic that covered all opcodes. This yielded a clearer picture of each opcode’s case.

- **Labeling and Renaming:** It’s useful to rename the obfuscated variables into meaningful ones. Analysts will often rename the apparent stack (`_0x4f176d` became `stack`), the program counter (`_0x3178c9` to `pc`), and so on, to keep track. In code, replacing hex/number literal opcodes with mnemonic labels as you identify them is extremely helpful. For instance, once you figure out opcode 0x11 means “deref.get” (as in TikTok’s VM for reading from the env object), you can annotate the code or even modify it to reflect that ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=off%20%20hex%20dec%20instr,3)).

- **Control-Flow Graph and Handler Isolation:** Sometimes, especially with a switch-case style interpreter, one can break out each case (each handler’s code) into a separate function or at least separate the code in analysis. The goal is to treat each handler’s logic in isolation and figure out what it does. If the code is extremely tangled (e.g. one big try/catch with nested ifs), analysts might manually extract code segments corresponding to conditions. Using a debugger to step through one iteration of the loop can also help isolate which part of the code executes for a given opcode.

### 4. Understanding Each Opcode (Revealing the ISA)

This is the core of devirtualization: determining the meaning of every opcode. Techniques include:

- **Manual reasoning:** By reading the handler code. For example, you might see in the handler for opcode X that it does `stack[++sp] = true` and `stack[++sp] = (something === 0)` ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=if%20%28instruction%20,stack%5B%2B%2BstackPtr%5D%20%3D%20true)). From that, you infer opcode X pushes two values, one `true` and one conditional boolean. That could correspond to handling of a boolean literal or comparison result. In fact, TikTok’s analysts saw something similar and realized opcodes 0 and 1 likely pushed `true` and `false` ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=match%20at%20L180%20stack,3%29)) (or `true` and `null` as it appeared, which was adjusted to `true/false` logic in the cleaned version). As another example, seeing code that takes `bytecode[pc++]` and does bit shifts to combine bytes ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=_0xb14b3d%20%3D%20_0x146ed2,else)) clearly indicates it’s loading a multi-byte immediate value.

- **Executing the bytecode step-by-step:** If manual reading is tough, an effective method is to **simulate the VM**. One can write a small program to execute the bytecode with guessed semantics and see if the outcomes make sense. However, without knowing the opcodes, simulation is tricky. Instead, analysts often run the real obfuscated code in a debugger but patch it to trace actions:
  - You could insert logging in the interpreter loop: e.g., print out each opcode and maybe key variable values as it runs. This can be done by editing the minified code (which is tedious but feasible once formatted) or by using the developer console to redefine certain functions (if the VM uses a dispatch table, you can replace some handler with a wrapper that logs then calls original).
  - Another trick is to run the code until just before an interesting event and then inspect the VM’s stack/registers. For instance, run the VM until just before it makes a real API call (like a `fetch` or sets a known global), and check what values are on the stack — this can give clues about what operations led there.

- **Symbolic execution and automated reasoning:** For a more algorithmic approach, one can leverage program analysis tools. Tim Blazytko’s work (though on native binaries) demonstrates using **symbolic execution** to automatically follow the VM’s logic ([Writing Disassemblers for VM-based Obfuscators](https://synthesis.to/2021/10/21/vm_based_obfuscation.html#:~:text=match%20at%20L180%20symbolic%20execution%2C,fledged%20disassembler)). The idea is to treat the VM bytecode as unknown and symbolically execute the interpreter, which yields expressions for what each opcode does in terms of symbolic inputs. When the interpreter branches on the opcode value, the analysis can fork and explore each path (each handler) systematically. In the end, you get a map of opcode to action (like “opcode 0x65: reg[dst] = reg[src1] + reg[src2]”). While Tim’s blog targeted a C virtualizer (Tigress) and used tools like Miasm ([Writing Disassemblers for VM-based Obfuscators](https://synthesis.to/2021/10/21/vm_based_obfuscation.html#:~:text=blog%20post%2C%20we%20will%20use,reconstructed%20from%20the%20VM%20disassembly)), the concept can apply to JS: one could instrument a JS engine or use a custom JS evaluator to do similar symbolic tracing. This is advanced and not commonly done for browser JS yet, but it’s a promising research direction. In practice, most real-case reversals have been more manual, but augmented with scripts.

- **Cross-referencing multiple instances:** If the VM is used in multiple places (like TikTok had many VMs for different functions, all with the same ISA), comparing their bytecodes and behaviors can speed up understanding. If you see the same opcode used in different contexts, you can deduce it performs a common function. For instance, if opcode 0x20 always appears before a certain API call, it might be the call instruction. In TikTok’s case, having many VM samples allowed the researcher to notice patterns and confirm guesses by intersecting knowledge across them ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=The%20solution%20was%20,This%20one%20does%20its%20best)).

- **Leverage High-Level Clues:** Sometimes you know or suspect what the protected code is supposed to do (especially in malware or known algorithms). If you suspect the VM is performing, say, an encryption routine or a fingerprint, you can look for telltale sequences. For example, if it’s computing an MD5, you might expect a loop structure and certain constants to appear (though those constants could be hidden). In the absence of such clues, reversing every opcode is the surest path.

Ultimately, the goal is to produce a *mapping from opcode values to human-understandable operations*. In Ibiyemi’s work, they reached the point of listing each opcode with a name and description (and even open-sourced this list) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=The%20last%20three%20variables%20declared,the%20instructions%20I%E2%80%99ve%20identified%20here)). With that, one can translate the bytecode to a pseudo-code or even regenerate JavaScript that mimics the original logic.

### 5. Decompiling the Bytecode

After deciphering opcodes, the final step is **devirtualizing** – i.e., converting the bytecode back into a high-level form (JavaScript or pseudo-code). This is akin to writing a decompiler for the custom VM. One way is to literally simulate the bytecode using the now-known semantics and build an abstract syntax tree of what it’s doing:

- Some researchers build a **custom interpreter** in Python or JS that implements all discovered opcodes, then run the bytecode to observe what it does with representative inputs. If done carefully, you can log an execution trace or even reconstruct structured control flow. For example, by tracking jumps and call/return, you can identify loop boundaries and function boundaries in the bytecode, then wrap the instructions accordingly.

- In Nike’s analysis, the author mentioned it would be easiest to convert the bytecode to an intermediate representation (like assembly) and then attempt to fully decompile the program to JS ([Devirtualizing Nike.com's Bot Protection (Part 1) | nullpt.rs](https://www.nullpt.rs/devirtualizing-nike-vm-1#:~:text=match%20at%20L562%20analyzing%20the,to%20fully%20decompile%20the%20program)). This suggests a plan to systematically translate the VM code into something like a high-level description. That could involve writing a disassembler (turn bytecode -> textual assembly) and then using pattern-matching or a custom logic to recognize high-level constructs (if a sequence of instructions corresponds to an `if` statement, etc.).

- In the TikTok case, the reddit discussion mentions the possibility of building a *full decompiler* once the disassembler is done ([Reverse Engineering TikTok's VM Obfuscation (Part 2) : r/programming](https://www.reddit.com/r/programming/comments/10755l2/reverse_engineering_tiktoks_vm_obfuscation_part_2/#:~:text=TL%3BDR%20,I%27m%20wrong)). This would automatically output JavaScript code that performs the same logic as the bytecode. While this wasn’t publicly released, it’s a natural progression: once each virtual instruction has a known effect, one can replace each with equivalent JS code and thus recover the original algorithm (up to renaming).

- **Caution:** Virtualization obfuscation can sometimes embed junk or opaque operations that don’t affect end results, so a decompiler must ignore those or the analyst must manually prune them. Also, certain opcodes might simulate behaviors that don’t translate one-to-one to JavaScript (for instance, if the VM had its own bitwise math with overflow flags, etc., although in JS context that’s rare). Generally, though, these VMs implement feasible JS operations, so decompiled output is achievable.

### 6. Tools and Platforms for RE

Throughout these steps, the following tools and techniques have proven useful:

- **JavaScript AST Tools:** Babel (as used in TikTok’s case) or Esprima can parse minified JS and allow programmatic transformations. For example, you can locate all numeric literals in a switch and sort them, or replace obfuscated variable names with simpler ones, or inject logging statements. These help untangle the interpreter logic.

- **Browser DevTools Debugger:** The ability to set breakpoints, watch variables, and step through code in Chrome or Firefox DevTools is invaluable. You can even pretty-print the code in the debugger to make it easier to set breakpoints on specific lines. Using breakpoints to catch the execution right when the VM is about to do something (like output a result) can give insight into what’s on the VM’s stack or registers at that moment.

- **Memory Inspection:** In JS, “memory” is just objects/arrays. If you identify the array used as the bytecode or stack, you can inspect its contents at runtime. DevTools Console can be used to evaluate expressions on the fly (for instance, type in the console the name of the array variable to see its elements). This was how the Nike analysis confirmed what part of `r` array was being used as bytecode versus as a string pool ([Devirtualizing Nike.com's Bot Protection (Part 1) | nullpt.rs](https://www.nullpt.rs/devirtualizing-nike-vm-1#:~:text=Further%20down%20the%20body%20of,r)).

- **Scripting and Emulation:** Writing a quick Node.js script to emulate the VM can be useful. One could copy the handler code (if relatively clear) or implement the understood opcode behaviors, then run the actual bytecode through it. This is safer than running the obfuscated code fully, since you won’t trigger any anti-debug traps, and you can instrument the emulation as you like (log every opcode, etc.). It’s essentially writing your own deobfuscator program for that specific obfuscation. Many researchers publish these scripts or at least the results – for example, Ibiyemi published the disassembled TikTok bytecode output ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=Armed%20with%20an%20approximate%20description,like%20format)) which implies they had a script to produce that listing.

- **Symbolic Execution Engines:** While not yet common for JS, one could imagine using a tool like `escaya` (JavaScript parser) plus a custom symbolic evaluator, or even convert the JS interpreter into Python and use Angr or Manticore (symbolic execution frameworks) to explore it. Tim Blazytko’s approach with Miasm for native code shows the viability: by treating some parts of state symbolically (unknown), the system can automatically figure out the effect of each handler ([Writing Disassemblers for VM-based Obfuscators](https://synthesis.to/2021/10/21/vm_based_obfuscation.html#:~:text=match%20at%20L134%20In%20a,In%20the%20following%2C%20we%20will)) ([Writing Disassemblers for VM-based Obfuscators](https://synthesis.to/2021/10/21/vm_based_obfuscation.html#:~:text=match%20at%20L180%20symbolic%20execution%2C,fledged%20disassembler)). If someone were reversing a very complex VM, this approach could save time by automating the discovery of opcode semantics.

- **Community Knowledge and References:** Often, specific obfuscators become known and prior work can be a goldmine. For instance, knowledge of JScrambler or JSFuck or older obfuscators can sometimes apply (though those are not VM-based, they might be mixed in as layers). In our context, referencing the prior academic works on virtualization (like Rolles 2009 ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=bytecode)), Kinder 2012) can give hints on common techniques used, even though those focused on native code. Today, write-ups on forums, blog posts, and GitHub projects (some referenced throughout this report) are the main resources – and as we saw, reversing a JS VM often requires custom-tailored code and a full understanding of the target.

### 7. Challenges and Closing Thoughts

Even with these techniques, virtualized JS is **labor-intensive** to reverse. It’s not uncommon for analysts to spend weeks unraveling a single VM if it’s particularly convoluted. Furthermore, obfuscators can update the VM (change opcode meanings, reorder the instruction set, etc.) to thwart the specific reverse-engineering effort – leading to a cat-and-mouse game. As one commenter noted, if changing the VM is easier for the defender than reversing it is for the attacker, virtualization is “worth it” ([Reverse Engineering TikTok's VM Obfuscation (Part 2) : r/programming](https://www.reddit.com/r/programming/comments/10755l2/reverse_engineering_tiktoks_vm_obfuscation_part_2/#:~:text=TL%3BDR%20,I%27m%20wrong)) from a security standpoint.

One major drawback for the obfuscator is **performance** and resource usage. A heavy VM can slow down a web page significantly (TikTok’s web app was observed to consume a lot of CPU/battery, likely due to the overhead of these VMs ([Reverse Engineering TikTok's VM Obfuscation (Part 2) : r/programming](https://www.reddit.com/r/programming/comments/10755l2/reverse_engineering_tiktoks_vm_obfuscation_part_2/#:~:text=ioneska))). Developers must choose carefully which parts of code to virtualize. Often it’s used on initialization code, anti-debug logic, or certain critical algorithms, rather than everything, to strike a balance.

In conclusion, **JavaScript virtualization-based obfuscation** represents a powerful way to safeguard client-side code by raising it to a level of abstraction that’s foreign to any standard tool. Its use has grown in the past 3–5 years for protecting web content and hinder bot or malware analysis. Reverse-engineering such obfuscation requires deep understanding of both JavaScript and virtual machine concepts, and often bespoke tooling. Thanks to community efforts, we have seen that even the most complex JS VMs (like those of TikTok and Kasada) can eventually be deconstructed – but it is a challenging endeavor. As defenders incorporate techniques like WebAssembly and increasingly complex VMs, the reversing community will undoubtedly respond with new methods (perhaps more automation and symbolic analysis) to peel back these layers. The never-ending duel between obfuscation and deobfuscation continues, on an ever more abstract battleground of virtual machines within the JavaScript realm.

**Sources:** High-effort technical analyses and resources were used to compile this report, including Johannes Willbold’s guide on JS virtualization ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=Virtualization%20obfuscation%20is%20a%20state,thereby%20executing%20the%20actual%20code)) ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=Since%20the%20bytecode%20is%20executed,to%20analyze%20the%20actual%20bytecode)) ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=%2F%2F%20const%20OP%20%3D%20,getReg%28src1%29%29%3B)), the JSVMP technical blogs ([Analysis of JS Virtualization - JS Virtualization](https://blog.jsvmp.com/js-virtualization/#:~:text=JS%20virtualization%20protection%20involves%20using,Bytecode%20Interpreter)) ([Analysis of JS Virtualization - JS Virtualization](https://blog.jsvmp.com/js-virtualization/#:~:text=bypass%20protection,loading%20into%20the%20target%20application)), Tim Blazytko’s research on VM disassembly ([Writing Disassemblers for VM-based Obfuscators](https://synthesis.to/2021/10/21/vm_based_obfuscation.html#:~:text=We%20see%20a%20control,virtual%20addition%20or%20push%2Fpop%20instructions)) ([Writing Disassemblers for VM-based Obfuscators](https://synthesis.to/2021/10/21/vm_based_obfuscation.html#:~:text=match%20at%20L180%20symbolic%20execution%2C,fledged%20disassembler)), and in-depth reverse-engineering case studies of TikTok’s ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=do%20things%20like%3A)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=It%E2%80%99s%20used%20to%20allow%20the,anything%20that%20JS%20can%20do)) and Nike’s ([Devirtualizing Nike.com's Bot Protection (Part 1) | nullpt.rs](https://www.nullpt.rs/devirtualizing-nike-vm-1#:~:text=%E2%80%9Cprogram%E2%80%9D%20of%20sorts%2C%20running%20inside,machine%20is%20run%2C%20telling%20the)) ([Devirtualizing Nike.com's Bot Protection (Part 1) | nullpt.rs](https://www.nullpt.rs/devirtualizing-nike-vm-1#:~:text=We%20now%20find%20the%20function,is%20in%20a%20different%20scope)) virtualization obfuscation. These illustrate the inner workings of JS VMs and the methodologies to devirtualize them. Each citation corresponds to specific insights or examples as noted in the text above.