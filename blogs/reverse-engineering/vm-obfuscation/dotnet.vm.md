Got it. I’ll look into open-source VM-based obfuscators specifically for .NET, analyze their source code, and report on their techniques, architecture, and any interesting implementation details. I’ll also highlight whether the projects are actively maintained.

I’ll get back to you shortly with the findings.

# Open-Source .NET VM-Based Obfuscators

**Code virtualization** is an obfuscation technique that transforms a program’s logic into custom bytecode which runs on a **virtual machine** (VM) with a bespoke instruction set ([Uncovering .NET Malware Obfuscated by Encryption and Virtualization](https://unit42.paloaltonetworks.com/malware-obfuscation-techniques/#:~:text=,The)). This adds a significant layer of complexity for reverse engineers, as they must understand the custom VM internals to recover the original logic. Below, we explore several open-source projects that implement VM-based obfuscation for .NET, analyzing their purpose, techniques, code structure, and maintenance status.

## KoiVM (ConfuserEx Virtualization Plugin)

**Purpose and Scope:** KoiVM is a virtualizing protector originally developed as a plugin for the open-source ConfuserEx obfuscator. Its goal is to transform .NET methods into **virtualized bytecode** that only a custom embedded VM can execute ([GitHub - Loksie/KoiVM-Virtualization: Virtualization made for .NET using ConfuserEX](https://github.com/Loksie/KoiVM-Virtualization#:~:text=Is%20a%20virtual%20machine%20made,if%20not%20all%20the%20cases)). KoiVM can either virtualize an entire assembly or specific methods (via attributes) to protect critical code paths, though virtualizing everything incurs heavy performance costs ([GitHub - Loksie/KoiVM-Virtualization: Virtualization made for .NET using ConfuserEX](https://github.com/Loksie/KoiVM-Virtualization#:~:text=Is%20a%20virtual%20machine%20made,if%20not%20all%20the%20cases)) ([GitHub - Loksie/KoiVM-Virtualization: Virtualization made for .NET using ConfuserEX](https://github.com/Loksie/KoiVM-Virtualization#:~:text=using%20the%20plugin%2C%20first%20one,if%20not%20all%20the%20cases)). It supports .NET Framework assemblies (up to ~4.x), with some limitations on certain IL opcodes and newer runtime features ([GitHub - Loksie/KoiVM-Virtualization: Virtualization made for .NET using ConfuserEX](https://github.com/Loksie/KoiVM-Virtualization#:~:text=,Only%20supported%20OS%20is%20Windows)).

**VM-Based Obfuscation Technique:** KoiVM works by mapping original CIL (Common Intermediate Language) instructions to a set of **custom VM opcodes**. It injects a **runtime interpreter** (the “KoiVM Runtime” library) into the protected assembly, which knows how to execute these opcodes. The protected methods are replaced with stubs that load an encoded bytecode stream (the translated opcodes) and then dispatch into the KoiVM interpreter. At runtime, the interpreter simulates the original logic by reading the VM opcodes and performing the equivalent operations. This **virtual CPU** model includes its own set of virtual registers and flags – in fact, the vanilla KoiVM defines about **119 internal constants** representing the VM’s registers, flags, and opcode identifiers ([DotRunpeX - demystifying new virtualized .NET injector used in the wild - Check Point Research](https://research.checkpoint.com/2023/dotrunpex-demystifying-new-virtualized-net-injector-used-in-the-wild/#:~:text=Unfortunately%20for%20us%2C%20we%20are,used%20to%20define%20registers%2C%20flags)). These constants and the VM handlers implement a wide range of virtual instructions so that most .NET bytecode constructs (arithmetic, calls, branches, etc.) can be handled. (Notably, a few complex opcodes like `Calli` and `Jmp` are not supported ([GitHub - Loksie/KoiVM-Virtualization: Virtualization made for .NET using ConfuserEX](https://github.com/Loksie/KoiVM-Virtualization#:~:text=,Only%20supported%20OS%20is%20Windows)).)

**Source Code and Handler Architecture:** In KoiVM’s source, each VM opcode has a corresponding **handler** routine in the VM runtime. The interpreter uses a loop (or switch-case) to fetch the next opcode from the bytecode sequence and invoke the appropriate handler. The VM is largely **register-based** (as indicated by the use of defined registers/flags constants ([DotRunpeX - demystifying new virtualized .NET injector used in the wild - Check Point Research](https://research.checkpoint.com/2023/dotrunpex-demystifying-new-virtualized-net-injector-used-in-the-wild/#:~:text=Unfortunately%20for%20us%2C%20we%20are,used%20to%20define%20registers%2C%20flags))) rather than purely stack-based, which means the handlers manipulate an array of virtual registers representing the original evaluation stack and local variables. KoiVM also integrates with ConfuserEx’s existing protections: for example, ConfuserEx’s anti-tamper may encrypt the virtualized bytecode or VM dispatcher, and its anti-debug hooks can be combined with KoiVM. The VM instruction set and handler logic are designed to be opaque – e.g., the numeric values of opcodes or the layout of the **`Constants`** table in the VM runtime can be randomized per protection instance to thwart pattern-matching deobfuscators ([DotRunpeX - demystifying new virtualized .NET injector used in the wild - Check Point Research](https://research.checkpoint.com/2023/dotrunpex-demystifying-new-virtualized-net-injector-used-in-the-wild/#:~:text=KoiVM%20de,class%20or%20changes%20in%20the)) ([DotRunpeX - demystifying new virtualized .NET injector used in the wild - Check Point Research](https://research.checkpoint.com/2023/dotrunpex-demystifying-new-virtualized-net-injector-used-in-the-wild/#:~:text=Unfortunately%20for%20us%2C%20we%20are,used%20to%20define%20registers%2C%20flags)). This, along with the need to reverse-engineer ~119 custom instructions, acts as an **anti-analysis feature** in itself.

**Code Structure and Design Patterns:** KoiVM’s project is structured as a plugin extension to ConfuserEx. It uses **dnlib** (via ConfuserEx) to rewrite assemblies: marking methods for virtualization, replacing their bodies with calls into the VM, and injecting the VM interpreter classes. The design cleanly separates the **VM specification** (constants defining opcodes/registers) and the **VM interpreter** (handler implementations) from the ConfuserEx processing logic. This separation follows a typical design pattern for virtualizers: one module generates the virtualized bytecode from the original method (mapping IL to VM ops), and another module (the VM runtime) interprets it. The handler architecture is essentially a **big switch** or dispatch table over opcodes, a straightforward design for bytecode interpreters.

**Maintenance and Updates:** KoiVM is an older project and is **no longer actively maintained** by its original author (“Ki”). It was released a few years ago and has known compatibility limitations with newer .NET Core/5+ runtimes ([GitHub - Loksie/KoiVM-Virtualization: Virtualization made for .NET using ConfuserEX](https://github.com/Loksie/KoiVM-Virtualization#:~:text=,Only%20supported%20OS%20is%20Windows)). Only Windows OS is supported for the protected assemblies ([GitHub - Loksie/KoiVM-Virtualization: Virtualization made for .NET using ConfuserEX](https://github.com/Loksie/KoiVM-Virtualization#:~:text=methods%20and%20not%20an%20actual,thats%20basically%20it%2C%20thats%20the)). Despite its age, KoiVM remains influential – its source is open (MIT licensed) and has been forked or modified in the community. For example, malware authors have adapted KoiVM (e.g. **dotRunpeX’s custom KoiVM variant ([DotRunpeX - demystifying new virtualized .NET injector used in the wild - Check Point Research](https://research.checkpoint.com/2023/dotrunpex-demystifying-new-virtualized-net-injector-used-in-the-wild/#:~:text=,More%20UAC%20Bypass%20techniques)) ([DotRunpeX - demystifying new virtualized .NET injector used in the wild - Check Point Research](https://research.checkpoint.com/2023/dotrunpex-demystifying-new-virtualized-net-injector-used-in-the-wild/#:~:text=Unfortunately%20for%20us%2C%20we%20are,used%20to%20define%20registers%2C%20flags))**), and there exist devirtualizers targeting the vanilla KoiVM. The last significant update to the public code was several years ago, and developers should be cautious with its memory leak issues and performance overhead if using it ([GitHub - Loksie/KoiVM-Virtualization: Virtualization made for .NET using ConfuserEX](https://github.com/Loksie/KoiVM-Virtualization#:~:text=Now%2C%20I%20will%20procceed%20to,find%20while%20using%20this%20protection)) ([GitHub - Loksie/KoiVM-Virtualization: Virtualization made for .NET using ConfuserEX](https://github.com/Loksie/KoiVM-Virtualization#:~:text=,of%20them%20to%20work%20as)).

## MemeVM

**Purpose and Scope:** MemeVM is a **proof-of-concept** mini virtualizer for .NET, created as a learning experiment. It takes a given .NET method’s MSIL and **“translates” it into instructions for a simple custom VM** ([GitHub - TobitoFatitoRE/MemeVM: A small virtualizer for .NET which works together with ConfuserEx](https://github.com/TobitoFatitoRE/MemeVM#:~:text=This%20projects%20takes%20your%20existing,our%20virtual%20machine%20will%20understand)). The goal was primarily educational – to demonstrate how a VM-based obfuscator might work – rather than to serve as a production-grade protector. MemeVM integrates with ConfuserEx (leveraging its plugin interface and dnlib for IL rewriting) but with a much smaller scope than KoiVM. It only implements a subset of .NET opcodes and was never meant for serious software protection ([GitHub - TobitoFatitoRE/MemeVM: A small virtualizer for .NET which works together with ConfuserEx](https://github.com/TobitoFatitoRE/MemeVM#:~:text=Note)).

**VM-Based Technique:** Like other virtualizers, MemeVM replaces the original code with a VM interpretation layer. It defines a very basic **bytecode** and an interpreter that executes it. However, MemeVM’s supported instruction set is minimal – many CIL opcodes are unimplemented or only partially handled (for example, it has **no support for pointer or typed reference instructions** and its branching logic is noted to be buggy) ([GitHub - TobitoFatitoRE/MemeVM: A small virtualizer for .NET which works together with ConfuserEx](https://github.com/TobitoFatitoRE/MemeVM#:~:text=,No%20support%20for%20pointers)). The virtualizer will convert straightforward MSIL sequences into its equivalent VM ops, but anything complex or unsupported is left as-is (or will likely break the protection). The result is a program that technically runs under a custom VM, but with significantly reduced completeness compared to full-fledged obfuscators.

**Source Code & VM Design:** In the source, MemeVM is split into a `MemeVM.Confuser` module (which hooks into ConfuserEx to transform methods) and a `MemeVM.Runtime` module (which contains the VM interpreter to embed). The VM design here is likely **stack-based** or a simple register stack model, given the limited instructions. Each handler in `MemeVM.Runtime` corresponds to a basic operation (perhaps arithmetic, load/store, call, etc.). The interpreter probably uses a loop with a switch over opcodes (similar to KoiVM but on a smaller scale). There are **no advanced anti-analysis tricks or diversifiers** in MemeVM – the implementation is straightforward. In fact, the author explicitly warns it “is not meant to be used as a serious layer of obfuscation” ([GitHub - TobitoFatitoRE/MemeVM: A small virtualizer for .NET which works together with ConfuserEx](https://github.com/TobitoFatitoRE/MemeVM#:~:text=Note)), implying no anti-debug or anti-tamper features were added. This simplicity makes it a good study example of a VM obfuscator’s skeleton without the complexity.

**Code Structure and Patterns:** MemeVM’s structure mirrors ConfuserEx plugin patterns: methods to virtualize are identified, their IL is read and translated into a sequence of MemeVM opcodes, and the original method body is replaced with a call into the MemeVM runtime. The **design pattern** is very clear and linear – e.g., it might create a byte array or list of opcodes for the method, store it (perhaps as a resource or an array in the binary), and insert a call like `MemeVM.Runtime.Interpreter.Execute(byte[] opcodes, object[] data)` in place of the original logic (this is speculative, but typical for such a tool). The code uses **dnlib** for IL manipulation (the repository even bundles `dnlib.dll` and `Confuser.Core.dll` for convenience ([GitHub - TobitoFatitoRE/MemeVM: A small virtualizer for .NET which works together with ConfuserEx](https://github.com/TobitoFatitoRE/MemeVM#:~:text=README))). There is a focus on clarity over sophistication; for instance, the author notes several limitations rather than implementing complex workarounds ([GitHub - TobitoFatitoRE/MemeVM: A small virtualizer for .NET which works together with ConfuserEx](https://github.com/TobitoFatitoRE/MemeVM#:~:text=,No%20support%20for%20pointers)), indicating an educational design pattern.

**Maintenance:** MemeVM is essentially **abandonware** – it had only a couple of commits (circa 2019) and never saw further development ([GitHub - TobitoFatitoRE/MemeVM: A small virtualizer for .NET which works together with ConfuserEx](https://github.com/TobitoFatitoRE/MemeVM#:~:text=Stars)). It has a small number of users (the GitHub repo has modest stars/forks) and is not actively maintained. Given its experimental nature and known bugs, it’s not used in production obfuscation. It remains available as an open-source reference for anyone interested in how VM obfuscation can be prototyped.

## StrongVM

**Purpose and Scope:** StrongVM is a .NET protector that emphasizes **method virtualization** as a core feature. It appears to be a community project (with possible commercial aspects, given a “Buy” link on its site) that provides several layers of protection: *“virtualize method, custom renaming, anti-debug, anti-memory-dump, string virtualization, resource encryption, and assembly merging,”* among others ([GitHub - Modify24x7/StrongVM: StrongVM is a virtualizing protector for .NET applications.](https://github.com/Modify24x7/StrongVM#:~:text=Features)) ([StrongVM](https://strongvm.blogspot.com/#:~:text=,v4.8%20%5BWindows)). The scope of StrongVM is broader than just virtualization – it aims to be an all-in-one protector – but its standout feature is converting methods to a virtual machine form (particularly to protect strings and critical routines). It supports .NET Framework 2.0 through 4.8 on Windows ([GitHub - Modify24x7/StrongVM: StrongVM is a virtualizing protector for .NET applications.](https://github.com/Modify24x7/StrongVM#:~:text=,v4.8)) ([StrongVM](https://strongvm.blogspot.com/#:~:text=,v4.8%20%5BWindows)).

**VM-Based Technique:** StrongVM’s virtualization likely operates similarly to KoiVM’s approach: targeted methods are replaced with a **VM interpreter stub**. The custom VM in StrongVM would have its own instruction set designed to emulate .NET operations. Given the feature list, StrongVM probably introduces VM opcodes not only for general logic but also for things like **string handling** (since it advertises “string virtualize” as a feature ([GitHub - Modify24x7/StrongVM: StrongVM is a virtualizing protector for .NET applications.](https://github.com/Modify24x7/StrongVM#:~:text=Features))). This could mean literal strings are stored in a virtualized form (for example, as data in the VM bytecode) and reconstructed at runtime by VM instructions, rather than appearing as plain text or even typical encrypted strings. The virtualization likely coexists with other protections: e.g., after virtualizing a method, the tool might also apply control-flow flattening or embed anti-debug checks into the VM code.

**Source Code and Handler Architecture:** The StrongVM project uses **dnlib** ([GitHub - Modify24x7/StrongVM: StrongVM is a virtualizing protector for .NET applications.](https://github.com/Modify24x7/StrongVM#:~:text=License)) for rewriting, suggesting its implementation is akin to ConfuserEx’s technique (which is common for .NET obfuscators). Although the full source code isn’t clearly published on GitHub (only binaries/releases), we can infer that StrongVM’s VM interpreter consists of a set of **handlers for each virtual opcode** and a dispatch loop. The handlers would perform operations corresponding to .NET instructions (arithmetic, field access, calls, etc.), all wrapped in a VM context that likely includes a *virtual program counter*, a *stack or register array* for operand storage, and possibly *virtual flags* or a *evaluation stack simulation*. StrongVM also touts anti-debug and anti-dump features ([GitHub - Modify24x7/StrongVM: StrongVM is a virtualizing protector for .NET applications.](https://github.com/Modify24x7/StrongVM#:~:text=,Resources%20encryption)). These may be implemented by injecting checks in the VM interpreter (for example, the VM could continuously check for the presence of a debugger and alter execution if detected) or by enabling .NET runtime features like `IsDebuggerPresent`/`Debugger.IsAttached` checks and anti-dump routines (e.g., zeroing out memory if an unauthorized dump is attempted). 

**Code Structure and Design Patterns:** Without the full source, one must rely on the described features: StrongVM likely has a modular structure, with components for each protection (renaming, virtualization, etc.). The **design pattern** for virtualization would involve: reading IL with dnlib, translating it to a custom bytecode, and injecting a **runtime interpreter class** into the assembly. That runtime might be merged into the assembly (StrongVM has a “merge .NET assembly” feature ([GitHub - Modify24x7/StrongVM: StrongVM is a virtualizing protector for .NET applications.](https://github.com/Modify24x7/StrongVM#:~:text=,v4.8)), presumably used to embed the interpreter and any support libraries). It probably uses a **register-based VM model** similar to KoiVM (which many .NET virtualizers copy), given that design’s flexibility in handling complex instructions. The mention of “custom rename method” suggests the renaming might be integrated with virtualization (perhaps renaming not just metadata but also decoy methods or the interpreter’s methods to confuse reverse engineers). In terms of patterns, StrongVM might employ **opaque predicates or diversified handlers** – e.g., each virtualization might slightly shuffle the VM opcode values or include dummy handlers – to make static pattern detection harder.

**Maintenance:** StrongVM had active development with multiple releases, with the latest known release around November 2022 ([GitHub - Modify24x7/StrongVM: StrongVM is a virtualizing protector for .NET applications.](https://github.com/Modify24x7/StrongVM#:~:text=Releases%2014)). This indicates it was maintained at least up to that date. However, the project appears to be primarily driven by a single developer (Modify24x7) and hasn’t garnered a large open-source community (the star/watch counts are low ([GitHub - Modify24x7/StrongVM: StrongVM is a virtualizing protector for .NET applications.](https://github.com/Modify24x7/StrongVM#:~:text=Stars))). The presence of a blog and even a buy option suggests that while the code is on GitHub, it might function partly as freeware and partly as a paid tool (perhaps paid for support or a more advanced edition). As of 2025, there’s no clear public activity beyond 2022. Users should check the GitHub releases page for updates, but it’s safe to say the project is **semi-maintained** with infrequent updates. The last updates focused on adding features like improved renaming and bug fixes (per the `WhatsNew.txt` in the repo). If using StrongVM, ensure it supports your target .NET version (it does not list .NET Core/5+, only .NET Framework up to 4.8 ([StrongVM](https://strongvm.blogspot.com/#:~:text=,v4.8%20%5BWindows))).

## VOT4CS (Virtualization Obfuscation Tool for C#)

**Purpose and Scope:** VOT4CS is an academic open-source project that implements virtualization obfuscation at the **C# source level** ([](https://mediatum.ub.tum.de/doc/1343178/911973262578.pdf#:~:text=VOT4CS%20uses%20the%20other%20option,features%20of%20the%20programming%20language)). Developed as a research prototype ([](https://mediatum.ub.tum.de/doc/1343178/911973262578.pdf#:~:text=have%20to%20employ%20technical%20means,off%20offered%20by%20the%20tool)), its purpose is to evaluate the security and performance trade-offs of virtualization-based protection on .NET programs. Instead of working on compiled IL, VOT4CS transforms C# source code before compilation (using the Roslyn compiler platform) to insert a virtual machine interpreter into selected functions. This tool allows fine-grained protection – the user can specify individual functions to virtualize, rather than the entire assembly ([](https://mediatum.ub.tum.de/doc/1343178/911973262578.pdf#:~:text=VOT4CS%20facilitates%20virtualization%20obfuscation%20at,obfuscate%20the%20entire%20program%2C%20which)). It was intended to help protect intellectual property by making decompilation much harder, and also to experiment with **randomized diversification** techniques to thwart deobfuscation based on pattern recognition ([](https://mediatum.ub.tum.de/doc/1343178/911973262578.pdf#:~:text=have%20to%20employ%20technical%20means,off%20offered%20by%20the%20tool)).

**VM-Based Technique:** The virtualization approach in VOT4CS involves two main phases ([](https://mediatum.ub.tum.de/doc/1343178/911973262578.pdf#:~:text=The%20work,source%20code.%20Roslyn)): a **refactoring phase** and a **virtualization transformation phase**. In refactoring, the source code of the target function is rewritten into a simpler normal form (e.g., splitting complex expressions and control structures into simple building blocks) to make it easier to virtualize. Then the virtualization phase replaces the function’s logic with a custom interpreter. Concretely, VOT4CS generates a set of data structures inside the function, typically: an array (or list) to hold all local variables and constants (treated uniformly as data operands), and an array of integers that encodes a sequence of opcodes representing the original operations ([](https://mediatum.ub.tum.de/doc/1343178/911973262578.pdf#:~:text=can%20be%20accurately%20decompiled%2C%20as,Our%20tool%20offers%20several%20possibilities)). The function is transformed to an infinite loop with a big **switch-case** that operates on these arrays, thus interpreting the bytecode. For example, an assignment like `x = y` in original C# might become a series of VM opcodes in the `code` array, which the interpreter loop executes by doing something like `data[x_index] = data[y_index]`. The technique is similar to how a CPU executes machine code, but here both the “machine” and its “code” are synthetic and particular to one function.

**Source Code & VM Instruction Set:** VOT4CS’s source (available on GitHub ([](https://mediatum.ub.tum.de/doc/1343178/911973262578.pdf#:~:text=virtualization%20obfuscation%20tool%20for%20C,language%2C%20VOT4CS%20operates%20at%20the))) uses the Roslyn API to parse C# code and emit the transformed code. The VM instruction set is defined at a high level – each opcode corresponds to a simplified operation (load constant, assignment, arithmetic operation, conditional jump, return, etc.). The design likely uses a **stack-machine simulated via arrays** – e.g. one could consider the `data` array as analogous to an operand stack/register file, and the `code` array as the program bytecode. An illustrative snippet of a virtualized function is shown below, following the pattern described in the VOT4CS paper:

```csharp
// Example: Structure of a function after virtualization (simplified)
object[] data = { /* initial locals & constants */ };
int[] code = { /* VM bytecode sequence */ };
int vpc = 0;  // virtual program counter
while (true) {
    switch (code[vpc++]) {
        case 0x23: // Example VM opcode (e.g., assignment)
            data[ code[vpc++] ] = data[ code[vpc++] ];
            break;
        case 0x1A: // Example VM opcode (e.g., return)
            return (int) data[ code[vpc++] ];
        case 0x52: // Example VM opcode (e.g., jump)
            vpc += (int) data[ code[vpc++] ];
            break;
        // ... other opcode handlers ...
    }
}
```

*Conceptually, VOT4CS transforms a function into a form like the above, where each case handles a custom opcode (the numbers 0x23, 0x1A, 0x52 here are illustrative) ([](https://mediatum.ub.tum.de/doc/1343178/911973262578.pdf#:~:text=code%2C%20which%20executes%20only%20on,an%20open%20source%20tool%20for)). The interpreter loop reads the next opcode and its operands from the `code` array and uses/manipulates the `data` array accordingly, thus emulating the original logic.* This design makes the control flow and data flow non-obvious to someone reading decompiled C# – they would see only the interpreter, not the original high-level code.

VOT4CS also incorporates **anti-analysis in the form of randomization** ([](https://mediatum.ub.tum.de/doc/1343178/911973262578.pdf#:~:text=features%20of%20VOT4CS%20which%20are,diversity%20is%20to%20distribute%20syntactically)). For instance, it can randomize the numeric values of opcodes or the order of non-critical operations, so that each protected build yields a somewhat different VM bytecode pattern. This helps defeat deobfuscation tools that rely on recognizing a specific bytecode signature. Because VOT4CS operates before compilation, the emitted binary is a legitimate .NET assembly containing the virtualized code (there’s no separate runtime library needed; the interpreter is baked into each protected function’s IL).

**Code Structure and Patterns:** Architecturally, VOT4CS is quite different from others: it uses a **source-to-source transformation** pattern. The project likely includes components for parsing C# with Roslyn, transforming the syntax tree (applying refactoring rules, then inserting the interpreter construct), and then outputting the modified C# source or directly emitting IL via Roslyn’s compilation. This approach leverages high-level language features (e.g., using C# types like object arrays and switch statements), resulting in obfuscated IL that still looks somewhat structured (because it’s generated by a C# compiler) but is semantically very difficult to trace. The design is modular: new virtualization handlers can be added by extending the set of opcodes and extending the switch-case generator. The **design pattern of in-function interpreter** is notable – unlike plugin-based obfuscators that inject a whole VM class, VOT4CS injects the VM logic into the function itself. This can make the obfuscation **more self-contained** but at the cost of larger method bodies. The project also emphasizes measuring performance overhead, so its pattern likely tries to keep the interpreter lean (only as complex as needed for the protected operations).

**Maintenance:** VOT4CS was released as part of academic research (around 2016) ([](https://mediatum.ub.tum.de/doc/1343178/911973262578.pdf#:~:text=SPRO%E2%80%9916%2C%20October%2028%202016%2C%20Vienna%2C,2995312)). Its GitHub repository saw updates for a short time after but has not been very active in recent years (no major updates in ~4+ years, based on repository activity). It has a small number of users (primarily researchers) and is not a mainstream obfuscation tool. As an academic proof-of-concept, it served to demonstrate the feasibility of source-level virtualization and to experiment with attacks/defenses in papers. Thus, it may not support the latest C# features or .NET versions without modification. The project is open-source, so interested developers could fork it to update Roslyn dependencies or expand the opcode set. In summary, VOT4CS is **mostly unmaintained** at this point, but it remains an invaluable reference for how virtualization can be implemented via compiler tooling. The latest code and documentation can be obtained from its repository ([](https://mediatum.ub.tum.de/doc/1343178/911973262578.pdf#:~:text=virtualization%20obfuscation%20tool%20for%20C,language%2C%20VOT4CS%20operates%20at%20the)), which includes examples and possibly evaluation benchmarks used in the associated research publication.

**References:** The above analysis cites information and descriptions from the projects’ documentation and relevant research blogs for accuracy and specificity. Each project’s name is linked to its source or documentation for further exploration.  ([GitHub - Loksie/KoiVM-Virtualization: Virtualization made for .NET using ConfuserEX](https://github.com/Loksie/KoiVM-Virtualization#:~:text=Is%20a%20virtual%20machine%20made,if%20not%20all%20the%20cases)) ([GitHub - Loksie/KoiVM-Virtualization: Virtualization made for .NET using ConfuserEX](https://github.com/Loksie/KoiVM-Virtualization#:~:text=,Only%20supported%20OS%20is%20Windows)) ([DotRunpeX - demystifying new virtualized .NET injector used in the wild - Check Point Research](https://research.checkpoint.com/2023/dotrunpex-demystifying-new-virtualized-net-injector-used-in-the-wild/#:~:text=Unfortunately%20for%20us%2C%20we%20are,used%20to%20define%20registers%2C%20flags)) ([GitHub - TobitoFatitoRE/MemeVM: A small virtualizer for .NET which works together with ConfuserEx](https://github.com/TobitoFatitoRE/MemeVM#:~:text=,No%20support%20for%20pointers)) ([GitHub - Modify24x7/StrongVM: StrongVM is a virtualizing protector for .NET applications.](https://github.com/Modify24x7/StrongVM#:~:text=Features)) ([StrongVM](https://strongvm.blogspot.com/#:~:text=,v4.8%20%5BWindows)) ([](https://mediatum.ub.tum.de/doc/1343178/911973262578.pdf#:~:text=have%20to%20employ%20technical%20means,off%20offered%20by%20the%20tool)) ([](https://mediatum.ub.tum.de/doc/1343178/911973262578.pdf#:~:text=The%20work,source%20code.%20Roslyn))

