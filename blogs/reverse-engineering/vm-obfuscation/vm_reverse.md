Understood. I’ll dig into write-ups, tweets, blog posts, and reverse engineering case studies by skilled practitioners who have analyzed JavaScript virtualization VMs like the one used in js-virtualizer. This will include techniques for deobfuscation, stepping through custom bytecode VMs, and comparing this process to reverse engineering native VM bytecode or machine code. I’ll get back to you with insights, strategies, and references from experienced reversers.

# Reverse Engineering JavaScript Virtual Machines Under Heavy Obfuscation

## What is JavaScript Virtualization Obfuscation?  
JavaScript virtualization-based obfuscation transforms certain functions or code segments into a **custom bytecode** and an embedded **interpreter (VM)** that runs this bytecode ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=Virtualization%20obfuscation%20is%20a%20state,thereby%20executing%20the%20actual%20code)). In other words, the original code is compiled into an intermediate bytecode, and a JavaScript function (the VM) executes it instruction by instruction. The original logic never appears as normal JS code; it’s hidden in the VM’s bytecode. An attacker must first reverse-engineer the VM (often itself **heavily obfuscated**) to understand the bytecode’s instruction set before they can recover the original code’s logic ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=Since%20the%20bytecode%20is%20executed,to%20analyze%20the%20actual%20bytecode)). This technique is considered a state-of-the-art obfuscation scheme because it adds an entire **custom ISA (instruction set architecture)** layer that reversers have to peel back ([Writing Disassemblers for VM-based Obfuscators](https://synthesis.to/2021/10/21/vm_based_obfuscation.html#:~:text=Virtual%20machines%20,aren%E2%80%99t%20meaningful%20for%20a%20reverse)).

**Heavy obfuscation on the VM implementation** makes this even more challenging. Protectors often rename variables and functions to meaningless identifiers (frequently **hexadecimal gibberish** names like `_0x5c2c98` etc.), apply **control-flow flattening** (merging or nesting many conditions and gotos so that the VM’s dispatcher loop isn’t obvious), and use **opaque predicates or dead code** to confuse analysis. They may also include **anti-debugging tricks** such as stalling loops or checks to hinder stepping through in a debugger ([Analysis of JS Virtualization - JS Virtualization](https://blog.jsvmp.com/js-virtualization/#:~:text=,include%20modifying%20the%20behavior%20of)). The result is a JavaScript file that, at first glance, is extremely difficult to read or analyze. For example, one malware analysis notes the common use of **hexadecimal values as names** for variables/functions and splitting strings into encoded chunks to reconstruct at runtime ([How to analyze JavaScript obfuscation](https://blog.cyber5w.com/Javascript-deobfuscation-techniques.html#:~:text=Image)) – these tricks complicate static reading.

## Challenges Posed by an Obfuscated JS VM  
Reversing such a virtualized and obfuscated script is daunting. Key challenges include:

- **Unreadable Identifiers & Structure:** Variables and function names are randomized (often hex-like), so you can’t infer their purpose by name ([How to analyze JavaScript obfuscation](https://blog.cyber5w.com/Javascript-deobfuscation-techniques.html#:~:text=This%20naming%20schema%20is%20a,way%20of%20obfuscating%20JS%20files)). The code tends to be one giant function or a few functions with **deeply nested logic**. For instance, in one real case the VM’s main loop was a single `for(;;)` with cascaded `if/else` blocks handling each opcode ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=if%20%28_0xd2004%20,else)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=We%20can%20see%20that%20this,is%20our%20instruction%20pointer)). This flattening means the logical flow isn’t obvious – all opcodes are handled in one big blob of code. It reduces the number of distinct branch instructions, but produces a tangle of nested conditions ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=The%20first%20one%20was%20a,are%20testing%20the%20same%20variable)).

- **Opaqueness of the Bytecode:** The bytecode itself might be stored as a large hex string or array of numbers. Often it’s **encoded or encrypted**. For example, TikTok’s web app included huge hex strings passed into VM functions ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=that%20looked%20like%20this%3A)). Those turned out to start with magic constants and included an XOR-based string encoding ([Reverse Engineering Tiktok's VM Obfuscation (Part 1) | nullpt.rs](https://www.nullpt.rs/reverse-engineering-tiktok-vm-1#:~:text=%2F%2F%20the%20second%20item%20is,weirdString%2C%20instructionPointer)) ([Reverse Engineering Tiktok's VM Obfuscation (Part 1) | nullpt.rs](https://www.nullpt.rs/reverse-engineering-tiktok-vm-1#:~:text=function%20readOpcode,2%2C%20instructionPointer%20%2B%204)). A reverser must decipher this format: figure out how the bytecode is structured (headers, tables, encoded literals, etc.) before even worrying about the VM’s opcodes.

- **Anti-Debug and Anti-Tamper:** Obfuscated VMs may try to detect debugging. They could use `toString` traps, `debugger` statements, or check timings. Some implementations run inside a `try/catch` so that any attempt to step through might constantly throw (the catch being part of normal control flow). The JS virtualization blog mentions **deliberate delays and anti-debugging** to disrupt analysis ([Analysis of JS Virtualization - JS Virtualization](https://blog.jsvmp.com/js-virtualization/#:~:text=scrambling%2C%20control%20flow%20flattening%2C%20and,effective%20technique%20for%20protecting%20sensitive)). As a reverse engineer, you often must **patch out or bypass** these tricks (e.g. disable break-on-exception, remove infinite loops or timeouts) to make dynamic analysis feasible.

- **Custom and Unique VM per Sample:** Unlike standard JS or known bytecode (like WebAssembly), each obfuscator’s VM can be unique. Research has shown that automated generic devirtualization is hard – each VM’s instruction set and obfuscation may require custom effort ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=Since%20any%20two%20virtualization%20obfuscations,1%5D%20%2C%20%204)). So tools need adaptation per target.

Despite these challenges, reverse engineers have developed practical methods to tackle JavaScript VMs. In fact, reversing a JS-based VM can sometimes be **easier than a native VM** in one sense: *the “source” is right in front of you*. As one security blog puts it, you at least have the code (however obfuscated) instead of raw machine bytes ([Reverse Engineering JS by Example | F5](https://www.f5.com/company/blog/reverse-engineering-by-example-flatmap-stream-payload-a#:~:text=Reverse%20engineering%20most%20JavaScript%20is,expressions%20like%20true%20to%20something)). This gives some advantages that we can leverage.

## Approaches to Reverse-Engineer an Obfuscated JS VM  
Reverse-engineering a JavaScript VM typically involves **both static deobfuscation and dynamic analysis**, plus a healthy dose of custom scripting. Here are the common strategies and steps, distilled from expert write-ups and case studies:

### 1. **Prettify and Prepare the Code**  
Start by formatting the script and getting a somewhat readable version. Obfuscators often remove whitespace and mangle code into one line. Use a JavaScript beautifier or formatter (like Prettier) to re-indent and line-break the code. This won’t solve naming issues, but it makes the structure visible. Often you will spot a suspicious large function with a loop – that’s likely the VM dispatcher.

Next, **rename variables for clarity**. If variable names are all hex, you might do this manually or use tools. For example, renaming `_0x4f176d` to `stack` and `_0x53c743` to `stackPtr` can help you track their role. In the TikTok VM analysis, the researcher extracted all the VM handler functions to separate files and systematically renamed parameters and locals to things like `opcode`, `stack`, `R0-R4`, etc., based on their position or behavior ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=There%20are%20dozens%20of%20them,and%20a%20list%20of%20instructions)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=The%20usage%20of%20,The%20instructions%20do%20things%20like)). This made it clearer that, for instance, `_0x4f176d` was used as an operand stack and `_0x53c743` as its index (stack pointer) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=The%20usage%20of%20,The%20instructions%20do%20things%20like)).

If the control flow is heavily flattened (e.g. deeply nested if-else for opcodes), consider **automating AST transforms** to simplify it. In one case, the VM had a chain of `if (_0xd2004 < X) { ... } else if (_0xd2004 < Y) { ... }` to handle opcodes ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=if%20%28_0xd2004%20,else)). A custom Babel plugin was written to restructure these nested conditionals into a cleaner, flatter switch-like form ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=The%20first%20one%20was%20a,are%20testing%20the%20same%20variable)). Flattening the dispatcher logic in this way makes it easier to see each opcode case separately rather than mentally untangling nested conditions.

### 2. **Identify the Bytecode and Decode Data**  
Typically, the VM function takes a big encoded string or array – that’s the **bytecode**. Analyze how the bytecode is processed at the start of the VM function. Often there will be an initial “decoder” that prepares an array of byte values or decodes an encryption key. In the TikTok VM example, the first part of each VM function pulled out a 32-bit key from the bytecode header and then XOR-decoded a set of embedded strings and opcodes using that key ([Reverse Engineering Tiktok's VM Obfuscation (Part 1) | nullpt.rs](https://www.nullpt.rs/reverse-engineering-tiktok-vm-1#:~:text=%2F%2F%20the%20second%20item%20is,weirdString%2C%20instructionPointer)) ([Reverse Engineering Tiktok's VM Obfuscation (Part 1) | nullpt.rs](https://www.nullpt.rs/reverse-engineering-tiktok-vm-1#:~:text=function%20readOpcode,2%2C%20instructionPointer%20%2B%204)). The reverser wrote a small script to mimic this decoder logic (using the same bitwise operations) and successfully recovered a list of plaintext strings hidden in the bytecode ([Reverse Engineering Tiktok's VM Obfuscation (Part 1) | nullpt.rs](https://www.nullpt.rs/reverse-engineering-tiktok-vm-1#:~:text=const%20stringDataLocation%20%3D%20instructionPointer%20%2B,log%28strings%29%3B)) ([Reverse Engineering Tiktok's VM Obfuscation (Part 1) | nullpt.rs](https://www.nullpt.rs/reverse-engineering-tiktok-vm-1#:~:text=We%20obtain%20the%20following%20output%3A)). 

By replicating the bytecode decoding in a controlled way (e.g., in a Node.js script or Python), you can extract helpful info: a list of constant strings, numeric constants, or an initial **decoded bytecode array** that the VM will execute. This is a big win, as it turns the opaque hex blob into a sequence of bytes (opcodes) and data values that you can analyze further. Essentially, you *“unpack”* the virtualized payload.

### 3. **Analyze the VM Loop and Instruction Handler Structure**  
Once the code is formatted and the bytecode data is accessible, focus on the **VM’s execution loop**. In many VMs (even native ones), there’s a recognizable pattern: a loop that fetches an opcode value and then a giant switch or if/else tree that chooses what to do for each opcode ([Writing Disassemblers for VM-based Obfuscators](https://synthesis.to/2021/10/21/vm_based_obfuscation.html#:~:text=We%20see%20a%20control,virtual%20addition%20or%20push%2Fpop%20instructions)). Identify the variable that serves as the **instruction pointer** (program counter into the bytecode array) – in JS this is often a numeric index incremented as instructions and operands are read. For example, `_0x3178c9` was identified as the bytecode pointer in TikTok’s VM ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=We%20can%20see%20that%20this,is%20our%20instruction%20pointer)), since the code did things like `var opcode = bytecodeArray[_0x3178c9++]` each iteration.

With the bytecode array and instruction pointer known, map out how the dispatcher works. Does it use a `switch(opcode)` or a series of `if` ranges? Is there a loop like `for(;;)` or `while(true)` wrapping it? In one case, the code was literally: 

```js
for (;;) {
  try {
    let _0xd2004 = bytecodeArr[instrPtr++];  // fetch opcode
    if (_0xd2004 < 3) { ... } else 
    if (_0xd2004 < 4) { ... } else 
    if (_0xd2004 === 4) { ... } else
    // ... and so on ...
  } catch(e) { break; }
}
``` 

This was clearly the VM’s **fetch-decode-execute loop** ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=%2F%2F%20string%20decoder%20goes%20here)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=if%20%28_0xd2004%20,else)). The try/catch was used to break out of the loop (e.g., an out-of-range fetch throws and signals VM termination) in that implementation. Recognizing this structure is crucial – it tells you *where* each opcode’s behavior is implemented (inside those branches).

Each branch (or case) corresponds to a **handler** for one or a range of opcodes. Now, **reverse engineer each handler’s effect**. This is like building a table of opcode meanings. For example, you might see something like: 

```js
if (_0xd2004 < 3) {
    _0x4f176d[++_0x53c743] = _0xd2004 === 0 || null;
}
```

From this, one can deduce: if opcode is 0 or 1 or 2 (since `<3`), then it pushes a value onto the stack – specifically, it pushes `true` for opcode 1, `false` for opcode 0 (because `0 === 0 || null` yields `true`), and `null` for opcode 2 (since `2 === 0` is false, the expression yields `null`). Indeed, the reverser noted that the first opcodes were used to **push `true`, `false`, or `null` onto the VM stack** ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=if%20%28_0xd2004%20,8%29)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=,object%20passed%20into%20the%20VM)). 

Another handler might read subsequent bytes as an immediate operand. E.g., an opcode 4 branch did: read two next bytes, combine into a 16-bit number, sign-extend it, and push that on the stack ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=_0xb14b3d%20%3D%20_0x146ed2,else)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=if%20%28_0xd2004%20,24%3B)) – indicating opcode 4 was a “load 16-bit constant” instruction. By reading the code logic, you iteratively assign meaning to each opcode (often giving them names like *PUSH_NULL*, *PUSH_CONST8*, *PUSH_CONST16*, *GET_STRING*, *CALL*, etc.). Many instructions will interact with a **VM stack** or a set of **VM registers**. In JS VMs, it’s common to implement a stack machine. For TikTok, the analysis showed a dynamic array `_0x4f176d` growing and shrinking – clearly a stack – and a handful of local vars that acted like registers (some VMs use a few working registers along with a stack) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=Inside%20this%20VM%2C%20we%20see,of%20instructions%20work%20like%20this)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=_0xb14b3d%20%3D%20%28_0x146ed2%5B_0x3178c9%5D%20,16%3B)).

It’s worth noting that in some cases, not all opcodes appear in a single VM instance. Obfuscators might optimize unused opcodes out. TikTok’s protector generated dozens of slightly different VM functions – each function’s VM only included the handlers it needed. This meant no single VM contained the full opcode set. The reverser overcame this by **merging the handler logic from all instances**: they wrote a script to collect conditions from every VM and union them into a comprehensive handler set ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=The%20second%20one%20was%20missing,not%20used%20are%20optimized%20away)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=The%20solution%20was%20,piece%20of%20code%20came%20from)). Essentially, if one VM handled opcodes `< 0x10` and another `< 0x08`, combining them revealed handlers for opcodes 0–7, 8–15, etc., across the union. This clever approach produced a “giant pseudo-VM” with all possible handlers, allowing the researcher to enumerate the meaning of **every opcode** in the superset ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=range%20of%20numbers%20covered%20by,piece%20of%20code%20came%20from)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=,%2F%2F%20omitted)).

### 4. **Dynamic Debugging and Instrumentation**  
While static analysis of the code is powerful, running the code in a debugger can greatly speed up understanding. One major **advantage of a JS VM over a native VM** is that you can use high-level debugging tools (like Chrome/Firefox DevTools or Node’s inspector) on the actual obfuscated code. You can set breakpoints inside the VM loop and **watch the variables change** as it runs. For example, you might break at the start of each iteration and examine the value of the `opcode` variable and the top of the stack array. This way, you confirm what each opcode does by seeing it in action. In practice, Ibiyemi Abiodun built a custom disassembler and then ran the real VM to verify that the disassembler’s output matched the VM’s behavior, using “a little bit of debugging to make sure its behavior matched the real VMs” ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=Armed%20with%20an%20approximate%20description,like%20format)).

**Instrumenting the VM** is also feasible: because you control the JS environment, you can modify the code on the fly. For instance, you could insert `console.log()` statements (or collect info in an array) at strategic points: log every opcode executed, log stack pushes/pops, etc. If manual insertion is tedious, you can use an AST tool (like Babel) to programmatically inject logging after each handler block. Running the obfuscated code with such instrumentation will give you a detailed **trace of the bytecode execution**. From that, you could reconstruct higher-level logic (similar to how one might trace a native VM in a debugger, but here it’s in JS so you can simply run it). There are even research tools in the native world that take an execution trace and filter out the VM overhead, leaving the virtual instruction sequence ([GitHub - jnraber/VirtualDeobfuscator: Reverse engineering tool for virtualization wrappers](https://github.com/jnraber/VirtualDeobfuscator#:~:text=promising,I%20have%20tested%20it%20on)) ([GitHub - jnraber/VirtualDeobfuscator: Reverse engineering tool for virtualization wrappers](https://github.com/jnraber/VirtualDeobfuscator#:~:text=The%20Virtual%20Deobfuscator%20is%20based,This%20means%20that%20most)) – one could analogously record the JS VM’s execution to get the protected bytecode sequence in human-readable form.

Be mindful of anti-debug tricks though. If the VM detects `debugger` or tries to break out when DevTools is open, you may need to neutralize those checks (e.g., by patching the code to remove the check or to disable the anti-debug conditional). The flexibility of JavaScript lets you do that patch easily (just edit the script or redefine certain functions at runtime). In contrast, patching a native binary’s anti-debug is much harder. Here, you can even **monkey-patch built-in APIs** if needed – e.g., override `setTimeout` to a no-op if the VM uses delays to deter you.

### 5. **Reconstruct the High-Level Logic**  
After identifying the opcodes and what they do, the final goal is to rebuild the original algorithm or code. In many cases, a **disassembly of the bytecode** is sufficient to understand the gist. For example, Abiodun’s disassembler for TikTok’s VM produced an assembly-like listing of instructions such as: 

```
0000: 0x11 (17) deref.get 0x01, 0x01  
0003: 0x14 (20) deref.set 0x00, 0x03  
0006: 0x11 (17) deref.get 0x02, 0x00  
0009: 0x12 (18) get.imm  0x0002  "fromCharCode"  
... 
0024: 0x43 (67) call.s   0x01    (call subroutine 1)  
0026: 0x43 (67) call.s   0x02    (call subroutine 2)  
... 
0043: 0x27 (39) popc.lt              (compare top of stack)  
0044: 0x47 (71) popcjump 0x000c      (conditional jump)  
...
``` 

This is a **pseudo-assembly** of the protected code ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=off%20%20hex%20dec%20instr,null)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=0021%200x11%20%2017%20deref,lt)). Each mnemonic (like `deref.get`, `get.imm`, `call.s`, etc.) was assigned by the reverser to describe what that opcode does (e.g., `deref.get X,Y` might mean “load property Y from object X”, etc.). Even without a full decompiler, this kind of listing is a huge help to understand program logic. In the snippet above, one can deduce it’s getting some global values, calling subroutine 1 and 2, doing a comparison and conditional jump – likely implementing some loop or conditional logic of the original code.

In some scenarios, you may go further and attempt an **automated decompilation**: translating the bytecode back to high-level JavaScript or pseudocode. This is quite complex and usually done on a case-by-case basis. (The TikTok reverser hinted at building a custom decompiler in a future part ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=Since%20these%20aren%E2%80%99t%20real%20assembly,3%20after%20I%20do%20that)).) However, once you have the disassembled instructions and understand the main data structures (stack, registers), writing a decompiler is *feasible*. It involves pattern-matching instruction sequences into higher-level constructs (e.g. a sequence of compare and popcjump opcodes becomes an `if` statement in JS, a series of pushes and a call become a function call, etc.). This is analogous to decompiling any assembly – just with a custom ISA. There are academic techniques like **symbolic execution** that can assist here. In fact, researchers like Tim Blazytko have shown that by symbolically executing through a VM’s handler functions, you can algorithmically map virtual opcodes to their effect on symbolic CPU state ([Writing Disassemblers for VM-based Obfuscators](https://synthesis.to/2021/10/21/vm_based_obfuscation.html#:~:text=After%20I%20recently%20gave%20a,obfuscators%20based%20on%20symbolic%20execution)) ([Writing Disassemblers for VM-based Obfuscators](https://synthesis.to/2021/10/21/vm_based_obfuscation.html#:~:text=We%20see%20a%20control,virtual%20addition%20or%20push%2Fpop%20instructions)). In JS, one could similarly use symbolic execution on the JS VM code to derive each opcode’s semantics, but given we can directly run and observe the VM, most practitioners haven’t needed full symbolic automation. Instead, writing custom scripts and using brainpower tends to be effective enough for these custom protections.

### 6. **Automation Tools and Scripts**  
While there is no one-size-fits-all devirtualizer for JavaScript, several tools can significantly aid the process:

- **AST-based Deobfuscation Tools:** Since JavaScript is high-level, you can use Babel or other AST frameworks to automate many deobfuscation steps. For example, the community has Babel plugins to simplify control-flow or evaluate constant expressions. In reversing JS VMs, custom Babel scripts were used to flatten nested conditionals ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=The%20first%20one%20was%20a,are%20testing%20the%20same%20variable)), inline or remove dead code, and merge different VM handlers ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=The%20solution%20was%20,piece%20of%20code%20came%20from)). This kind of *programmatic refactoring* is a huge time saver compared to manually editing thousands of lines. Open-source projects like *babel-plugin-deobfuscate* and others on GitHub provide templates for common transformations (unflattening control flow, decoding strings, etc.).

- **Runtime Instrumentation:** Tools like Chrome DevTools, Puppeteer, or even Node’s `vm` module can be leveraged. For instance, you can run the obfuscated code in a headless browser with DevTools Protocol, set breakpoints, and script the debugging session to dump information. There are also sandbox analyzers for JS malware (like [deobfuscate.io](https://deobfuscate.io) mentioned in one blog ([How to analyze JavaScript obfuscation](https://blog.cyber5w.com/Javascript-deobfuscation-techniques.html#:~:text=Also%20because%20of%20that%2C%20some,version%20of%20it%20for%20you))) that can execute obfuscated scripts and try to output a prettier version. These aren’t tailored to custom VMs specifically, but they use heuristics to undo common JS obfuscation layers.

- **Custom Emulators/Interpreters:** After deducing the bytecode format and opcodes, you can write your own **emulator** for the bytecode. This could be in JavaScript itself or another language like Python. By simulating the VM, you can execute the protected bytecode *outside* of the original obfuscated environment. This is useful if you want to step through the bytecode at a higher level or feed in different inputs. For example, if the VM implements some algorithm, you could run the bytecode in your emulator to see outputs for various inputs, effectively treating it like reversing any algorithm. In practice, once a reverser maps out most instructions, building a quick interpreter is straightforward (since most JS VM instructions mirror JS capabilities like arithmetic, stack ops, method calls, etc.). The TikTok researchers did publish a partial interpreter in TypeScript to decode strings and disassemble bytecode ([Reverse Engineering Tiktok's VM Obfuscation (Part 1) | nullpt.rs](https://www.nullpt.rs/reverse-engineering-tiktok-vm-1#:~:text=function%20readOpcode,2%2C%20instructionPointer%20%2B%204)) ([Reverse Engineering Tiktok's VM Obfuscation (Part 1) | nullpt.rs](https://www.nullpt.rs/reverse-engineering-tiktok-vm-1#:~:text=function%20getStringsDecoded,opcodeLength%3B%20let%20stringBuffer%20%3D)), which is an initial step toward a full emulator.

- **Malware RE Tools:** Although aimed at native code, tools like IDA or Ghidra aren’t directly applicable to JS. However, if a VM uses WebAssembly (as some advanced protectors do for performance ([Analysis of JS Virtualization - JS Virtualization](https://blog.jsvmp.com/js-virtualization/#:~:text=Existing%20JavaScript%20protection%20solutions%20are,is%20implemented%20in%20C%2FC%2B%2B%20to))), you might end up needing those tools to analyze the WASM module implementing the VM. (Some protectors compile the VM to WASM so that reversers face a native-level challenge inside the browser ([Analysis of JS Virtualization - JS Virtualization](https://blog.jsvmp.com/js-virtualization/#:~:text=bypass%20protection,loading%20into%20the%20target%20application)).) In general for pure JS, you’ll stick to JS-centric tools.

## Comparison: JS VM vs Native VM Reversing  
Reverse-engineering a **JavaScript-implemented VM** offers a few notable advantages over the classic case of a VM embedded in native code:

- **Source-Level Visibility:** With JavaScript, you **have the code** (albeit obfuscated) available. You don’t need to disassemble raw bytes into code – it’s already text. As F5 security researchers noted, reversing JS is often more straightforward than binary because *“after all, the source is right in front of you”* ([Reverse Engineering JS by Example | F5](https://www.f5.com/company/blog/reverse-engineering-by-example-flatmap-stream-payload-a#:~:text=Reverse%20engineering%20most%20JavaScript%20is,expressions%20like%20true%20to%20something)). This means you can apply high-level reasoning and use text search (e.g., search for `Math.min` or specific constants) to locate parts of interest. In a native VM, you must first decode assembly and deal with compiler optimizations.

- **Dynamic Introspection:** A JS VM runs on a real JS engine, which you can harness. You can pause execution, inspect variables, change them, skip instructions, etc., all with built-in debugging tools. This **debuggability** is a huge edge. In contrast, debugging a native VM protection requires a low-level debugger (like OllyDbg/x64dbg) and you risk anti-debug tricks at the OS level. In JS, the worst you typically face is some obfuscated checks which, as mentioned, you can often neuter by editing the code on the fly.

- **High-Level Libraries for Parsing/Modifying Code:** The abundance of JavaScript parsers and AST libraries means you can write scripts to **deobfuscate structurally**. For example, flattening control flow or substituting constants via Babel is much easier than writing an IDA Python script to decompile a binary’s VM handlers. This speeds up reversing. The TikTok VM reversing heavily relied on custom Babel plugins to merge and simplify code across dozens of VM functions ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=The%20first%20one%20was%20a,are%20testing%20the%20same%20variable)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=The%20solution%20was%20,piece%20of%20code%20came%20from)), something that has no real native equivalent (you can’t so easily merge several binary blobs of handlers without a lot of manual work).

- **No Real “Anti-RE” at system level:** JavaScript can’t prevent you from reading its code – once you have the JS file, there’s no DRM on it. Native protections sometimes pack or encrypt the code in memory. With JS, the most they can do is make it hard to read or try to detect debugging, but they can’t hide the code completely or stop you from instrumenting it, because the browser must run it in plain form. You also don’t have to worry about things like self-modifying code (usually) or binary encryption beyond maybe string scrambling.

That said, JS VMs can still be *very complex* and time-consuming to reverse. They can implement hundreds of opcodes, and the logic can span thousands of lines of obfuscated code. The performance overhead also means such VMs are relatively rare (used only to protect the most sensitive client logic, since running an entire large application on a custom VM would be too slow). But when they are used, these advantages give reversers a fighting chance.

Notably, authors of JS obfuscators are aware of these advantages, so they try to mitigate them. For instance, the `js-virtualizer` project itself warns users to **obfuscate the VM engine code** before release: *“including the opcode names in the VM makes it more trivial to reverse engineer... given the virtual machine, the virtualized function is pretty trivial to reverse”* ([GitHub - aesthetic0001/js-virtualizer: Virtualization-based obfuscation for javascript](https://github.com/aesthetic0001/js-virtualizer#:~:text=It%20is%20highly%20recommended%20that,workings%20of%20the%20virtualized%20code)) ([GitHub - aesthetic0001/js-virtualizer: Virtualization-based obfuscation for javascript](https://github.com/aesthetic0001/js-virtualizer#:~:text=need%20to%20protect%20your%20code,is%20not%20guaranteed%20that%20the)). In practice, protectors will remove any helpful metadata (no opcode names or comments in the VM), and might even split the interpreter across multiple functions or use indirect calls to make tracing harder. Some go as far as implementing parts of the VM in WebAssembly (as mentioned) to force a reverser into a hybrid JS/native analysis ([Analysis of JS Virtualization - JS Virtualization](https://blog.jsvmp.com/js-virtualization/#:~:text=bypass%20protection,loading%20into%20the%20target%20application)). But even then, the integration points (how JS calls into the WASM module) can be hooked or observed via the browser.

## Case Studies and Examples in the Wild  
Several **real-world examples** illustrate how skilled reverse engineers approach these protections:

- **TikTok Web App VM (2022-2023):** TikTok deployed a custom JS VM in their web client to hide certain telemetry and anti-bot logic. The initial discovery was documented by a researcher under the handle “Veritas” ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=One%20day%2C%20I%20stumbled%20across,up%20where%20they%20left%20off)), and a follow-up deep-dive by Ibiyemi Abiodun (a.k.a. @laptou) picked up from there ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=javascript%20%202reverse)). They found multiple functions like `_0x4c03ae()` that take a long hex string and an object of getters, and then execute a virtualized routine ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=The%20most%20interesting%20bits%20contained,calls%20that%20looked%20like%20this)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=setup)). Through AST analysis, they uncovered the bytecode decryption using an XOR key, extracted all the hidden strings (like `'substr', 'length', '_mssdk'` etc. that hinted at functionality) ([Reverse Engineering Tiktok's VM Obfuscation (Part 1) | nullpt.rs](https://www.nullpt.rs/reverse-engineering-tiktok-vm-1#:~:text=We%20obtain%20the%20following%20output%3A)) ([Reverse Engineering Tiktok's VM Obfuscation (Part 1) | nullpt.rs](https://www.nullpt.rs/reverse-engineering-tiktok-vm-1#:~:text=%27,urlencoded%27%2C%20%27application%2Fjson)), and reconstructed the VM’s operation as described earlier. Using Babel to de-nest conditionals and merge partial implementations, they enumerated ~76 distinct opcodes and determined their behavior ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=%7D%20else%20if%20%28instruction%20,76%29%20%7B)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=,object%20passed%20into%20the%20VM)). For example, they identified opcodes for pushing constants, reading/writing properties via that mysterious object of getters (which mapped numeric IDs to real JS objects like `window`, `document`, `XMLHttpRequest`, etc. allowing the bytecode to interact with the outside world) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=,return%20XMLHttpRequest%3B)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=%7D%2C%20get%200xa%28%29%20,return%20_0x1aafcc%3B)). In the end, they built a disassembler that could translate the hex bytecode into an assembly listing, making it far easier to see what data was being gathered and how ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=off%20%20hex%20dec%20instr,null)) ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=0021%200x11%20%2017%20deref,lt)). This case demonstrated *practical techniques*: using automated AST transforms, writing custom scripts to assist analysis, and iteratively guessing and verifying opcode functions. (It was implied a full decompiler could be built next ([Reverse Engineering TikTok's VM Obfuscation | Ibiyemi Abiodun](https://ibiyemiabiodun.com/projects/reversing-tiktok-pt2/#:~:text=Since%20these%20aren%E2%80%99t%20real%20assembly,3%20after%20I%20do%20that)), though those results were not published due to policy.)

- **Custom VM in Malware (Hypothetical):** While not as commonly documented as native packer VMs, there have been malware (or at least aggressive adware/protectors) in the JS space. A notable strategy is that some **malicious loaders** will include a JS VM to execute a second-stage payload. Reverse engineers approach these similarly: run the script in a safe environment (like SpiderMonkey or a headless browser) and hook into `eval` or other APIs to catch the moment the bytecode is executed. If possible, dump the bytecode and then either feed it into the real VM step by step or emulate it. Common JS malware analysis techniques – like replacing `eval` with a print function to reveal decrypted code – sometimes work if the VM eventually evals some result. But if all malicious logic stays inside the VM, one must reverse it fully. Tools such as the CyberChef or custom Node scripts come in handy to do things like bulk XOR decode strings (once the key is known) or to brute-force simple encoding used in bytecode.

- **Academic and Community Tools:** Johannes Willbold’s *Rusty-JSYC* (a JS virtualization project) was accompanied by a blog *“The Secret Guide to Virtualization Obfuscation in JavaScript”*. In it, he emphasizes making the VM architecture “complicated and nasty” to thwart analysis ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=never%20restored%20anywhere,to%20analyze%20the%20actual%20bytecode)) ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=Constructing%20an%20instruction%20set)). Interestingly, he notes any two virtualization schemes can differ so much that automated tools struggle ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=Since%20any%20two%20virtualization%20obfuscations,1%5D%20%2C%20%204)). On the flip side, Rolf Rolles’ earlier work *“Unpacking Virtualization Obfuscators”* (2009) ([The Secret Guide To Virtualization Obfuscation In JavaScript | Johannes Willbold](https://jwillbold.com/posts/obfuscation/2019-06-16-The-Secret-Guide-To-Virtualization-Obfuscation-In-JavaScript/#:~:text=match%20at%20L342%201.%20,Obfuscated)) and later research by Jacob Kinder (2012) attempted static devirtualization of native code. They found it to be NP-hard in general, reinforcing why dynamic analysis (or at least hybrid methods) is often the go-to. Tim Blazytko’s 2021 workshop and blog on **writing VM disassemblers via symbolic execution** ([Writing Disassemblers for VM-based Obfuscators](https://synthesis.to/2021/10/21/vm_based_obfuscation.html#:~:text=After%20I%20recently%20gave%20a,obfuscators%20based%20on%20symbolic%20execution)) was focused on native obfuscators like Tigress, but many concepts carry over. For example, identifying the dispatcher and handlers via the unique control-flow shape ([Writing Disassemblers for VM-based Obfuscators](https://synthesis.to/2021/10/21/vm_based_obfuscation.html#:~:text=We%20see%20a%20control,virtual%20addition%20or%20push%2Fpop%20instructions)) is something a JS reverser also tries to do (just reading JS logic rather than a decompiled C graph).

- **Other Obfuscation Tools:** Commercial JavaScript protectors like *JScrambler* or open projects like *Enigma* apply virtualization among other techniques. Public analyses of these are sparse (companies keep their schemes secret), but some researchers have shown interest in breaking them. Often, they share tips on Twitter or blogs without full code due to legal concerns. Known RE practitioners in this space include people like **@veritas** (nullpt.rs), **@laptou** (Ibiyemi), **@johannes_willbold**, and folks at security companies (e.g., the F5 Labs example, or analysts at Palo Alto Unit 42 etc., who deal with obfuscated JS malware). Following these individuals can provide insight into new techniques or tooling.

## Practical Tips and Takeaways  
In summary, **reverse-engineering a JS-based virtual machine is difficult but doable** with a methodical approach:

- *Use the browser/Node to your advantage:* set breakpoints on the VM loop, watch the pseudo-registers and stack as the bytecode runs. You have a live execution environment – leverage it.

- *Leverage AST tools:* Write small scripts to rename variables, flatten control flow, and extract duplicated code. This automates the tedious parts of deobfuscation.

- *Reverse engineer incrementally:* Don’t try to understand everything at once. Tackle one opcode or one small group of handlers at a time. Build up a table of instructions as you go. Often understanding a few key opcodes (like how a conditional jump is done, or how function calls are handled) will then unlock understanding of larger code patterns.

- *Watch out for tricky math or logic in handlers:* Obfuscators might implement an opcode’s effect in a convoluted way (e.g., computing a value with bit tricks so it’s not obvious it’s an addition). If something looks like a math puzzle, consider evaluating it with actual numbers or even using a solver/symbolic tool to simplify it.

- *Common VM patterns:* Many virtual JS protections end up implementing things like a **stack**, some **registers**, a way to call subroutines (often an opcode that pushes a return address and jumps, or directly a `call` opcode that makes a nested call to another JS function or bytecode). Recognize these patterns. For instance, if you see an array of functions and an opcode used as an index into it, that’s a typical *computed dispatch* (each function in the array is a handler). If you see an opcode leading to `someArray.push(value)`, likely it’s a push instruction. Over time, you build intuition for these.

- *Don’t get lost in the weeds:* These obfuscators deliberately include junk code or overly complex control flow. Focus on the core mechanism (the dispatch loop and real effects on program state). You can ignore or remove any “scenery” that doesn’t affect that (e.g., dummy arithmetic on a temp variable that isn’t used, etc.). One paper humorously titled **“Don’t flirt with FLA” (FLA = Flattening)** ([Don't flatteN yourself: deobfuscating malware with Control-Flow ...](https://www.virusbulletin.com/conference/vb2023/abstracts/dont-flatten-yourself-deobfuscating-malware-control-flow-flattening/#:~:text=Don%27t%20flatteN%20yourself%3A%20deobfuscating%20malware,is%20disabled%20in%20your%20browser)) discusses defeating Control-Flow Flattening – often, simplifying the flattening is just a matter of recognizing a dispatcher loop structure, which we do as part of VM reversing.

Lastly, be patient and document your findings. Reverse engineering a virtualization obfuscation can feel like solving a complex puzzle. Each opcode you decipher is like finding a piece of the puzzle’s picture. With enough pieces, the full image (the original program logic) will emerge. And remember, while it’s a cat-and-mouse game (protectors will try new tricks), the reverser has one ultimate advantage: **the code must run for the intended user**. If it runs, it can be understood – even if it takes a deep dive through layers of a virtual machine to get there. As one GitHub project noted, if the VM’s code isn’t further protected, a virtualized function can become “trivial to reverse engineer” ([GitHub - aesthetic0001/js-virtualizer: Virtualization-based obfuscation for javascript](https://github.com/aesthetic0001/js-virtualizer#:~:text=need%20to%20protect%20your%20code,class%20is%20obfuscated%20before%20use)) once you grasp the VM. The goal of the reverse engineer is to reach that point where the virtualized opcodes become as intelligible as regular code. With the techniques above and real-world examples as guidance, this is entirely feasible. 

**References:** Refs cited inline include analyses by Willbold【6】, the JS-VMP blog【7】, TikTok VM reversals【11】【13】【14】【15】【16】, and others that showcase these concepts in action.