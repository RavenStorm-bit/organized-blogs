Got it. I’ll look into how reverse engineers defeat VMProtect and similar virtualization-based DRM systems, focusing on tracing, emulation, and replay techniques. I’ll also include an overview of the tools they use (like Qiling, Unicorn, or custom VMP analyzers) and explain how these tools function in the context of cracking or understanding virtualized code.

I’ll get back to you with a detailed breakdown of both the conceptual processes and the tooling landscape.

# Defeating VMProtect Virtualization: Tracing, Emulation, and Replay Techniques

## Introduction to Code Virtualization Protection  
Modern protectors like **VMProtect (VMP)** transform original machine code into a custom *bytecode* that runs on a **virtual CPU** with its own instruction set. This process – known as **code virtualization** – obscures the program’s true logic by replacing normal instructions with pseudo-instructions (opcodes) understood only by the embedded VM interpreter ([Defeating VMProtect's Latest Tricks | cyber.wtf](https://cyber.wtf/2023/02/09/defeating-vmprotects-latest-tricks/#:~:text=A%20colleague%20of%20mine%20recently,out%20what%20is%20going%20on)) ([Unveiling the VMProtect-devirtualization Project: A Review that project | by Gonchik Tsymzhitov | Medium](https://gonchik.medium.com/unveiling-the-vmprotect-devirtualization-project-a-review-that-project-4ecb55796200#:~:text=VMProtect%20is%20widely%20acclaimed%20for,property%20contained%20within%20the%20software)). The protected binary contains a **virtual machine interpreter** that reads and executes these custom bytecode instructions at runtime. Reverse engineering such virtualized code is notoriously difficult, since analysts must decipher an unknown instruction set and a layer of interpretation. According to VMProtect’s own documentation, breaking virtualization essentially requires *“building a disassembler with the same architecture as the processor the virtual machine imitates”* to translate the bytecode back to normal code ([VMProtect Software » VMProtect » Docs](https://vmpsoft.com/vmprotect/user-manual/#:~:text=Virtualization%C2%A0%E2%80%93%20a%20process%20that%20transforms,of%20the%20resulting%20disassembled%20code)). In other words, to defeat VMP one must reconstruct or bypass the virtual CPU’s behavior.

**Why is this so challenging?** Each protected function is translated into a sequence of virtual opcodes that perform the original logic in a roundabout way. The VM uses **custom handlers** to execute each opcode, along with encryption, obfuscation, and anti-debug tricks to thwart analysis. A single simple operation (like an arithmetic add) might turn into dozens of virtual instructions interleaved with junk operations. All of this makes it extremely time-consuming to recover the original algorithm by static analysis alone ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=The%20simplest%20method%2C%20get%20the,and%20a%20lot%20of%20implementation)) ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=X%20)). Reverse engineers have therefore developed dynamic techniques – tracing execution, emulating the code, and recording/replaying runs – to peel back the virtualization layer and automate parts of the devirtualization process.

## The Overall Process of Analyzing Virtualized Code  
Defeating a virtualization-based DRM scheme like VMProtect generally involves several stages. Below is an overview of the typical process reverse engineers follow to analyze and devirtualize protected code:

1. **Locate the Virtualized Code:** First, identify which functions or code regions are virtualized. Signs include unusual section names (e.g. sections named `.vmp0/.vmp1` in the binary), or stubs where a function call enters a large VM dispatcher routine ([Analysis of VMProtect. Packer confirmed for use in… | by Sachiel | Medium](https://sachiel-archangel.medium.com/analysis-of-vmprotect-0b28c8e47ca5#:~:text=Distinctive%20program%20sections)) ([VMProtect trace parser. Abstract | by Sachiel | Medium](https://sachiel-archangel.medium.com/vmprotect-trace-parser-dfdc18152f59#:~:text=When%20analyzing%20a%20packer%20that,refer%20to%20the%20previous%20article)). Analysts use disassemblers to find the VM entry point and the setup of the virtual machine (e.g. VMP’s `VMProtectBegin/End` markers or prologue code that initializes the VM context).
2. **Bypass Anti-Analysis:** VMProtect often employs anti-debug and anti-VM tricks to prevent tracing. Reverse engineers must disable or work around checks for debuggers or VMs (for example, using plugins like ScyllaHide to evade debugger detection ([Defeating VMProtect's Latest Tricks | cyber.wtf](https://cyber.wtf/2023/02/09/defeating-vmprotects-latest-tricks/#:~:text=A%20colleague%20of%20mine%20recently,out%20what%20is%20going%20on)), or even running the code in a controlled VM/hypervisor to avoid triggers ([Defeating VMProtect's Latest Tricks | cyber.wtf](https://cyber.wtf/2023/02/09/defeating-vmprotects-latest-tricks/#:~:text=Kernel%20mode%20tooling%20such%20as,use%20and%20easier%20to%20debug))). This ensures the protected code can execute under observation.
3. **Capture Execution Behavior:** Next, obtain a *trace* of the virtualized code’s execution. This can be done by single-stepping in a debugger, instrumenting the code to log instructions, or emulating the code and hooking each virtual instruction (details in later sections). The goal is to see the sequence of virtual opcodes executed and how the VM handles manipulate the *virtual CPU state*.
4. **Identify VM Components:** Using the trace and disassembly, identify key components of the VM architecture – the **virtual instruction pointer (VIP)**, **virtual stack pointer (VSP)**, the handler dispatch loop, and the **handler table** that maps opcodes to handler functions. This often involves recognizing certain constants or register usage (for example, VMP uses a register like RSI/ESI to hold the VIP and RBP/EBP as VSP ([VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture // Back Engineering Blog](https://blog.back.engineering/17/05/2021/#:~:text=%60VIP%60%20,RSI%20is%20equivalent%20to%20VIP)) ([Unpacking BattleEye - Article 1 | lolblat blog](https://lolblat.github.io/articles/battle-eye-post-1.html#:~:text=After%20filtering%20out%20the%20useless,the%20address%20of%20the%20array))).
5. **Decode and Map Opcodes:** Once the VM’s dispatch mechanism is understood, the analyst decodes each virtual opcode and begins mapping each to its function. This can mean reverse-engineering each handler function to determine what it does (e.g. arithmetic, stack push/pop, conditional jump, API call, etc.). Tracing and emulation greatly assist here by letting the analyst execute handlers in isolation or observe their effect on the virtual state.
6. **Reconstruct Original Logic:** Finally, the sequence of virtual instructions (and their effects) is translated back into equivalent native operations. This can be done manually or with automated *devirtualization* tools that output an IR (Intermediate Representation) or even recompiled assembly. The end result is a recovered implementation of the original code, which can be analyzed or patched without the VM overhead.

Throughout this process, dynamic analysis is invaluable. Because VMProtect uses self-modifying and encrypted bytecode, purely static approaches struggle – many values are decrypted on the fly by the VM. By letting the program run (under close observation), reverse engineers leverage VMP’s own interpreter to decrypt and reveal the bytecode and handlers. The sections below delve into the key techniques of tracing, emulation, and execution replay that make this analysis feasible.

## Tracing and Dynamic Analysis Techniques  
**Instruction tracing** is a dynamic analysis approach where the execution of the program is recorded at the instruction level. For virtualized code, the idea is to trace either the *native instructions* executed (to see the VM interpreter in action) or the *virtual instruction stream* (to see the sequence of opcodes being processed). There are several ways to obtain such traces:

- **Debugger Single-Stepping and Hooks:** One straightforward method is using a debugger (like x64dbg or WinDbg) to step through the VM code. A reverse engineer might set a breakpoint at the start of the VM dispatcher loop (the point where each new virtual opcode is fetched) and then single-step or run to the next iteration repeatedly. This effectively walks through each virtual instruction. Writing debugger scripts or using plugins can automate the process of logging each step (for example, recording the VIP register and relevant data each time) so the entire opcode sequence is captured. Debuggers also allow setting **memory breakpoints** or hooks – e.g. break when the virtual instruction pointer is read or when the handler table is accessed – to intercept each VM instruction execution without manually stepping. This fine-grained tracing, however, can be extremely slow due to the thousands of instructions a VM executes, and it may be thwarted by anti-debug tricks if done in a live environment.

- **Dynamic Binary Instrumentation (DBI):** Tools like Intel PIN or DynamoRIO can instrument an application to automatically log executed instructions or basic blocks. An analyst could write a DBI tool to filter and dump only the instructions executed in the VM code sections (for instance, only log instructions from the `.vmp0` section of the binary). This produces a trace of the native execution of the VM. The challenge is handling the volume of data and distinguishing between the VM’s internal operations and any “real” API calls or other code. But DBI can often be run transparently, avoiding some anti-debug traps, since it doesn’t use a traditional debugging interface.

- **Built-in Tracing in Analysis Tools:** Some advanced debuggers/IDEs (IDA Pro, x64dbg, etc.) have tracing features where you can run the program and have it log executed instructions up to a certain point. For example, IDA’s debugger can produce an execution trace log. In practice, reverse engineers use this to let the program run through the virtualized function while logging, then post-process the log. One real-world case of this was analyzing a VMProtect-packed malware (“PrivateLoader”) by obtaining an execution trace and then filtering out the “noise” instructions to find meaningful actions like API calls ([VMProtect trace parser. Abstract | by Sachiel | Medium](https://sachiel-archangel.medium.com/vmprotect-trace-parser-dfdc18152f59#:~:text=I%20considered%20dynamic%20analysis%20to,The%20Windows%20API)). Because virtualization inserts many garbage or redundant instructions, traces can be “contaminated” with junk that obscures the real logic ([VMProtect trace parser. Abstract | by Sachiel | Medium](https://sachiel-archangel.medium.com/vmprotect-trace-parser-dfdc18152f59#:~:text=unpacker%2C%20it%20would%20be%20better,The%20Windows%20API)). Scripting can help extract the key events (e.g. the moments when a Windows API is actually invoked, hidden among the VM ops).

- **Hardware-Tracing Features:** In some situations, analysts might leverage processor features like Intel Processor Trace (PT) which records execution flow with minimal overhead. This can produce a detailed trace even when debugging is not possible, and it can be used in a live or virtual machine environment. However, interpreting the PT output requires additional tooling to map it back to instructions, and anti-VMProtect measures might detect the unusual environment.

In practice, **tracing is often combined with partial emulation or instrumentation**. For instance, one effective strategy is to run the protected code inside an emulator or instrumented environment that logs each virtual instruction as it executes. A researcher might hook the VM’s *dispatch function* to log the current opcode and relevant operands each time through the loop. By doing so, they obtain the exact sequence of virtual opcodes executed for a given input. This sequence is essentially the *program* in the VM’s bytecode. Once you have the bytecode trace, you can attempt to interpret it (manually or with a custom tool) to recover the original logic. Tracing thus provides the raw data needed for the devirtualization step. As Jonathan Salwan et al. describe, an *“obfuscated trace T' (from the protected code) combines original instructions from the original code (trace T) and instructions of the virtual machine (VM(T)) such that T' = T + VM(T)”* ([GitHub - JonathanSalwan/VMProtect-devirtualization: Playing with the VMProtect software protection. Automatic deobfuscation of pure functions using symbolic execution and LLVM.](https://github.com/JonathanSalwan/VMProtect-devirtualization#:~:text=The%20approach)). The tracer’s job is to collect T', after which analysis can separate the two components.

**Overcoming Anti-Debug:** It’s worth noting that VMProtect’s virtualization is often coupled with many anti-debug checks. Tracing in a live process means the analyst must disable or sidestep these defenses. Tools like **ScyllaHide** (an x64dbg plugin) help by faking or hiding common indicators (PEB flags, NtQueryInformationProcess, etc.) ([Defeating VMProtect's Latest Tricks | cyber.wtf](https://cyber.wtf/2023/02/09/defeating-vmprotects-latest-tricks/#:~:text=advanced%20anti,out%20what%20is%20going%20on)). If user-mode tricks fail, kernel-mode anti-anti-debug like **TitanHide** or hypervisor-based debuggers can be used ([Defeating VMProtect's Latest Tricks | cyber.wtf](https://cyber.wtf/2023/02/09/defeating-vmprotects-latest-tricks/#:~:text=Kernel%20mode%20tooling%20such%20as,use%20and%20easier%20to%20debug)). Another trick is to execute the target in a single-step mode or with interrupts; however, VMP may detect the overhead of tracing (for example, timing checks or special instructions to detect single-step). This cat-and-mouse game often pushes analysts toward using full emulation or record/replay so that the analysis can be done *outside* the original runtime.

In summary, tracing gives a chronological view of what the virtualized code does. It’s the first step to understanding the custom VM: by observing how each opcode is fetched and executed, one can start identifying patterns (e.g. a certain opcode always results in a particular arithmetic operation). Tracing alone doesn’t *solve* the virtualization, but it lays the groundwork by exposing the bytecode and the order of operations, which is essential for later steps.

## Emulation-Based Analysis Approaches  
To sidestep many of the difficulties of live debugging, reverse engineers frequently turn to **emulation**. Emulation involves running the protected code in a simulated CPU or system, where one has complete control and visibility. By emulating the code, one can execute it freely (letting the VM run as intended) while intercepting and inspecting its behavior without many of the risks of anti-debug triggers. There are a few levels of emulation used in defeating VMProtect:

- **Full-System Emulation (QEMU/PANDA):** One option is to run the entire program in a whole-system emulator like QEMU. The protected binary is executed inside a virtual OS, and tools such as **PANDA** (Platform for Architecture-Neutral Dynamic Analysis) build on QEMU to allow introspection. PANDA can run the program and *record* its execution, then replay it deterministically with various analysis plugins ([PANDA.re ](https://panda.re/#:~:text=PANDA%20is%20an%20open,or%20even%20a%20Jupyter%20notebook)) ([PANDA.re ](https://panda.re/#:~:text=Whole)). Using PANDA or QEMU, an analyst can capture the execution of the VMProtect code, then analyze the trace or apply taint analysis to see how data flows through the virtual machine. The advantage is that the protected code believes it’s running normally on a real system, so it will decrypt and execute its bytecode as usual. Meanwhile, the analyst can extract the bytecode or even the decrypted handler code from the emulator’s memory. Full-system emulators can simulate hardware and OS responses, so even sophisticated anti-VM checks can sometimes be neutralized or patched out (for example, faking CPUID results to hide the emulator ([Defeating VMProtect's Latest Tricks | cyber.wtf](https://cyber.wtf/2023/02/09/defeating-vmprotects-latest-tricks/#:~:text=match%20at%20L158%20The%20first,any%20hypervisor%20information%20from%20cpuid))). The downside is performance – emulation is slower than native execution, especially with instrumentation, and setting up a whole OS environment for analysis can be complex. Nevertheless, record-and-replay frameworks like PANDA make it feasible to do heavy analyses (like multi-path exploration or taint tracking) on a captured execution without the target running live ([PANDA.re ](https://panda.re/#:~:text=PANDA%20is%20an%20open,or%20even%20a%20Jupyter%20notebook)) ([PANDA.re ](https://panda.re/#:~:text=Whole)).

- **User-Mode CPU Emulation (Unicorn Engine):** Often, reverse engineers extract only the portion of code they care about – for instance, the VMProtect virtual machine code and its data – and emulate just that in a lightweight CPU emulator. The **Unicorn Engine** is a popular open-source emulator for this purpose. Unicorn is a CPU emulator framework (based on QEMU) that can emulate many architectures at instruction level, with Python and C/C++ bindings for scripting ([Emulating Code with Unicorn](https://www.trellix.com/assets/docs/atr-library/tr-emulating-code-with-unicorn.pdf#:~:text=if%20there%20was%20something%20that,a%20ride%20with%20this%20powerful)). An analyst can load the binary code for the VM handlers and bytecode into Unicorn, set up the CPU registers to an initial state, and then let it run the virtualized function entirely under emulation. During this, one can hook memory accesses, API calls, or specific addresses. For example, you can hook every RET instruction or the VM’s dispatcher to log info, or hook memory reads from the bytecode stream to see each opcode. Unicorn does not emulate a full OS by itself – it executes code, and for any system calls or external API calls, the user must handle those (either by hooking and faking a return value, or by providing an implementation). In the context of VMP, many virtualized routines are self-contained computations (e.g. algorithmic calculations or license checks), so they might not call OS APIs at all, making them ideal to run in Unicorn. By observing the state changes in Unicorn (registers, memory) after each virtual instruction, the reverse engineer can deduce what that instruction is doing. Emulation also safely executes any self-modifying code or decryption – since Unicorn will faithfully execute those instructions, it will decrypt the bytecode or handlers on the fly just like a real CPU, revealing the hidden logic without the analyst needing to manually decrypt it.

- **Process Emulation Frameworks (Qiling):** While Unicorn handles CPU emulation, frameworks like **Qiling** wrap Unicorn to provide higher-level facilities like loading a PE/ELF binary, handling imports, and simulating OS behavior (file system, libraries, etc.). Qiling can be pointed at a Windows binary and it will map the sections in memory, resolve imports (with either dummy stubs or user-provided handlers), and let you emulate from the entry point or any address. Reverse engineers have used Qiling to create custom “debuggers” for VMP-protected code. For instance, one researcher built a tracer on Qiling that emulates the program’s code and uses pattern matching to identify virtual instructions as they execute ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=As%20I%20don%E2%80%99t%20want%20to,without%20handling%20each%20control%20flow)). Because Qiling/Unicorn executes instructions directly, it naturally bypasses the **rolling key decryption** and other runtime obfuscations – by the time an instruction executes in the emulator, it’s in its decrypted form in registers. The tracer mentioned skipped the decryption routines and logged the already-decrypted operands of each VMP opcode ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=just%20a%20simple%20math%20operation,second%20is%20an%20if%20statement)). This kind of approach provides a clean view of the virtual instruction sequence. The limitation of Qiling is that not all OS behaviors are emulated; one may need to implement certain API behaviors or provide expected data (as noted, Qiling doesn’t automatically handle every Windows API) ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=,get%20a%20lifted%20simplified%20output)) ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=,VMProtectTest)). Nonetheless, for contained algorithms, this is manageable.

- **Dump and Emulate (Dumpulator):** Another powerful technique is to take a *snapshot* of the program at a certain point and emulate from there. **Dumpulator** is a tool that allows loading a process memory dump into an emulator and continuing execution ([GitHub - mrexodia/dumpulator: An easy-to-use library for emulating memory dumps. Useful for malware analysis (config extraction, unpacking) and dynamic analysis in general (sandboxing).](https://github.com/mrexodia/dumpulator#:~:text=An%20easy,links%20to%20posts%2Fvideos%20using%20dumpulator)). The workflow might be: run the protected program until just before the virtualized function executes (possibly bypassing the unpacking and anti-debug setup), dump the process, then use Dumpulator to emulate the rest of the function offline. This way, all the necessary code (the VM, the decrypted bytecode, etc.) is present in the dump, and the emulator can execute it without the original environment. Because Dumpulator is built on Unicorn, it inherits the ability to step through code and introspect memory. Analysts can set breakpoints on VM handler addresses in Dumpulator or instrument it to log each instruction. The big advantage is **repeatability**: you can run the same snippet as many times as needed, try different inputs, and not worry about the target process terminating or self-destructing because you’re working on a static snapshot. For malware or license checks that only run once, this is extremely useful.

In all these cases, emulation provides **freedom from anti-debug and timing issues**. The code thinks it’s running normally, so it will reveal the decrypted bytecode, execute all the junk and real instructions, and follow the virtual control flow. The reverse engineer can then capture the behavior. Emulation can also speed up analysis – e.g. you might run the emulator *without* logging to quickly get through initialization, then enable logging for the VM instructions only. Some have even partially automated devirtualization by running the emulator and automatically translating each encountered virtual instruction into a higher-level representation on the fly ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=As%20I%20don%E2%80%99t%20want%20to,without%20handling%20each%20control%20flow)). While writing a full emulator for a custom VM is complex, leveraging existing engines like Unicorn means you only need to script the parts specific to the target (setting up memory, hooking events of interest).

## Execution Recording and Replay  
**Execution replay** techniques are closely related to emulation and tracing, and they form a powerful strategy for dealing with virtualized code. The core idea is to **record a program’s execution once**, and then be able to **replay it deterministically** as many times as needed, possibly with different analyses or instrumentation each time. This is extremely useful for VMProtect, because one clean run of the protected code (with the correct inputs) can be captured and then analyzed deeply without having to fight the protector’s defenses on each attempt.

One way to do this, as mentioned, is via PANDA/QEMU’s record-and-replay. Using PANDA, an analyst can run the VMProtect-protected program in the emulator and enable recording at the start of the virtualized function. The entire CPU state and memory interactions during that function’s execution will be logged. Later, the analyst can replay this execution **offline** — the code re-executes exactly as it did originally, but now one can attach various PANDA plugins or analysis scripts. For example, on the replay one could attach an instruction trace logger (to get the full trace without the overhead of logging during the original run), or a taint analysis engine to see how certain input bytes propagate through the virtual machine ([PANDA.re ](https://panda.re/#:~:text=Taint%20Engine)). Because the replay is deterministic, one can experiment with different analysis strategies on the same execution. This ensures any anti-debug or anti-tamper logic (which ran during the original execution) is already bypassed by virtue of using the recording; the replay won’t trigger those again because it’s not running the original code live, just iterating through the pre-recorded state transitions.

Another interpretation of “replay” in the context of devirtualization is **execution path replay on a custom simulator**. In research by Salwan et al., after obtaining a trace of the VM execution (the sequence of mixed VM instructions and underlying native operations), they **replay that trace in a symbolic execution engine** ([GitHub - JonathanSalwan/VMProtect-devirtualization: Playing with the VMProtect software protection. Automatic deobfuscation of pure functions using symbolic execution and LLVM.](https://github.com/JonathanSalwan/VMProtect-devirtualization#:~:text=1,unprotected%20version%20of%20the%20target)). Essentially, they feed the recorded instructions one by one into a symbolic emulator (like Triton or an LLVM-based simulator) which computes the effect on symbolic inputs. Because they control the replay, they can instrument it to *“distinguish between two subsequences of instructions: the VM’s internal operations versus the original program logic”* ([GitHub - JonathanSalwan/VMProtect-devirtualization: Playing with the VMProtect software protection. Automatic deobfuscation of pure functions using symbolic execution and LLVM.](https://github.com/JonathanSalwan/VMProtect-devirtualization#:~:text=The%20approach)). By doing so, they filter out the effects of the VM overhead and derive a simplified formula or IR that represents what the original code did. This is a form of **offline deobfuscation**: the heavy lifting of running the code was done once (either on a real CPU or an emulator), and the replay is used to *compute* the semantics of that execution in a clearer form. The output might be, for example, an LLVM IR or a simplified set of expressions for the original function’s behavior.

In practical terms, tools like **PANDA** provide built-in replay capabilities ([PANDA.re ](https://panda.re/#:~:text=PANDA%20is%20an%20open,or%20even%20a%20Jupyter%20notebook)) ([PANDA.re ](https://panda.re/#:~:text=Whole)). For instance, an analyst could record an execution where a certain input is provided to the protected function (say, a license check with a sample key). Then offline, they replay and examine memory and register states to find where the key is validated. If the function has multiple paths (like different branches for “license valid” vs “invalid”), one could record each path separately by running the program with different inputs, then compare the replays. This helps map out the virtualized control flow. Execution replay ensures that even if the protected code self-terminates or modifies itself, the captured trace preserves what occurred, allowing detailed inspection frame-by-frame.

One must capture the trace correctly — for example, starting the recording after any anti-debug initialization to avoid huge logs or irrelevant setup code. But once you have it, replay can be run under an interactive debugger too. Some reverse engineers convert recorded traces into formats that can be loaded into tools like IDA as “execution traces,” to visualize which addresses were hit. Others feed traces into custom scripts (like Python with Unicorn) to literally re-run the instructions and dump intermediate values.

In summary, **record & replay** provides a safety net: you only brave the protector’s active defenses once during recording, and thereafter all analysis is done in a controlled environment. This technique is especially powerful combined with emulation and symbolic analysis, as it bridges the gap between dynamic and static analysis — you get the dynamic runtime info, then you can perform static-like reasoning on the replay without the obfuscation layers interfering further.

## Inside VMProtect’s Virtual Machine  
Understanding how VMProtect’s custom virtual machine is implemented is key to defeating it. VMProtect (particularly VMP v2.x and v3.x) uses a **register-based** or **stack-based VM** (depending on version) with a fixed set of opcodes. The protected code is translated into a **virtual instruction stream** (bytecode), and at runtime a VM dispatcher interprets this stream. Reverse engineers targeting VMP will seek to recover the details of this virtual CPU: what registers it uses, how it encodes instructions, and how the handlers work.

 ([VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture // Back Engineering Blog](https://blog.back.engineering/17/05/2021/)) *Figure: Structure of a VMProtect virtual instruction, consisting of a one-byte opcode and an optional immediate operand of up to 8 bytes ([VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture // Back Engineering Blog](https://blog.back.engineering/17/05/2021/#:~:text=Virtual%20instructions%20consist%20of%20two,to%20eight%20byte%20immediate%20value)).*  

A **virtual instruction** in VMProtect typically consists of an **opcode** (1 byte) followed by zero or more bytes of immediate data. The opcode is essentially an index that selects a handler from the VM’s handler table, and the immediate operand (if present) could be a value to push, an offset for a jump, etc. Each protected binary randomizes and encrypts its opcodes, but the overall structure remains: one byte = one virtual opcode ([VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture // Back Engineering Blog](https://blog.back.engineering/17/05/2021/#:~:text=Virtual%20instructions%20consist%20of%20two,to%20eight%20byte%20immediate%20value)). Reverse engineers confirm this by observing the VM’s behavior: for example, the code that fetches an opcode will read a byte from the bytecode stream (pointed to by the VIP register) ([VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture // Back Engineering Blog](https://blog.back.engineering/17/05/2021/#:~:text=an%20encrypted%20index%20into%20the,RBX%20is%20the%20RVA%20to)). In a 32-bit VMP, common register usage is: ESI as the VIP (address of next bytecode), EBP as the VSP (base of the VM’s value stack), EDI as a pointer to a VM register context (if using virtual registers), and EBX often holding a *rolling key* for decoding ([Unpacking BattleEye - Article 1 | lolblat blog](https://lolblat.github.io/articles/battle-eye-post-1.html#:~:text=After%20filtering%20out%20the%20useless,the%20address%20of%20the%20array)). In 64-bit VMP2, RSI is VIP and RBP is VSP, with a similar concept ([VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture // Back Engineering Blog](https://blog.back.engineering/17/05/2021/#:~:text=%60VIP%60%20,RSI%20is%20equivalent%20to%20VIP)).

**VM Initialization:** When a VMProtected function is entered, there’s an **init routine** (often called `vm_entry`) that sets up the virtual CPU. It may push the real CPU state to a stack (to save it), allocate or assign memory for the virtual stack, load the initial VIP (which might be an encrypted pointer passed as an argument), and initialize the decryption key ([Unpacking BattleEye - Article 1 | lolblat blog](https://lolblat.github.io/articles/battle-eye-post-1.html#:~:text=Step%201%3A%20initialize%20the%20VM%2C,also%20creating%20the%20encryption%20key)). For example, the BattleEye case study found that the VM set EBX = some key, ESI = start of bytecode, created a register array at EDI, and prepared EBP as stack base ([Unpacking BattleEye - Article 1 | lolblat blog](https://lolblat.github.io/articles/battle-eye-post-1.html#:~:text=After%20filtering%20out%20the%20useless,the%20address%20of%20the%20array)) ([Unpacking BattleEye - Article 1 | lolblat blog](https://lolblat.github.io/articles/battle-eye-post-1.html#:~:text=Step%201%3A%20initialize%20the%20VM%2C,also%20creating%20the%20encryption%20key)). Identifying this setup is usually the first big clue – it tells the reverser where the bytecode lives in memory and what the initial key is for decoding opcodes.

**Fetch-Decode-Execute Loop:** After initialization, the VM enters a loop to execute virtual instructions. In pseudocode, this looks roughly like:  

```
while (true):
    opcode = *VIP;            // fetch byte
    VIP += 1;
    decoded = decode(opcode, key);
    key   = update_key(key, decoded);
    handler_addr = HandlerTable[decoded];
    call handler_addr;
```

Each iteration fetches the next byte of bytecode, decodes it, updates the key, and dispatches to the corresponding handler. In reality, VMProtect implements this with optimized assembly and obfuscation: it might not literally use a `switch` statement or direct array indexing; instead it may use a series of transformations on the opcode and then a computed jump (or even push-ret to jump to handler) ([Unpacking BattleEye - Article 1 | lolblat blog](https://lolblat.github.io/articles/battle-eye-post-1.html#:~:text=Step%202%3A%20where%20we%20are,by%20returning%20into%20the%20handler)). Still, reverse engineers have observed a consistent pattern in VMP’s loop. Notably, **opcode values are stored encrypted** and must be run through a decoding step involving a rolling key. One analysis describes: *“We get the opcode (1 byte) from the VIP, increment VIP, XOR the opcode with an encryption key, perform some arithmetic operations on it, then XOR the key with the decoded opcode (rolling the key). Then we fetch the handler address from a table and dispatch by returning into the handler.”* ([Unpacking BattleEye - Article 1 | lolblat blog](https://lolblat.github.io/articles/battle-eye-post-1.html#:~:text=Step%202%3A%20where%20we%20are,by%20returning%20into%20the%20handler)). This aligns with many VMP variants: a XOR-based rolling key and some additional transforms (add, sub, rotate, etc.) for obfuscation.

 ([VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture // Back Engineering Blog](https://blog.back.engineering/17/05/2021/)) *Figure: VMProtect operand decryption uses a rolling key and a fixed sequence of transformations (e.g. XOR, NEG, ROL, INC) to decode each opcode or immediate. After decrypting an operand, the key is updated with that operand’s value ([VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture // Back Engineering Blog](https://blog.back.engineering/17/05/2021/#:~:text=VMProtect%202%20encrypts%20its%20virtual,hold%20the%20decrypted%20operand%20value)) ([VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture // Back Engineering Blog](https://blog.back.engineering/17/05/2021/#:~:text=,al%20%3B%20update%20rolling%20key)).*  

**Rolling Key and Opcode Encryption:** The use of a changing key means that the byte values of opcodes in the binary are not fixed; they decrypt differently depending on the key’s state. The key is typically updated after each opcode (often by a simple operation involving the decoded opcode). For example, in VMP2, the first transform applied to the opcode involves RBX (the rolling key register) ([VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture // Back Engineering Blog](https://blog.back.engineering/17/05/2021/#:~:text=match%20at%20L697%20an%20encrypted,RBX%20is%20the%20RVA%20to)). An example from a VMP2 analysis shows: `xor al, bl` (XOR opcode with key), then a series of three transformations (neg, rol, inc on the opcode byte), then `xor bl, al` (update key by XORing with decoded opcode) ([VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture // Back Engineering Blog](https://blog.back.engineering/17/05/2021/#:~:text=,al%20%3B%20update%20rolling%20key)). The figure above illustrates this: one operation mixing in the rolling key, three generic transformations, then updating the key. Because of this design, **the opcode values appear dynamic** – you can’t just look at the bytecode bytes on disk and know the instruction; you must run the decryption logic or emulate it. Reverse engineers often extract this portion of code (`calc_jmp` in some write-ups) and either emulate it or rewrite it in Python to decrypt the bytecode stream offline. In fact, once the algorithm is known (XOR with key, some rotates, etc.), one can dump the raw bytecode from memory and apply the same transformations to recover the sequence of opcode indices used at runtime.

**Handler Table:** VMProtect uses a table of pointers (or offsets) to handler functions. In many versions, this is a table of 256 entries (since opcodes are 1 byte) ([VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture // Back Engineering Blog](https://blog.back.engineering/17/05/2021/#:~:text=match%20at%20L876%20VMProtect%202,This%20section%20will)) ([VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture // Back Engineering Blog](https://blog.back.engineering/17/05/2021/#:~:text=VM%20handlers%20contain%20the%20native,This%20section%20will)). Each entry in the table is itself stored encrypted (often XORed with a constant or encoded with a single transformation) and gets decrypted on the fly before jumping. In VMP2 x64, for example, R12 register is loaded with the base of this handler table during VM init ([VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture // Back Engineering Blog](https://blog.back.engineering/17/05/2021/#:~:text=The%20next%20notable%20operation%20is,the%20vm%20handler%20table%20quite)). Every VMProtect-protected binary will have this table in its data section (or embedded in the code section), and identifying it is crucial: it effectively maps **virtual opcode -> native handler address**. A common reverse-engineering approach is to locate this table by searching for suspicious large constants or the code pattern that loads the table base. The back.engineering analysis notes *“R12 always contains the address of the VM handler table… a signature which can be used to find the table location”* ([VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture // Back Engineering Blog](https://blog.back.engineering/17/05/2021/#:~:text=The%20next%20notable%20operation%20is,the%20vm%20handler%20table%20quite)). Once you have the table, you can try decrypting all 256 entries to get a list of addresses for handlers. Not all may be used, but if you can decrypt them, you can label these addresses in a disassembler, greatly aiding analysis of each handler.

**VM Handler Functions:** A **handler** is a native code routine that implements the effect of a particular virtual instruction. Handlers typically do things like: load or store a value on the virtual stack, perform arithmetic (add, xor, mul) on values in the virtual registers/stack, handle jumps or calls (modify VIP or call real functions), etc. Reverse engineers study handlers to map them to semantics. For example, a handler that pops two values from the VMP stack and adds them, then pushes the result (and maybe flags) back, is clearly an ADD operation. Another handler might move data between virtual registers, or push an immediate value. Handlers can range from very simple (one or two native instructions) to quite complex (implementing something like a loop or a call that interacts with real API). In VMProtect, handlers are often heavily obfuscated with dead code and arithmetic obscurity (mixed boolean arithmetic transformations) to make them hard to understand at first glance ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=So%20how%20could%20we%20crack,bit%20about%20the%20%E2%80%98Devirtualization%E2%80%99%20approach)) ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=dynamically,the%20deobfuscations%20in%20LLVM%20IR)). However, since each handler is a relatively small routine, analysts can use both static and dynamic analysis: disassemble the handler to see its structure, and run it in an emulator or with specific inputs to observe its effect.

A typical process is: identify a handler (say at address X), set a breakpoint on X in a debugger or emulator and see when it’s hit. When hit, look at the virtual stack or registers (which might be stored in some known memory location or register context) before and after execution. This tells you what the handler consumed and produced. Doing this for each unique opcode eventually lets you build a map of opcode -> operation. 

**Virtual Registers and Stack:** VMP’s VM often has a set of virtual registers. In some versions, it’s a pure stack machine (all operations use a stack for operands); in others, it has general-purpose virtual registers as well. The analysis of BattleEye’s VMP instance indicated an array of 16 virtual registers located via the EDI register ([Unpacking BattleEye - Article 1 | lolblat blog](https://lolblat.github.io/articles/battle-eye-post-1.html#:~:text=After%20filtering%20out%20the%20useless,the%20address%20of%20the%20array)). Those were likely used in handlers for things like moving values or performing calculations without constantly pushing/popping. Knowing how these are laid out (e.g. EDI points to an array on the real stack, EBX+index or EDI+index is used in handlers) helps interpret handler logic. For example, if a handler writes to [EDI+0x4], it might be setting virtual register 1 to some value (depending on how the array is structured). Similarly, the virtual stack in VMP2 is at RBP; push/pop handlers will do real memory writes/reads at [RBP + offset]. Recognizing these memory access patterns is key to understanding what each handler does. A load immediate handler might directly write a constant into [RBP + some offset], whereas an arithmetic handler might read two values from [RBP + offsets], operate, then write one back.

**Control Flow in the VM:** Special handlers manage virtual jumps, calls, and returns. For instance, a virtual CALL might push the current VIP (so that a VRET can return to it later), then set VIP to a new address (effectively jumping to a new bytecode location). These are among the trickier parts because VMProtect will use them to implement *opaque control flow* – the bytecode could jump around in ways that don’t directly correlate to the original program’s flow, making it hard to follow without fully simulating the VM. However, by identifying the jump handlers and tracking the values placed into VIP, a reverse engineer can reconstruct the bytecode control flow graph. In fact, some automated tools focus on extracting the **VM bytecode** and then disassembling *that* into a higher-level representation, essentially treating the bytecode as if it were assembly in a weird architecture. This can involve writing a custom disassembler for the VMP bytecode or using an IL like **VTIL** (Virtual Machine Translation Intermediate Language) as done in the NoVmp project ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=dynamically,the%20deobfuscations%20in%20LLVM%20IR)) ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=Jut%20to%20mention%20it%2C%20Fvrmatteo,here)).

In summary, the custom VM of VMProtect introduces its own “architecture” that must be reverse-engineered. Analysts look for: the **VIP register**, the **VSP (stack base)**, any **virtual register context**, the **handler dispatch mechanism** (often a calculated jump through a table), the **opcode decoding logic** (rolling key and transforms), and the **handler table**. With those identified, the task reduces to analyzing a finite set of handler functions. It’s a painstaking process, but each handler you figure out is one puzzle piece of the original program’s functionality.

## Mapping Virtual Instructions to Native Logic (Devirtualization)  
Once the VM architecture is understood and the handlers are identified, the ultimate goal is to **recover the original code’s logic**. This process of translating the virtual instructions back to an understandable form is often called *devirtualization*. Reverse engineers use a combination of pattern recognition, data flow analysis, and even compiler-like techniques to accomplish this. Here’s how they map virtual instructions to the original code:

- **Manual Analysis and Pattern Matching:** In simpler cases, a reverse engineer can manually correlate a sequence of virtual instructions to what the original code did. For example, after analyzing handlers, one might label them: opcode 0x5A = “VADD (virtual add)”, 0x5B = “VSUB”, 0x10 = “PUSH const”, etc. Then by looking at the recorded opcode trace (from dynamic tracing), the analyst can hand-simulate or write a quick script to apply each known instruction to a simulated stack, thereby reconstructing the computation. This is essentially writing a mini-interpreter for the bytecode once you know what each opcode means. In fact, early methods to crack simpler VMs involved pattern matching the handler code against known templates (like recognizing an ADD handler because it has an ADD instruction against two stack values). This “less proper way” yields results, but for VMProtect’s obfuscated handlers, the directly recovered code can be very messy ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=The%20simplest%20method%2C%20get%20the,and%20a%20lot%20of%20implementation)). Each handler might include junk and do things in a convoluted way that doesn’t directly translate to clean high-level code. So while you *could* dump a sequence of equivalent x86 instructions for each opcode (effectively inlining each handler’s logic), the result is usually bloated and hard to read (though functionally correct).

- **Lifting to an Intermediate Representation (IR):** A more advanced approach is to translate the virtual bytecode execution into an IR such as LLVM IR, VTIL, or even a custom IL. Projects like **NoVmp** (for VMP 3.x x64) do exactly this: they take the handlers and produce an optimized intermediate representation of the logic ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=dynamically,the%20deobfuscations%20in%20LLVM%20IR)) ([can1357/NoVmp: A static devirtualizer for VMProtect x64 3 ... - GitHub](https://github.com/can1357/NoVmp#:~:text=GitHub%20github,machine)). By using an IR, one can then apply **optimization passes** to simplify the logic – for example, remove stack stores that are immediately loaded (because in the VM everything might go to the stack), perform constant folding on the arithmetic junk, and eliminate dead code. As R0da notes, *“the code [output] will be horrible due to the MBA and register swapping, so the most effective choice is to convert it to a compiler IR… From here you can do optimization passes to remove junk code, MBA, and other obfuscations”* ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=The%20simplest%20method%2C%20get%20the,and%20a%20lot%20of%20implementation)). After simplification, the IR can even be recompiled back to readable assembly or decompiled to C. This approach treats the VM’s effect as a form of high-level code and leverages compiler technology to clean it up. Notably, researchers have developed LLVM passes specifically to simplify VMProtect-obfuscated IR ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=Jut%20to%20mention%20it%2C%20Fvrmatteo,here)) (e.g. removing mixed boolean arithmetic sequences that are inserted as obfuscation).

- **Dynamic Taint & Symbolic Execution:** Another powerful technique is to use **dynamic taint analysis (DTA)** or **symbolic execution** during the execution of the VM code to directly infer the relationship between inputs and outputs, bypassing the need to map each opcode manually ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=IX.2%20,DTA%20%26%20Symbolic%20execution)). In this approach, one marks the important inputs (say the function’s parameters or a user input) as symbolic or tainted, then runs the virtualized code either concretely or symbolically. As the VM executes, a symbolic execution engine (like Triton or Angr) accumulates symbolic expressions that represent the output in terms of the input. All the VM’s internal computations (the junk and shuffles) will be part of these expressions, but after the function completes, you can attempt to simplify the final expressions for the outputs. The assumption is that a lot of the VM’s work will simplify out, revealing an expression equivalent to the original algorithm. For instance, if the original function was `return x ^ y`, a symbolic execution of the virtualized version should yield something that simplifies to `x ^ y` (possibly after applying SMT solvers or simplification libraries to remove the extra XORs and ADDs introduced by virtualization). Jonathan Salwan’s work demonstrated this: by replaying a trace and constructing symbolic expressions, they were able to optimize and reduce them to essentially the original code’s logic ([GitHub - JonathanSalwan/VMProtect-devirtualization: Playing with the VMProtect software protection. Automatic deobfuscation of pure functions using symbolic execution and LLVM.](https://github.com/JonathanSalwan/VMProtect-devirtualization#:~:text=1,unprotected%20version%20of%20the%20target)). In one case, the team lifted the simplified expressions to LLVM IR and even recompiled a new “devirtualized” function that produced the same outputs ([GitHub - JonathanSalwan/VMProtect-devirtualization: Playing with the VMProtect software protection. Automatic deobfuscation of pure functions using symbolic execution and LLVM.](https://github.com/JonathanSalwan/VMProtect-devirtualization#:~:text=1,unprotected%20version%20of%20the%20target)).

- **Automated Tools and Scripts:** Many tools exist (often not publicly, but some open-source) that assist in devirtualization. For example, Salwan’s **VMProtect-devirtualization** project is a dynamic approach that takes a trace, uses symbolic execution to get an IR, and then applies optimizations to remove the VM overhead ([GitHub - JonathanSalwan/VMProtect-devirtualization: Playing with the VMProtect software protection. Automatic deobfuscation of pure functions using symbolic execution and LLVM.](https://github.com/JonathanSalwan/VMProtect-devirtualization#:~:text=The%20approach)) ([GitHub - JonathanSalwan/VMProtect-devirtualization: Playing with the VMProtect software protection. Automatic deobfuscation of pure functions using symbolic execution and LLVM.](https://github.com/JonathanSalwan/VMProtect-devirtualization#:~:text=1,unprotected%20version%20of%20the%20target)). There’s also been academic work (e.g., *“Symbolic Deobfuscation: From Virtualized Code back to the Original”* ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=define%20what%20the%20VM%20does,code%20back%20to%20the%20original))) that formalizes using SMT solvers to reverse engineer virtualized code. On the more pragmatic side, community tools like **VTIL** (Virtualization Translation IL) have been created to facilitate writing your own devirtualizers. VTIL provides a common IL to lift custom VM bytecode and perform analyses. The NoVmp tool uses VTIL and is capable of handling VMP 3.x bytecode, producing devirtualized output that can be assembled back to x64 machine code ([can1357/NoVmp: A static devirtualizer for VMProtect x64 3 ... - GitHub](https://github.com/can1357/NoVmp#:~:text=GitHub%20github,machine)). Using such a tool, one can automate much of the tedious work: feed in the binary, identify the VM structures (possibly with some manual hints), and let it spit out a devirtualized function.

- **Validation and Iteration:** Regardless of method, a crucial step is verifying that the reconstructed logic is correct. Analysts often run tests – for instance, provide the same inputs to both the original virtualized function (executed normally or in an emulator) and the devirtualized version, and compare outputs. If they match for a variety of cases, confidence is high that the devirtualization is successful. This testing can also help identify if certain opcodes were misunderstood. If there’s a discrepancy, one can go back and examine that part of the bytecode trace, see which handler was involved, and correct the interpretation.

To illustrate these concepts, consider a **simple case study**: Suppose a protected function calculates a checksum on an input buffer. Under VMProtect, you trace and find a loop implemented in bytecode. By analyzing handlers, you realize there’s a virtual register that holds the running checksum, and an opcode that adds each byte. Once you map those out, you can reconstruct that loop in pseudo-code or IR. If the VM had inserted bogus operations (like adding 0 then subtracting 0, or XORing and then XORing back), an optimization pass or a keen eye will recognize those cancel out. The end result you derive is a clean loop summing bytes – which you recognize as the checksum algorithm.

The **key point** is that mapping virtual instructions to native logic is like translating from one language to another. You first build a “dictionary” of the VM’s opcodes (by reverse-engineering handlers), then translate the sequence (with attention to control flow and data flow) into the native language of x86 or C. Techniques like symbolic execution effectively do this translation at the semantic level, saving the analyst from handling every obscure transformation. Other techniques like IR lifting use the structured approach of a compiler to simplify the translated code. Often the final devirtualized output is not 100% identical to the original source (variable names are gone, some control flow may be flattened, etc.), but it is equivalent in functionality and far easier to analyze than the raw virtualized blob.

## Tools and Frameworks for Defeating VMProtect  
Reverse engineers have a suite of specialized tools to assist with tracing, emulation, and analysis of VMProtect-protected binaries. The table below summarizes some well-known tools and how they contribute to this process:

| **Tool / Framework**     | **Purpose & Technique**                                             | **Usage in VMP Analysis**                                    |
|--------------------------|---------------------------------------------------------------------|--------------------------------------------------------------|
| **x64dbg** (with plugins) | User-mode debugger for Windows with scripting and plugin support.   | Used to step through VMProtect code, set breakpoints on handlers, and dump traces. Plugins like **ScyllaHide** help bypass anti-debugger checks ([Defeating VMProtect's Latest Tricks | cyber.wtf](https://cyber.wtf/2023/02/09/defeating-vmprotects-latest-tricks/#:~:text=advanced%20anti,out%20what%20is%20going%20on)). Can script repetitive tasks (like logging registers each loop) to automate tracing. |
| **Unicorn Engine**       | CPU emulator framework (multi-arch) for emulating code at instruction level ([Emulating Code with Unicorn](https://www.trellix.com/assets/docs/atr-library/tr-emulating-code-with-unicorn.pdf#:~:text=if%20there%20was%20something%20that,a%20ride%20with%20this%20powerful)). | Enables writing Python/C scripts to emulate the VM’s code. Reverse engineers use Unicorn to execute VM handler code in isolation or run entire functions in a controlled way. Hooks allow logging each instruction or memory access. No OS overhead – ideal for focusing on the VM logic itself. |
| **Qiling**               | Emulation framework built on Unicorn, simulating OS environments.    | Simplifies loading a Windows binary into an emulator. Provides abstractions for memory, threads, and can intercept API calls. In VMP analysis, Qiling is used to emulate the protected function as if in a debugger, but without actual execution. For example, building a custom tracer that runs the VM loop and identifies opcodes dynamically ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=As%20I%20don%E2%80%99t%20want%20to,without%20handling%20each%20control%20flow)). |
| **Dumpulator**           | Emulator for process **memory dumps** (based on Unicorn) ([GitHub - mrexodia/dumpulator: An easy-to-use library for emulating memory dumps. Useful for malware analysis (config extraction, unpacking) and dynamic analysis in general (sandboxing).](https://github.com/mrexodia/dumpulator#:~:text=An%20easy,links%20to%20posts%2Fvideos%20using%20dumpulator)).  | Allows snapshot emulation. Analysts dump the process once the VM is initialized (with bytecode decrypted in memory) and then use Dumpulator to continue execution. This avoids runtime anti-debug issues. Useful for automating execution of the VM code and extracting decrypted handlers or bytecode. |
| **PANDA** (QEMU)         | Whole-system emulation platform with **record & replay** ([PANDA.re ](https://panda.re/#:~:text=PANDA%20is%20an%20open,or%20even%20a%20Jupyter%20notebook)) and plugin architecture. | Used to run the protected binary in a sandboxed VM and record its execution. On replay, plugins can trace instructions, do taint analysis, or monitor API calls. PANDA’s record/replay ensures consistent results and allows heavy analysis (like checking every memory access or generating an entire execution trace) without disturbing the original run. |
| **Triton** & **Symbion** | Dynamic binary symbolic execution framework (Triton) with the ability to take over concrete execution (Symbion). | Applied in advanced workflows to symbolically execute the VM code after capturing a concrete trace. For instance, after recording a path, use Triton to symbolize inputs and regenerate the path’s expressions, then simplify. Salwan’s project leverages Triton under the hood for symbolic simplification of VMP bytecode logic. |
| **VTIL** (Virtual-machine Translation IL) and **NoVmp** | A custom IL and toolset for lifting obfuscated code, with a focus on virtualized code (NoVmp is a devirtualizer for VMP 3.x using VTIL). | These are used for static devirtualization. One can feed the discovered handler implementations and bytecode into VTIL, which then provides optimization passes to remove obfuscation and output clean high-level code or reassemble to machine code. NoVmp automates much of VMP 3.x devirtualization into a working x64 binary ([can1357/NoVmp: A static devirtualizer for VMProtect x64 3 ... - GitHub](https://github.com/can1357/NoVmp#:~:text=GitHub%20github,machine)), demonstrating the power of this approach. |
| **IDA Pro / Binary Ninja (with scripts)** | Disassemblers that can be scripted (via IDC, IDAPython, or Binary Ninja’s API) for custom analysis. | Analysts write scripts to identify the handler table, mark handler functions, and even emulate the opcode decryption. IDA’s debugger can be used to trace, and its decompiler can assist in reading handler logic once the handlers are identified and cleaned up. These tools aren’t specialized for virtualization, but their scripting makes them indispensable for custom tasks (e.g., automatically rename handlers as you identify them, or dump out bytes from the virtual bytecode buffer). |
| **Frida** and **DynInstr** tools (e.g., Intel PIN) | Dynamic instrumentation and API hooking tools. | Frida can be used to hook sensitive API calls or even patch the code at runtime (for example, to skip anti-debug checks). Intel PIN or DynamoRIO can instrument at the instruction level to log execution without a debugger. While not specifically made for VMP, they can be leveraged to collect execution data in difficult scenarios (like attach to process after unpacking and log addresses of interest). |

*Table: Tools and frameworks commonly used to analyze or devirtualize VMProtect-protected code, spanning debuggers, emulators, record-replay systems, and program analysis libraries.*  

Each tool serves a particular niche. For instance, if one has a full trace and wants to automate devirtualization, VTIL or Triton is useful. If one needs to quickly test what a suspected handler does, Unicorn or Dumpulator is handy (just run the snippet and see the result). If anti-debug is blocking analysis, PANDA or a hypervisor-based approach can get around it. Often these tools are used in combination. A common workflow might be: use x64dbg/ScyllaHide to get past the packer, Dump the process memory when at the VM start, load it into IDA to identify the table and handlers, then use Unicorn in a Python script to emulate the bytecode, logging each opcode and translating it to an IL, then feed that IL into an optimization tool to get a final devirtualized output.

## Real-World Examples and Case Studies  
Over the years, numerous reversers and researchers have documented their efforts in defeating VMProtect’s virtualization. These case studies highlight the practical application of tracing, emulation, and replay techniques:

- **BattleEye Unpacking (lolblat’s Blog):** In a series of posts, researcher “lolblat” tackled a driver protected by VMProtect (used by the BattleEye anti-cheat software). They identified the VM architecture (finding ESI/EDI/EBP as VIP, registers, stack, and a rolling key in EBX) and described the VM loop in detail ([Unpacking BattleEye - Article 1 | lolblat blog](https://lolblat.github.io/articles/battle-eye-post-1.html#:~:text=After%20filtering%20out%20the%20useless,the%20address%20of%20the%20array)) ([Unpacking BattleEye - Article 1 | lolblat blog](https://lolblat.github.io/articles/battle-eye-post-1.html#:~:text=Step%202%3A%20where%20we%20are,by%20returning%20into%20the%20handler)). By **emulating each opcode** and reversing its effect, they systematically rebuilt the original routine. The blog notes *“I created an emulator to emulate the application, I passed over each opcode and reversed it”* ([Unpacking BattleEye - Article 1 | lolblat blog](https://lolblat.github.io/articles/battle-eye-post-1.html#:~:text=Now%20that%20we%20know%20how,each%20opcode%20and%20reverse%20it)). This yielded insight into how the code was manipulating memory protections and loading functions. The result was a successful unpacking of the protected code, demonstrating a manual but structured approach to devirtualization.

- **Jonathan Salwan’s VMProtect-Devirtualization Project:** This project (and associated paper) provided a clear example of using **trace + symbolic execution** on VMProtect. They focus on a pure function (no side effects) protected by VMP. The steps taken were: identify the virtualized function, generate a trace of its execution, then replay that trace symbolically to derive the original code’s formula ([GitHub - JonathanSalwan/VMProtect-devirtualization: Playing with the VMProtect software protection. Automatic deobfuscation of pure functions using symbolic execution and LLVM.](https://github.com/JonathanSalwan/VMProtect-devirtualization#:~:text=1,unprotected%20version%20of%20the%20target)). They were able to lift the result to LLVM IR and recompile a working equivalent function. This case study proved that even heavily obfuscated virtualization can be defeated by combining dynamic analysis (to handle the self-modifying, encrypted aspects) and static symbolic reasoning (to simplify the logic) ([GitHub - JonathanSalwan/VMProtect-devirtualization: Playing with the VMProtect software protection. Automatic deobfuscation of pure functions using symbolic execution and LLVM.](https://github.com/JonathanSalwan/VMProtect-devirtualization#:~:text=contribution%20aims%20to%20provide%20an,key%20and%20operands%20encryption%20etc)) ([GitHub - JonathanSalwan/VMProtect-devirtualization: Playing with the VMProtect software protection. Automatic deobfuscation of pure functions using symbolic execution and LLVM.](https://github.com/JonathanSalwan/VMProtect-devirtualization#:~:text=The%20approach)). It also showed the importance of focusing on specific functions (they note the method works best when the function has a finite number of paths and no complex interactions).

- **R0da’s Blog on VMP 3.x:** In a detailed three-part blog, r0da reverse engineered VMP 3.x, comparing the demo vs paid versions, explaining the virtualization (including advanced features like handler mutations, register swapping, and *Ultra* mode obfuscations). In the final part, they discussed devirtualization approaches: a “less proper” pattern-matching method versus a “more efficient” method using **Dynamic Taint Analysis (DTA)** and symbolic execution ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=IX.1%20,way%E2%80%9D%20%3A%20Pattern%20matching)) ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=IX.2%20,DTA%20%26%20Symbolic%20execution)). R0da even built a custom Unicorn/Qiling-based debugger to trace VMP instructions and then export the collected bytecode to an IR for optimization ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=As%20I%20don%E2%80%99t%20want%20to,without%20handling%20each%20control%20flow)) ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=,get%20a%20lifted%20simplified%20output)). The blog demonstrates on example routines (a math calculation and an if-statement) how the virtualized code can be understood and even partially automated. One notable takeaway was the explosion of instruction count – a small piece of code became hundreds of VMP instructions and tens of thousands of native instructions ([  Quick look around VMP 3.x - Part 3 : Virtualization | r0da's Blog](https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/#:~:text=In%20my%20example%2C%2017%20instructions,the%20number%20of%20executed%20instructions)) – underscoring why automation is needed.

- **NoVmp (Community Devirtualizer):** The release of NoVmp (an open-source static devirtualizer for VMP 3.x x64) is a real-world testament that these techniques can be encoded into a tool ([can1357/NoVmp: A static devirtualizer for VMProtect x64 3 ... - GitHub](https://github.com/can1357/NoVmp#:~:text=GitHub%20github,machine)). NoVmp leverages VTIL to lift the entire virtualized function into IL, applies known simplifications, and outputs working x64 code. The existence of such a tool shows that through community effort, the handler patterns and VM structure were generalized to handle multiple binaries. While not trivial to use, it provides a framework where a lot of the heavy lifting (finding handler table, decoding opcodes, etc.) is automated or at least assisted by the tool.

- **Malware Analysis Reports:** Many malware families (e.g. some coin miners, loaders like PrivateLoader, or droppers like SystemBC) have used VMProtect to hinder analysis. In these cases, analysts often report that they resorted to dynamic tracing to get past the virtualization. For instance, Hendrik Eckardt’s write-up on a VMProtect 3.x packed malware mentioned that standard user-mode anti-anti-debug tools failed, leading them down *“an unexpectedly deep rabbit hole”* of figuring out the VM’s behavior ([Defeating VMProtect's Latest Tricks | cyber.wtf](https://cyber.wtf/2023/02/09/defeating-vmprotects-latest-tricks/#:~:text=A%20colleague%20of%20mine%20recently,out%20what%20is%20going%20on)). By using a combination of debugger tricks (even switching to a 32-bit OS to avoid Heaven’s Gate issues ([Defeating VMProtect's Latest Tricks | cyber.wtf](https://cyber.wtf/2023/02/09/defeating-vmprotects-latest-tricks/#:~:text=64,bit%20system%20for%20this%20sample))) and likely dumping memory, they managed to analyze the protected code. Another example is the analysis by “Sachiel” of PrivateLoader’s VMP-packed code, where an **IDA trace was used** to bypass the opaque virtualization and pinpoint Windows API calls ([VMProtect trace parser. Abstract | by Sachiel | Medium](https://sachiel-archangel.medium.com/vmprotect-trace-parser-dfdc18152f59#:~:text=Abstract)) ([VMProtect trace parser. Abstract | by Sachiel | Medium](https://sachiel-archangel.medium.com/vmprotect-trace-parser-dfdc18152f59#:~:text=I%20considered%20dynamic%20analysis%20to,The%20Windows%20API)). These reports highlight that in real incident response or malware analysis scenarios, time is of the essence – analysts will use whatever quick tracing or dumping method gets the job done (rather than fully devirtualize every opcode). The goal might simply be to find indicators of compromise or decode a configuration, which can sometimes be achieved by partial devirtualization (e.g. identify where in the bytecode an API is called and just focus on extracting that).

In all these case studies, a common thread is the **use of dynamic analysis to handle the protector’s complexity**. Pure static reversing of VMProtect is theoretically possible but practically grueling – dynamic tracing/emulation provides the foothold needed to then apply clever analysis on the captured execution. The case studies also show a spectrum of effort: from quick and dirty tracing to deeply academic symbolic analysis. Depending on the reverse engineer’s goal (e.g., fully recover the code vs. just observe its effect) the approach can vary, but the toolbox of tracing, emulation, and replay is universally applicable.

## Conclusion  
Reverse-engineering a VMProtect-protected program is like peeling an onion of obfuscation. Code virtualization adds a whole new (virtual) CPU that must be understood. By using **tracing**, reverse engineers let the program reveal its secrets step by step, opcode by opcode. By leveraging **emulation**, they run the code in a safe sandbox, free to inspect every register and memory change, effectively turning the table on the protector – the analysis happens on our terms, not the malware’s. And with **record/replay**, they gain the ability to time-travel through execution, examining every nook and cranny of the code’s behavior as many times as needed. 

The combination of these dynamic techniques with clever static analysis (like symbolic execution and IR lifting) has proven successful against VMProtect and similar virtualization-based DRM systems. It transforms a seemingly opaque blob of virtual opcodes back into human-readable logic. While each new version of VMProtect may introduce fresh obfuscation tricks (like more complex handlers or anti-emulation checks), the fundamental approach remains: understand the virtual machine, and you can unlock the protected code. The arms race continues, but armed with tools like Qiling, Unicorn, PANDA, and the collective knowledge from numerous case studies, reverse engineers have shown that even the thickest virtualization layer can be unraveled with methodical analysis.

Ultimately, defeating a system like VMProtect is a mix of **art and engineering** – the art of recognizing patterns and sneaky tricks, and the engineering of building tools and scripts to automate the heavy lifting. As we’ve seen, the community has made great strides, from bespoke tracers to full devirtualization pipelines. Each technique – tracing, emulation, replay – plays a role in chipping away at the virtual machine until the original program’s logic is laid bare. With these techniques, what once was **“unknown architecture”** ([VMProtect Software » VMProtect » Docs](https://vmpsoft.com/vmprotect/user-manual/#:~:text=Virtualized%20fragments%20of%20code%20are,of%20the%20resulting%20disassembled%20code)) becomes just another program to decompile and understand.

