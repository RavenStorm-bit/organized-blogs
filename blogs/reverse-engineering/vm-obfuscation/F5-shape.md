Got it. I’ll research F5 Shape's use of VM-based JavaScript obfuscation, including technical analyses, reverse engineering write-ups, and known methods for understanding or defeating it.

I’ll focus on public discussions, tools, and code-level breakdowns used by researchers or security experts to reverse engineer or bypass the protections implemented by F5 Shape’s JavaScript VM obfuscation. I’ll let you know once I’ve compiled the findings.

# F5 Shape Security’s VM-Based JavaScript Obfuscation – Technical Analysis

## Introduction  
F5’s Shape Security (now part of F5 Distributed Cloud Bot Defense) is known for its **highly sophisticated, VM-based JavaScript obfuscation** used in client-side anti-bot scripts ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=ShapeSecurity%27s%20Javascript%20Virtual%20Machine,to%20protecting%20their%20API%20endpoints)). In practice, a snippet of Shape’s JavaScript is injected into web pages of major enterprises (banks, e-commerce, airlines, government sites, etc.) to gather *client-side signals* (fingerprinting data) and detect automated traffic ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=This%20sort%20of%20clientele%20represents,stop%20bots%20and%2For%20automation%20scripts)). To protect this sensitive bot-detection logic, Shape uses a **custom JavaScript virtual machine (VM)** to execute the code, making it _extremely difficult for attackers to reverse-engineer or bypass_ ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=ShapeSecurity%27s%20Javascript%20Virtual%20Machine,to%20protecting%20their%20API%20endpoints)). The reputation of Shape’s VM is such that it’s considered “one of the hardest anti-bots to reverse” in the web security community ([ShapeSecurity's VM : r/webscraping](https://www.reddit.com/r/webscraping/comments/19emrv2/shapesecuritys_vm/#:~:text=Hello%20guys%208%20days%20ago,ass%20to%20reverse)). Over the years, this approach has set a trend – other anti-bot vendors (e.g. Google’s ReCAPTCHA, Kasada, Cloudflare) have also adopted VM-based obfuscation to harden their client-side code ([The Bot Mitigation Game Has Changed, Again - Kasada](https://www.kasada.io/the-bot-mitigation-game-has-changed-again/#:~:text=Timeline%3A%20Google%20,2023)). Shape, which pioneered this around 2017, remains at the forefront of this technique. 

**How it works:** When a protected webpage loads, the Shape script (often split into a small *launcher* and a large *VM kernel*) is fetched. The launcher script loads the VM code (sometimes called a “seed”) along with configuration parameters (like keys or alphabets) ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=%2A%20Kernel%20,encryption%20keys%20and%20the%20custom)). The kernel/VM then runs invisibly in the browser, collecting various fingerprinting signals (device attributes, behavioral data, etc.) and packaging them into encrypted form. These are sent back to the server in custom headers (e.g. `X-abcde-A`, `X-abcde-B`, etc.) ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=Those%20headers%20transmit%20a%20set,A%20header%28s)). If the client fails to produce the correct headers (e.g. due to script tampering or automation), Shape’s server-side will flag the request as potentially malicious. In short, Shape’s **client-side VM forces bots to execute complex, obfuscated code in a real browser environment**, raising the bar for attackers ([The Bot Mitigation Game Has Changed, Again - Kasada](https://www.kasada.io/the-bot-mitigation-game-has-changed-again/#:~:text=Defensible%20JavaScript%20collection%20ensures%20that,risk%20for%20the%20bot%20operators)).

## Key Obfuscation Techniques in Shape’s JavaScript VM  
Shape’s obfuscation is not a generic packer but a purpose-built virtualization system. Below we summarize the **key techniques** employed to make the JavaScript **extremely opaque**:

- **Custom JavaScript Virtual Machine:** The core of Shape’s protection is a **custom VM interpreter written in JavaScript**. Instead of running logic directly, the real fingerprinting code is **compiled into a custom bytecode**, and a JS **interpreter loop** executes that bytecode ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=ShapeSecurity%27s%20VM%20internals%20are%20supposed,matter%2C%20we%20cannot%20read%20bytecode)). This means the original program’s structure (functions, loops, if-statements) is transformed into low-level opcodes executed by the VM, **hiding the true control flow and logic** from anyone reading the script ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=ShapeSecurity%27s%20VM%20internals%20are%20supposed,matter%2C%20we%20cannot%20read%20bytecode)). Essentially, the human-readable source is never present; it’s all virtualized. An analyst sees only a tangle of VM operations rather than meaningful application code.

- **Stack-Based VM with Custom Opcode Handlers:** Shape’s VM is a **stack-based interpreter** (values are pushed to an operand stack and operations manipulate the stack) ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Shape%20Security%20implements%20a%20custom,instruction%20but%20instead%20the%20micro)). It implements a rich set of custom opcodes to replicate JavaScript’s functionality (e.g. arithmetic, object access, control structures, etc.). The VM’s “**instruction set**” is designed to be **polymorphic** – it changes frequently. In fact, Shape uses a **rotating opcode mapping** so that the numeric codes and their handler functions are randomized per deployment ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Shape%20Security%20implements%20a%20custom,instruction%20but%20instead%20the%20micro)). This means the meaning of a bytecode value (say `0x5A`) is not fixed; it could represent different operations in different versions, thwarting pattern-based analysis. The VM is quite complex (it’s been described as a **CISC**-style VM ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Shape%20Security%20implements%20a%20custom,instruction%20but%20instead%20the%20micro)) with relatively complex instructions), and it includes built-in support for exceptions, loops, and function calls (the VM manages its own call stack or “threads” of execution). All of these opcode **handler functions** are heavily obfuscated (minified names, unusual coding patterns) in the delivered script.

- **“Superoperators” (Merged Operations):** To further complicate reverse-engineering, Shape’s VM uses **superoperators**, which are opcodes that perform multiple low-level operations in one handler. Internally, the Shape code generator can combine several atomic operations into one VM instruction handler. This means each opcode handler might do a sequence of actions (e.g. load a constant, read a variable, then compute a bitwise operation) as a single block ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=)) ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=function%20OPCODE_HANDLER%28_context%29%20,%24_a%20%26%20%24_c%3B)). The set of atomic operations that get fused is randomized, leading to **unique instruction combinations** each time (there’s an “infinite array of possible combinations” for these handlers) ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=)). Superoperators both improve performance (fewer VM loop iterations) and **obfuscate the program flow** by flattening what would be multiple steps into one opaque blob of code. A reverse-engineer can no longer rely on identifying simple known bytecode patterns – each handler is a custom puzzle.

- **Control Flow Flattening via Virtualization:** By using a VM, Shape effectively implements a form of **control-flow flattening**. The original program’s structured flow (with nested loops, conditionals, etc.) gets compiled into a single stream of bytecode instructions and jump tables. The VM typically runs in a loop fetching the next opcode to execute (often indirect via a mapping table) ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=3)) ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=10)). This means **all original branching logic is hidden** behind the VM’s dispatch mechanism – to an outside observer, it’s just one giant loop and switch. Traditional analysis (which relies on following logical branches in source code) is thwarted, since the real branches are determined by the bytecode and VM state. In practice, **humans can’t follow the code by eye** because it no longer resembles top-down code; the flow is flattened into a sea of VM operations ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=ShapeSecurity%27s%20VM%20internals%20are%20supposed,matter%2C%20we%20cannot%20read%20bytecode)).

- **Heavily Mangled Code & Identifiers:** The delivered JavaScript (the VM implementation and data) is extremely **minified/obfuscated at the syntax level**. All function and variable names are mangled into meaningless identifiers (often one or two characters, sometimes non-alphanumeric unicode) ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=This%20is%20a%20sample%20of,making%20sense%20of%20their%20script)). For example, instead of `throwIfTypeError`, you might see a function named `qd` or similar ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=throwIfTypeError)). Object property names and keys are also hashed or replaced with short aliases. This makes reading the raw code daunting – every variable is “named” something like `q`, `w`, `X`, etc. ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=This%20is%20a%20sample%20of,making%20sense%20of%20their%20script)). While this kind of identifier obfuscation is common, Shape’s implementation is extensive and tailored (they do *not* rely on a public obfuscator tool) ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=Something%20that%20is%20quite%20refreshing,side%20scripts)), so the mapping of names changes over time and is not easily recognizable. Reverse engineers often have to **renaming variables/functions** (using scripts or AST transformations) as a first step to make sense of the VM code ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=At%20the%20beginning%20of%20my,and%20analyzing%20easier%20to%20perform)).

- **Encrypted and Opaque Data Structures:** A significant portion of the VM’s “data” (constant tables, strings, etc.) is kept in **encoded forms** so that it’s not directly readable in the script. For instance, *all string literals* that the VM might need (think of messages, function names, keys) are stored in an **obfuscated form** (often base64 or similar). Shape uses a custom mechanism where strings are **XOR-encrypted and base64-encoded** in an array, and only constructed at runtime when needed ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=Every%20single%20string%20that%20is,function)) ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=const%20strBDecoded%20%3D%20base64Decoder%28obfuscatedStrings,xorMap%5BfullKeyName%5D%20%3D%20value)). The VM contains a helper (often called `getXorValue` or similar by reversers) that takes two encoded string pieces and XORs them (with a dynamic one-byte key) to produce the actual string ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=Every%20single%20string%20that%20is,function)) ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=const%20strBDecoded%20%3D%20base64Decoder%28obfuscatedStrings,xorMap%5BfullKeyName%5D%20%3D%20value)). In effect, any meaningful text (like `"userAgent"` or `"webdriver"`) is never plainly present – it’s dynamically decrypted at execution time. Similarly, numeric constants might be split or stored in a specialized array (one of the VM data objects is literally an `ARRAY_OF_NUMBERS`) ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=7)). This array holds numbers in various formats and is used whenever the VM needs a constant number, again so that the actual value isn’t obvious in source ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=7)). There’s also an `OBFUSCATED` strings array (base64 text pieces) ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=match%20at%20L334%207,OBFUSCATED)) and other config arrays. All these make it **impractical to glean any configuration or logic by scanning the static file** – everything is encoded and must be decoded by running the VM.

- **Indirect Access to Native APIs:** To avoid calling browser APIs or globals in an obvious way, Shape’s VM often uses **indirection for native functions**. One of the VM’s data arrays (`NATIVE_FUNCTIONS`) contains references to real browser objects or methods ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=9)). For example, instead of calling `window.navigator` or `document.createElement` directly in the code, the VM might store these in an array at startup (perhaps via dynamic indexing) and later call them via the array (e.g. `NATIVE_FUNCTIONS[5](args)`). This hides explicit references to well-known properties or functions from static analysis. There’s also an `ARRAY_OF_MAP_FILTER_FOR_EACH` which contains prototypes for Array.map, filter, forEach ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=match%20at%20L360%2010)) – likely so the VM can iterate or manipulate arrays without ever writing the literal words “map” or “forEach” in the code, confounding simple keyword searches. This **layer of indirection** forces an analyst to reconstruct what each index refers to (often by observing at runtime), adding another hurdle to understanding the logic.

- **Dynamic Polymorphism & Frequent Updates:** Perhaps Shape’s greatest strength is not just how complex the VM is, but how **frequently it changes**. The Shape “kernel” script is **recompiled and redistributed approximately every 30 minutes** for each protected site ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=match%20at%20L63%20,new%20seed%20every%2030%20minutes)). In other words, even if an attacker painstakingly deobfuscates one instance of the VM, that **version becomes obsolete very quickly**. Each new “seed” (build of the VM) changes the opcode mappings, the order of operations, encryption keys, and even the overall ordering of the fingerprinting steps ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=match%20at%20L63%20,new%20seed%20every%2030%20minutes)). The launcher script often passes fresh parameters each time, like dynamically generated **encryption keys, random nonces, and even a custom Base64 alphabet** for encoding data ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=%2A%20Launcher%20,request%20base)). This polymorphism ensures that any hard-coded bypass or signature will break. Only an **automated deobfuscation approach** or executing the script itself can keep up with the changes. For the defender, this means even if their VM is “cracked” on Monday, by Tuesday the attackers may be back to square one if they cannot automate the reverse-engineering. This cat-and-mouse dynamic makes Shape’s solution particularly resilient.

- **Possible Anti-Debugging/Tamper Checks:** Shape’s obfuscation is **designed to be resilient** if someone tries to tamper with or instrument the code. While the specifics are closely guarded, researchers have noted the presence of **self-defending code** and potential integrity checks inside the VM ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Downside)). For example, the VM could be seeded with “fake” branches or dummy bytecode paths that, if taken (by an impatient static analyzer), lead to incorrect results – only the correct execution path yields the proper signals. There may also be explicit anti-debug checks (like detecting devtools, or ensuring the code isn’t running too slowly under instrumentation). If a reverse-engineer directly modifies the VM script (e.g. to insert hooks), it might detect the change and alter its behavior or stop functioning ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Downside)). These measures are not fully documented publicly, but any **dynamic hook must be careful** to avoid tripping such defenses, according to tool authors.

**Table: Key VM Obfuscation Techniques in F5 Shape Security**  

| Technique                 | Implementation Details in Shape’s JS VM                                           | 
|---------------------------|-----------------------------------------------------------------------------------|
| **Custom VM Interpreter** | Entire client-side logic is compiled to **custom bytecode** and executed by a JS VM, hiding original code and control flow ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=ShapeSecurity%27s%20VM%20internals%20are%20supposed,matter%2C%20we%20cannot%20read%20bytecode)). |
| **Rotating Opcode Set**   | Uses a **randomized instruction set** (opcode meanings shuffled per “seed”) ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Shape%20Security%20implements%20a%20custom,instruction%20but%20instead%20the%20micro)), so each deployment’s bytecode is unique. |
| **Complex “CISC” Ops**    | Implements **complex VM instructions** (“superoperators”) that perform multiple actions in one handler ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=)), making static patterns hard to find. |
| **Flattened Control Flow**| Original program’s structure (ifs/loops) is flattened into a single bytecode stream & VM loop, preventing straightforward tracing of logic ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=ShapeSecurity%27s%20VM%20internals%20are%20supposed,matter%2C%20we%20cannot%20read%20bytecode)). |
| **Identifier Mangling**   | All function/variable names are **minified or mangled** to nonsense (e.g. `w.A` instead of meaningful names) ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=This%20is%20a%20sample%20of,making%20sense%20of%20their%20script)), deterring manual reading. |
| **Encoded Strings & Data**| Stores strings and constants in encoded form (XOR’ed, base64, etc.) and decrypts at runtime ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=Every%20single%20string%20that%20is,function)) ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=const%20strBDecoded%20%3D%20base64Decoder%28obfuscatedStrings,xorMap%5BfullKeyName%5D%20%3D%20value)). No useful literals appear in the script. |
| **Native API Indirection**| References to browser APIs and prototypes are accessed via pre-filled arrays/objects (e.g. `NATIVE_FUNCTIONS` array) ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=9)), so sensitive calls never appear as direct identifiers. |
| **Frequent Polymorphic Builds** | VM code is recompiled **frequently (e.g. every 30 min)** with new random keys, opcodes, and ordering ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=match%20at%20L63%20,new%20seed%20every%2030%20minutes)), ensuring **attackers must continuously start over**. |
| **Anti-Tamper Safeguards**| Suspected self-checks and dummy code paths exist to detect modification or debugging, making naive instrumentation risky ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Downside)). |

## Protecting Bot Detection & Fingerprinting Logic  
The ultimate goal of Shape’s obfuscation is to **protect the client-side bot detection logic** – i.e. the collection of signals and their evaluation – from attackers. By using the VM techniques above, Shape ensures that the **exact fingerprinting methods and data** remain hidden. Here’s how the bot detection/fingerprinting is integrated and protected:

- **“Signals” Collection:** Shape’s script gathers a wide array of **fingerprinting signals** from the browser. These include obvious things like user-agent, screen dimensions, timezone, and language, but also more **advanced signals** like GPU/graphics driver info, canvas fingerprints, WebGL data, audio contexts, touch/mouse movement timing, and even how the page’s JavaScript behaves (e.g. detection of automation tools). All these are computed within the VM code. Because the logic is virtualized, an attacker cannot easily see **which signals are collected or how**. For example, the code might call a function to enumerate WebGL rendering info – but in the VM’s bytecode, that could be dozens of opcodes manipulating data structures, with nothing explicitly saying “WebGL”. The obfuscation and indirection (like using `NATIVE_FUNCTIONS` to call `canvas.getContext`) make it **very non-obvious** what data is being gathered. This means a bot developer has a hard time knowing **what they need to fake** to appear legitimate.

- **Encoding and Encrypting the Telemetry:** After gathering the raw signals (often called **sensor data**), Shape’s script **encodes and encrypts** this data before sending. According to reverse-engineering writeups, Shape uses a custom encoding format (internally nicknamed **“superpack”** encoding) to serialize the data efficiently ([GitHub - sonya75/starbucks-botdetection-cracked: Starbucks uses Shape Security for bot detection. This script is to pass that bot detection for any website using Shape Security, like Starbucks or Chipotle for example](https://github.com/sonya75/starbucks-botdetection-cracked#:~:text=The%20sensor%20data%20is%20first,standard%20base64%20alphabets%20are%20shuffled)). The serialized blob is then **encrypted with dynamic keys** – typically using two random “seeds” that were delivered with or derived from the script ([GitHub - sonya75/starbucks-botdetection-cracked: Starbucks uses Shape Security for bot detection. This script is to pass that bot detection for any website using Shape Security, like Starbucks or Chipotle for example](https://github.com/sonya75/starbucks-botdetection-cracked#:~:text=The%20sensor%20data%20is%20first,standard%20base64%20alphabets%20are%20shuffled)). The encryption is custom (not a standard cipher, likely a simple XOR or polyalphabetic cipher with those seeds). Finally, the encrypted bytes are **base64-encoded with a non-standard alphabet** ([GitHub - sonya75/starbucks-botdetection-cracked: Starbucks uses Shape Security for bot detection. This script is to pass that bot detection for any website using Shape Security, like Starbucks or Chipotle for example](https://github.com/sonya75/starbucks-botdetection-cracked#:~:text=Then%20the%20encoded%20data%20is,standard%20base64%20alphabets%20are%20shuffled)). Crucially, the base64 alphabet itself is randomized each time (the server knows what variant was used). The outcome is that the **payload sent to the server is gibberish** to an outsider – only the server (which has the keys/seed) can decrypt it. Even if one intercepts the headers, without running the exact same JS logic, it’s infeasible to decode or alter them.

- **Dynamic Per-Session Parameters:** Every time the client loads the page, Shape provides unique values that tie into the telemetry generation. As noted, the script is accompanied by a unique **UUID token** and other dynamic parameters ([GitHub - sonya75/starbucks-botdetection-cracked: Starbucks uses Shape Security for bot detection. This script is to pass that bot detection for any website using Shape Security, like Starbucks or Chipotle for example](https://github.com/sonya75/starbucks-botdetection-cracked#:~:text=Each%20time%20you%20load%20a,times%2C%20they%20will%20block%20it)). This token is often visible in one of the headers (`X-...-f` or similar) and is used server-side to correlate the expected seeds. The Shape VM actually **hides a “bundle seed” inside its bytecode** (a value that isn’t obvious except by running the code) ([GitHub - sonya75/starbucks-botdetection-cracked: Starbucks uses Shape Security for bot detection. This script is to pass that bot detection for any website using Shape Security, like Starbucks or Chipotle for example](https://github.com/sonya75/starbucks-botdetection-cracked#:~:text=Each%20time%20you%20load%20a,times%2C%20they%20will%20block%20it)). The server can derive or verify this seed from the UUID. If an attacker simply replays an old payload or reuses a token, the server will detect a mismatch and likely block the request ([GitHub - sonya75/starbucks-botdetection-cracked: Starbucks uses Shape Security for bot detection. This script is to pass that bot detection for any website using Shape Security, like Starbucks or Chipotle for example](https://github.com/sonya75/starbucks-botdetection-cracked#:~:text=Each%20time%20you%20load%20a,times%2C%20they%20will%20block%20it)). In other words, **each instance of the script produces a one-time result** – it’s not reusable. This design forces bots to truly run the JS on every request (just copying a past answer won’t work after it expires or if tied to a different token).

- **Protected Communication via Custom Headers:** Shape sends the fingerprint results in custom HTTP headers (often prefixed with an `X-` and some random-looking key that is constant per site). For example, on a site like Target protected by Shape, one might see headers like `X-GyJwza5Z-A`, `X-GyJwza5Z-B`, `X-GyJwza5Z-C`, etc. ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=around%20their%20Network%20tab%20to,find%20these%20weird%20headers)) ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=Those%20headers%20transmit%20a%20set,A%20header%28s)). The obfuscation ensures that even the generation of these header names is hidden – the prefix (`X-GyJwza5Z-`) is constructed at runtime (likely from those obfuscated strings) ([GitHub - sonya75/starbucks-botdetection-cracked: Starbucks uses Shape Security for bot detection. This script is to pass that bot detection for any website using Shape Security, like Starbucks or Chipotle for example](https://github.com/sonya75/starbucks-botdetection-cracked#:~:text=%60X,containing%20the%20sensor%20data)). The contents: one header might carry the main encoded payload (`-a`), another a checksum or secondary value (`-b`), another a “bundle seed” or version (`-c` or `-d`), and one is the token (`-f`) ([GitHub - sonya75/starbucks-botdetection-cracked: Starbucks uses Shape Security for bot detection. This script is to pass that bot detection for any website using Shape Security, like Starbucks or Chipotle for example](https://github.com/sonya75/starbucks-botdetection-cracked#:~:text=%60X,header)). All of these are produced by the VM logic. The **integrity of the data is protected** (e.g. a checksum header `-b` that is derived from the payload and token ensures they match ([GitHub - sonya75/starbucks-botdetection-cracked: Starbucks uses Shape Security for bot detection. This script is to pass that bot detection for any website using Shape Security, like Starbucks or Chipotle for example](https://github.com/sonya75/starbucks-botdetection-cracked#:~:text=%60X,value))). This prevents tampering – if an attacker tried to modify the payload or reuse it, the checksum wouldn’t match and the server knows something is off. Essentially, the obfuscation + encryption acts as a client-side **challenge–response**: only a real browser running the exact script can produce a valid set of headers.

- **Bot Detection Decisions Hidden In VM:** Shape’s script not only collects data, but could also make some client-side decisions (for example, detecting obvious automation and not even sending a full payload). Because this logic is inside the VM, any heuristics (like “if no mouse movement at all, flag as bot”) are **opaque**. Attackers can’t easily discern at which point a property is considered suspicious. All the comparisons and thresholds are happening in bytecode. The result – whether the client appears valid – might be encoded in the payload in a way only the server can judge. In older Shape versions, researchers noted that **hundreds of signals at network, browser, and user-interaction levels** feed into the decision ([[PDF] Shape Enterprise Defense - F5](https://www.f5.com/pdf/shape-security/Shape-SED-Solution-Overview.pdf#:~:text=It%20relies%20on%20hundreds%20of,reverse%20proxy%20can%20be)). The obfuscation protects these details, so attackers cannot just replicate a subset of signals; they must replicate the entire behavior of the script.

In summary, Shape’s VM-based obfuscation ensures the **bot detection logic is a black box** on the client side. Attackers are forced to treat it as such – they can either execute it like a black box (incurring the overhead and risk of detection) or attempt the herculean task of devirtualizing it in real-time. Meanwhile, the server validates the cryptographically jumbled output. This architecture has proven highly effective at keeping automated attackers from forging the “expected” client behavior without doing the real work.

**Table: Example Flow of Shape’s Protected Signal Collection**  

| Step                        | Description & Obfuscation                                                                 |
|-----------------------------|-------------------------------------------------------------------------------------------|
| **1. Page Loads Shape JS**  | Browser loads Shape’s launcher and VM code (unique per session). VM starts executing in background. |
| **2. Fingerprint Signals**  | VM gathers device/browser data (UA string, WebGL info, input events, etc.) – all done via VM opcodes (hidden logic, no obvious function calls). |
| **3. Encode & Encrypt**     | Collected data is serialized (e.g. with Shape’s **SuperPack** format) ([GitHub - sonya75/starbucks-botdetection-cracked: Starbucks uses Shape Security for bot detection. This script is to pass that bot detection for any website using Shape Security, like Starbucks or Chipotle for example](https://github.com/sonya75/starbucks-botdetection-cracked#:~:text=The%20sensor%20data%20is%20first,standard%20base64%20alphabets%20are%20shuffled)), then encrypted with two dynamic seeds ([GitHub - sonya75/starbucks-botdetection-cracked: Starbucks uses Shape Security for bot detection. This script is to pass that bot detection for any website using Shape Security, like Starbucks or Chipotle for example](https://github.com/sonya75/starbucks-botdetection-cracked#:~:text=The%20sensor%20data%20is%20first,standard%20base64%20alphabets%20are%20shuffled)). The result is base64-encoded using a custom alphabet ([GitHub - sonya75/starbucks-botdetection-cracked: Starbucks uses Shape Security for bot detection. This script is to pass that bot detection for any website using Shape Security, like Starbucks or Chipotle for example](https://github.com/sonya75/starbucks-botdetection-cracked#:~:text=Then%20the%20encoded%20data%20is,standard%20base64%20alphabets%20are%20shuffled)). These steps are performed by opaque VM routines (attackers can’t easily replicate without the keys). |
| **4. Prepare Headers**      | VM generates custom header names and values. e.g. `X-####-a` = main payload, `X-####-b` = checksum, `X-####-c` = bundle seed, `X-####-f` = session token ([GitHub - sonya75/starbucks-botdetection-cracked: Starbucks uses Shape Security for bot detection. This script is to pass that bot detection for any website using Shape Security, like Starbucks or Chipotle for example](https://github.com/sonya75/starbucks-botdetection-cracked#:~:text=%60X,header)). Names are constructed at runtime (prefix hidden in VM data). Checksums ensure consistency. |
| **5. Send to Server**       | The headers are sent with an HTTP request (or via a beacon). The server side knows the expected seed/keys (from the token) and decodes the payload. It then evaluates the fingerprint data to decide if the client is a bot. Because the client code was **polymorphic and encrypted**, a bot can’t fudge these headers without running the actual code. |

## Reverse Engineering and Bypass Efforts by Researchers  
Despite Shape Security’s efforts to keep their VM inscrutable, the security research community has actively studied it. Over the years, several **reverse engineering write-ups and tools** have emerged, offering a glimpse into Shape’s VM internals and even methods to deobfuscate it. Below, we discuss known strategies and resources used to attack Shape’s VM obfuscation:

- **Static Analysis & Decompilation:** One approach is to **statically analyze the VM code** to recover the higher-level logic. This is extremely challenging due to the complexity and dynamic aspects, but not impossible with enough automation. Researchers have used techniques like **Abstract Syntax Tree (AST) transformations** to rename variables and reformat the code for readability ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=At%20the%20beginning%20of%20my,and%20analyzing%20easier%20to%20perform)). Once the code is cleaned up, the next step is often to disassemble or decompile the bytecode. For example, recognizing patterns in the VM’s opcode handlers can allow a reverse engineer to map certain bytecode sequences to high-level constructs (like an `if` or a loop). A notable blog series by **Botting.rocks (2024)** methodically breaks down Shape’s VM: Part 1 covers the overall architecture (“VM Machinery” like the thread scheduler), Part 2 dissects the **VM data structures** (11 key objects including `OPS_FUNCTIONS`, `HEAP` for bytecode, etc.), and Part 3 begins diving into specific opcodes and how they implement JavaScript semantics. The author demonstrates how to identify individual *atomic operations* inside the merged opcode handlers by building a **dependency graph** of the handler’s statements ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=instructions)) ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=During%20each%20traversal%2C%20we%20determine,instance%2C%20consider%20the%20following%20statement)). By analyzing these dependency graphs, they could split a superoperator into its constituent operations. This kind of static deconstruction is essentially **writing a custom decompiler for the VM**, which is exactly what the author advocates – a “proper decompiler” that can trace each bytecode path and output equivalent JavaScript ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=hundreds%20or%20even%20thousands%20of,matter%2C%20we%20cannot%20read%20bytecode)). Indeed, they note that control structures like loops and conditionals *can* be recovered by following the chained opcodes, even if variable names and some expressions remain opaque ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=hundreds%20or%20even%20thousands%20of,matter%2C%20we%20cannot%20read%20bytecode)). Static reverse engineering of Shape’s VM is painstaking, but these write-ups prove it’s feasible to **understand the VM’s design** (e.g. how it starts thread `0_0`, how it spawns new threads for functions ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=1)) ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=transferredKeys%20array%20and%20calls%20work,wrapper%20for%20the%20function%20work)), how it uses a `THREAD_CONFIG` for managing execution ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=match%20at%20L373%2011)), etc.) and to manually translate bytecode back to logic in some cases. However, doing this by hand for each new “seed” is impractical – thus static analysis is often combined with dynamic techniques.

- **Dynamic Tracing & Instrumentation:** The more powerful approach to deobfuscate Shape’s VM is to **instrument it at runtime**. By letting the VM actually execute in a controlled environment (a real browser or a headless engine), one can hook into the process to extract either the bytecode or the high-level operations being performed. A publicly available tool in this vein is the *Shape Security Decompiler Toolkit* by @g2asell2019 ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=This%20tool%20kit%20is%20capable,lift%20these%20traces%20into%20javascript)). This toolkit is a **full dynamic deobfuscation framework**: it **injects a custom tracer into the Shape VM** to log every opcode executed, and then “lifts” the trace into reconstructed JavaScript code ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=This%20tool%20kit%20is%20capable,lift%20these%20traces%20into%20javascript)) ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Shape%20Security%20implements%20a%20custom,instruction%20but%20instead%20the%20micro)). The trick is to patch the VM script slightly to insert hooks at the right places (for example, after each opcode dispatch). The author of the toolkit describes targeting the **micro-instructions** that are consistent across versions, rather than the ever-changing full handlers ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Shape%20Security%20implements%20a%20custom,instruction%20but%20instead%20the%20micro)). In practice, the tool likely hooks fundamental operations (like the low-level stack pushes, pops, arithmetic ops) which don’t change in essence, and uses those to build a picture of what each instruction did. Over the course of execution, one can collect a log like: “push constant 5; push constant 3; bitwise AND; store result…”, and from that reconstruct that the code was effectively `var x = 5 & 3`. By tracing all paths, the toolkit can output a de-virtualized JavaScript that should be functionally similar to the original code hidden in the VM. This is essentially an **automated disassembler/disassembler** approach.

    - *Challenges:* Instrumenting Shape’s VM is not trivial. One concern is **self-defense/tamper checks**: since the toolkit modifies the script (to insert hooks or to expose internal data), it risks triggering any anti-tamper mechanisms ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Downside)). The toolkit author acknowledges this, noting that certain “fake paths” or checks could slip through and pollute the output if not handled ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Since%20the%20deobfuscator%20hooks%20directly,checks%20should%20still%20be%20prevalent)). Another challenge is performance and completeness: the VM might have code that only runs in rare conditions (e.g. error handling paths), so a tracer needs to either force execution down those paths or employ symbolic execution to discover them – otherwise, the decompiled output might miss pieces. Nonetheless, dynamic tracing has proven quite effective. It essentially uses the VM against itself: let it decode its own logic, then catch it in the act.

- **Bypass Tools and Scripts:** Beyond pure analysis, some projects have aimed directly at **bypassing Shape’s protection**. One early example (circa 2018) is a GitHub project nicknamed “Starbucks bot detection cracked” ([ShapeSecurity's VM : r/webscraping](https://www.reddit.com/r/webscraping/comments/19emrv2/shapesecuritys_vm/#:~:text=that%20is%20a%20pain,reverse)) (Starbucks was a known Shape customer). The author managed to **extract the necessary data and reimplement the signal generation in Python**. Their approach, as described in the README, was to reverse engineer the encoding/encryption (the “superpack” and custom base64) and the dynamic values, so that the Python script could **produce valid headers without running the real JS** ([GitHub - sonya75/starbucks-botdetection-cracked: Starbucks uses Shape Security for bot detection. This script is to pass that bot detection for any website using Shape Security, like Starbucks or Chipotle for example](https://github.com/sonya75/starbucks-botdetection-cracked#:~:text=Shape%20Security%20uses%20a%20custom,that%20can%20decompile%20the%20bytecodes)) ([GitHub - sonya75/starbucks-botdetection-cracked: Starbucks uses Shape Security for bot detection. This script is to pass that bot detection for any website using Shape Security, like Starbucks or Chipotle for example](https://github.com/sonya75/starbucks-botdetection-cracked#:~:text=The%20sensor%20data%20is%20first,standard%20base64%20alphabets%20are%20shuffled)). They did not publish the full decompiler (for anti-abuse reasons) but outlined the process: parse the Shape script to get the **encryption seeds and alphabet** (which they call *seed1*, *seed2*, and the custom alphabet) ([GitHub - sonya75/starbucks-botdetection-cracked: Starbucks uses Shape Security for bot detection. This script is to pass that bot detection for any website using Shape Security, like Starbucks or Chipotle for example](https://github.com/sonya75/starbucks-botdetection-cracked#:~:text=Each%20time%20you%20load%20a,times%2C%20they%20will%20block%20it)), and also get the hidden *bundle seed*. Then, using those, take their own sensor data (collected via browser automation or imitation) and feed it through the same transformations (superpack encode -> custom encrypt -> custom base64). The result was a set of headers that could convince the server. This illustrates a possible bypass: **reimplement the VM’s functionality outside the browser**. However, this is extremely brittle – as soon as Shape changes any detail of the encoding or adds new signals, the external implementation breaks. Indeed, such scripts require constant maintenance and essentially chasing Shape’s updates. The fact that this older repo is now archived (and newer ones have taken its place) shows the *cat-and-mouse nature*: Shape introduces breaking changes (like new opcodes or different checks) ([The Bot Mitigation Game Has Changed, Again - Kasada](https://www.kasada.io/the-bot-mitigation-game-has-changed-again/#:~:text=Metrics%20used%20to%20measure%20a,mitigation%E2%80%99s%20resolve%20to%20improve%20include)), and reverse engineers have to scramble to update their tools.

- **Community Write-ups and Collaboration:** Several security researchers have published detailed analyses of Shape’s inner workings, which help others understand and possibly automate bypasses. For example, **Sveba’s blog (2024)** *“Dissecting Shape Security’s Virtual Machine”* provides an in-depth look at how one might simplify and recognize the VM’s instruction handlers ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=)) ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=During%20each%20traversal%2C%20we%20determine,instance%2C%20consider%20the%20following%20statement)). Another researcher (likely the Botting.rocks author) shared insights on forums like Reddit, highlighting how dynamic and hard to tackle Shape’s VM is, and pointing to the lack of recent public tooling (before their own) ([ShapeSecurity's VM : r/webscraping](https://www.reddit.com/r/webscraping/comments/19emrv2/shapesecuritys_vm/#:~:text=Hello%20guys%208%20days%20ago,ass%20to%20reverse)). There’s also discussion comparing Shape’s approach to other bot solutions: e.g., PerimeterX, Akamai, DataDome all use more conventional obfuscation which attackers found ways around, whereas Shape’s virtualization stood out ([An Introduction to Javascript Obfuscation & Babel-ReverseJS](https://steakenthusiast.github.io/2022/05/21/Deobfuscating-Javascript-via-AST-An-Introduction-to-Babel/#:~:text=,Shape%20Security%2C%20PerimeterX%2C%20Akamai%2C%20DataDome)). This collective knowledge has led to the development of custom devirtualizers and even partial open-source **emulators** of Shape’s VM. For instance, one could write a **Shape VM interpreter in Node.js** that, given the extracted bytecode and data, executes it to produce outputs – essentially mimicking what the browser does, but in a controlled environment where one can inspect the state. This is another bypass approach: **emulate the VM** fully to get the result without a real browser. It’s like running the bytecode on a clone of the VM. The challenge again is staying updated with Shape’s frequent changes.

In summary, reverse engineers attack Shape’s obfuscation on two fronts: *understanding the VM design* (which is a one-time effort that yields insight into any version’s structure), and *prying out the dynamic secrets of each instance* (keys, bytecode, etc.). Tools now exist to automate much of this, but using them is an ongoing arms race. A point often noted is that defeating Shape’s obfuscation doesn’t necessarily defeat the bot detection logic itself – it just lets one see it. Actually fooling the detection might require replicating subtle browser behaviors (timing, real user interaction), which is another layer of challenge beyond deobfuscation.

**Notable Public Resources on Shape Security’s VM:**  

| Resource (Year)                 | Description and Contributions                                                 |
|---------------------------------|-------------------------------------------------------------------------------|
| **Botting.rocks – ShapeSecurity’s JS VM (2024)**  ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=ShapeSecurity%27s%20Javascript%20Virtual%20Machine,to%20protecting%20their%20API%20endpoints)) ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=The%20VM%20Data%20contains%2011,the%20bytecode%2C%20ops%20functions%2C%20etc))  | A multi-part blog series (Parts 1–3 by “TellMeMore”) that reverse-engineers Shape’s VM. Explains the **VM architecture** (threads, VM functions), details the **11 key VM data structures** (e.g. `XOR_MAP`, `OPS_FUNCTIONS`, `HEAP`, etc.), and analyzes opcode handlers. Provides code snippets (beautified VM code) with commentary on how each part works. Excellent for understanding Shape’s design and building a decompiler. |
| **Sveba’s Blog – Dissecting Shape’s VM (2024)**  ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=)) ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=During%20each%20traversal%2C%20we%20determine,instance%2C%20consider%20the%20following%20statement)) | A technical deep-dive focusing on simplifying Shape’s **opcode handler logic**. Introduces a method of using **dependency graphs** to split merged instructions into atomic operations. Confirms that Shape uses a randomized instruction set and demonstrates a strategy to systematically identify each operation in a handler. Complements Botting.rocks by offering another perspective on devirtualization. |
| **Shape VM Decompiler Toolkit (GitHub 2023)**  ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Shape%20Security%20implements%20a%20custom,instruction%20but%20instead%20the%20micro)) ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Downside)) | Open-source **dynamic deobfuscation toolkit** by g2asell2019. It can **hook and trace** a running Shape VM in order to dump the executed opcodes and then **lift** them into equivalent JavaScript. Handles all known Shape VM versions (with a focus on invariant micro-operations). Provides a foundation to automate breaking Shape’s obfuscation, although users must be careful with tamper checks. |
| **Starbucks Shape Cracker (GitHub 2018)**  ([GitHub - sonya75/starbucks-botdetection-cracked: Starbucks uses Shape Security for bot detection. This script is to pass that bot detection for any website using Shape Security, like Starbucks or Chipotle for example](https://github.com/sonya75/starbucks-botdetection-cracked#:~:text=Shape%20Security%20uses%20a%20custom,that%20can%20decompile%20the%20bytecodes)) ([GitHub - sonya75/starbucks-botdetection-cracked: Starbucks uses Shape Security for bot detection. This script is to pass that bot detection for any website using Shape Security, like Starbucks or Chipotle for example](https://github.com/sonya75/starbucks-botdetection-cracked#:~:text=The%20sensor%20data%20is%20first,standard%20base64%20alphabets%20are%20shuffled)) | An early **bypass script** (Python) demonstrating how to extract required dynamic values from Shape’s JS and generate valid sensor data headers offline. It reverse-engineered Shape’s older encryption (superpack + custom cipher + base64) and showed that with the right seeds and algorithms, one could simulate the browser’s output. A proof-of-concept that Shape’s system can be defeated if you fully deconstruct it, though maintenance is difficult. |
| **Kasada Research Blog (2023)**  ([The Bot Mitigation Game Has Changed, Again - Kasada](https://www.kasada.io/the-bot-mitigation-game-has-changed-again/#:~:text=Timeline%3A%20Google%20,2023)) ([The Bot Mitigation Game Has Changed, Again - Kasada](https://www.kasada.io/the-bot-mitigation-game-has-changed-again/#:~:text=Polymorphic%20detection)) | While not about Shape specifically, this blog discusses the **evolution of bot mitigation** and highlights the adoption of **JS VMs** by multiple vendors (mentioning Shape). It explains why VMs and **polymorphic JS** are now industry-standard – to *force* attackers to execute code and to frequently change the puzzle. It provides context for why Shape’s approach is effective and how attackers’ costs go up. |

## Conclusion  
F5 Shape Security’s VM-based JavaScript obfuscation represents a **state-of-the-art defense** in the cat-and-mouse game of web bot mitigation. By compiling client-side code into a custom VM with ever-changing opcodes, encrypted data, and self-defense mechanisms, Shape makes it extraordinarily time-consuming for attackers to understand or emulate its anti-bot checks. The use of a JavaScript VM achieves *defense-in-depth*: even if one layer (say, simple obfuscation) is peeled back, the core logic is locked behind a virtualization barrier. This ensures that critical anti-bot techniques (like advanced fingerprinting and behavior analysis) cannot be easily read or replayed by attackers.

Reverse engineers have risen to the challenge with creative solutions – building decompilers, instrumenting the VM, and sharing knowledge. These efforts show that no obfuscation is impregnable given enough skill and time. Indeed, given a specific instance of Shape’s VM, a determined analyst can eventually unravel it and produce either a readable form of the code or a tool to simulate it. **However, Shape’s strength is in the *dynamic* nature of its scheme**. By the time an attacker reverse-engineers one version, the target application will have long since updated to a new VM seed with different traps and tricks. This rapid update cycle, combined with the sheer complexity of the virtualization, means **attackers must invest significant, ongoing effort to keep up** ([The Bot Mitigation Game Has Changed, Again - Kasada](https://www.kasada.io/the-bot-mitigation-game-has-changed-again/#:~:text=Metrics%20used%20to%20measure%20a,mitigation%E2%80%99s%20resolve%20to%20improve%20include)). For most bot operators, that cost (in development time, computing resources, and expertise) becomes prohibitive, especially when facing a moving target.

In conclusion, F5 Shape Security’s use of VM-based JavaScript obfuscation is a prime example of pushing client-side code protection to its limits. It employs **custom virtual machines, opcode randomization, control-flow flattening, and multi-layered encoding** to safeguard its bot detection logic. While the security community continues to probe and occasionally pierce these defenses (through publications and tools), Shape’s approach dramatically **raises the bar for attackers**, often tipping the scales in favor of the defender. It highlights how a well-engineered obfuscation and frequent polymorphism can turn the browser into an effective first line of defense against web bots – a gauntlet that only the most resourceful adversaries can hope to crack, and even then, not without a fight. 

