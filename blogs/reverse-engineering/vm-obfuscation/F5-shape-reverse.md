Awesome. I’ll dig into recent and in-depth reverse engineering work done on F5 Shape’s JavaScript VM – including blog posts, GitHub repos, tools, deobfuscation write-ups, and tweets by well-known researchers. I’ll pay close attention to the techniques they use, the tools they build or rely on, and their reasoning process while reverse engineering Shape’s virtual machine.

I’ll let you know once I’ve compiled everything into a breakdown of expert insights, approaches, and tools.

# Reverse Engineering F5 Shape Security’s JavaScript VM Obfuscation

## Background: Shape’s VM-Based Obfuscation 
F5’s Shape Security (now part of F5 Distributed Cloud Bot Defense) protects web apps by running highly obfuscated JavaScript on the client side. Instead of straightforward code, Shape delivers a **custom JavaScript Virtual Machine (VM)** that executes bytecode, collecting **client signals** (fingerprinting data) and packaging them into encrypted headers ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=Many%20have%20probably%20come%20across,to%20find%20these%20weird%20headers)) ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=Image%3A%20ShapeSecurity%20headers)). The protection involves two main scripts on each page load: a *launcher* (per-request, dynamic) and a *kernel* VM seed (periodically changing). The kernel (also called a “seed”) contains the compiled bytecode and logic for signal collection, while the launcher injects the kernel and passes configuration like encryption keys via a custom init event ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=%2A%20Kernel%20,encryption%20keys%20and%20the%20custom)). Shape’s client-side code uses “remarkably sophisticated obfuscation” – essentially a **JavaScript VM interpreter** with a **rotating instruction set** and continuously changing code, making it extremely difficult to reverse engineer ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Shape%20Security%20implements%20a%20custom,The%20approach%20I%20took%20in)) ([Reverse Engineering TikTok's VM Obfuscation (Part 2) : r/netsec](https://www.reddit.com/r/netsec/comments/107bxy3/reverse_engineering_tiktoks_vm_obfuscation_part_2/#:~:text=Anti,gmail%20and%20possibly%20other%20places)).

Notably, Shape’s system is **polymorphic**: A new VM *seed* is compiled and distributed about every 30 minutes for each site, with fresh encryption keys, XOR constants, and even a randomized ordering of signals ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=%2A%20Kernel%20,tools%20to%20decompile%20their%20seeds)). This means even if one instance is decoded, the scheme changes frequently, raising the bar for bot developers. Many high-profile enterprises (banks, retail, etc.) use Shape, so attackers and researchers have invested significant effort into **deobfuscating and reverse-engineering** this VM to understand or bypass the protections ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=Formerly%20known%20as%20Shape%20Security%2C,in%20protecting%20against%20automated%20threats)).

## Researcher Write-Ups on Deobfuscating Shape’s VM (2023–2024)
Several reverse engineers have published deep technical analyses of Shape’s VM in recent years:

- **BottingRocks Series (Adrian “TellMeMore”, 2024):** A three-part blog series dives into the internals of Shape’s JS VM. In **Part 1**, the author outlines how to retrieve the *launcher* and *kernel* scripts (e.g. from a Target website) and describes the overall architecture ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=Finding%20the%20Kernel%20and%20the,Launcher%20Script)) ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=%2A%20Kernel%20,encryption%20keys%20and%20the%20custom)). They note that the kernel is a **pre-compiled bytecode seed** containing the signal logic and dynamic crypto material (keys, XOR bytes, custom base64 alphabets), whereas the launcher is a request-specific bootstrap that passes those keys into the VM ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=%2A%20Kernel%20,encryption%20keys%20and%20the%20custom)) ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=%2A%20Launcher%20,request%20base)). The blog shows example **encrypted headers** (like `x-gyjwza5z-a`, `x-gyjwza5z-b`, etc.) which carry the encoded signals collected by the VM ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=%22x,f%22%3A%20%22A9BJosyMAQAAZpEmnOwCZxjY3txkFz1zX7rKF9WpV6wa)) ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=Image%3A%20ShapeSecurity%20headers)). 

  Because the kernel script is heavily obfuscated (properties and variables mangled beyond recognition), the author’s first step was to apply **AST transformations using Babel** to rename every function, variable, and property to more readable names ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=At%20the%20beginning%20of%20my,and%20analyzing%20easier%20to%20perform)). Simply beautifying the minified code wasn’t enough; renaming gave them a consistent naming scheme to mentally map the code. With a readable form in hand, they then break down the VM’s structure. The series identifies **“VM Machinery” vs “VM Data”**: the *Machinery* refers to the core interpreter functions (eight main functions that rarely change, such as `thread()`, `work()`, `vmRunner()`, `vmMemory()`, etc.), while the *Data* refers to the embedded constant tables and bytecode that do change per seed ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=I%27m%20going%20to%20categorize%20the,internals%20into%202%20parts)) ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=The%20VM%20Machinery%20consists%20primarily,functions%20that%20power%20the%20VM)).

  In **Part 2**, the author focuses on those **VM Data structures**. They enumerate 11 key data objects used by Shape’s VM ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=VM%20Data)), explaining each one’s role. For example, the **`XOR_MAP`** holds pieces for string construction – every string in the VM is stored in an obfuscated form and is dynamically **decrypted via XOR** when needed ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=1)). The VM uses a function (reconstructed and named `getXorValue`) to XOR-decode strings by combining two base64-encoded strings and a byte constant ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=Every%20single%20string%20that%20is,function)) ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=function%20getXorValue,0%5D%20%26%20255)). The blog shows the original convoluted code and a cleaned-up version of `getXorValue` that reveals how two inputs (`strA` and `strB`) are XORed to produce a clear string, with results cached in `XOR_MAP` to avoid recomputation ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=Every%20single%20string%20that%20is,function)) ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=function%20getXorValue,0%5D%20%26%20255)). Other data structures described include `OPS_FUNCTIONS` (the array/object of all VM opcode handler functions), `OPS_SEQUENCE` (a mapping table that helps determine the next opcode via dynamic index lookups), the **`HEAP`** (which is essentially the bytecode array itself – the author nicknamed it “HEAP” as it was an array of byte values) ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=match%20at%20L302%204)), and things like `OBFUSCATED` (an array of strings used in building string constants), `ARRAY_OF_NUMBERS` (an array of numeric constants), `NATIVE_FUNCTIONS` (a list of native JS functions/prototypes accessible to the bytecode), and a `THREAD_CONFIG` structure that defines how new “threads” (VM functions) are initialized ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=7)) ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=10)).

  In **Part 3**, the BottingRocks series goes “deeper into the ops” – essentially reverse-engineering the **virtual instruction set**. A key insight is that Shape does *not* use a one-to-one mapping between high-level operations and VM opcodes. Instead, it employs many **compound opcodes or “super-operators”**, each of which may perform multiple low-level actions. The author describes it as a jigsaw puzzle: many ops are “scrambled” combinations or permutations of basic operations ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=The%20ops%20from%20ShapeSecurity%27s%20VM,a%20lot%20of%20scrambled%20ops)). This makes naive identification hard – two seeds might implement the same logic with differently merged ops. Rather than trying to catalog hundreds of opcodes, the author approached it by **analyzing each atomic operation within an opcode handler**. They identified about **13 fundamental action types** that any opcode handler line could fall into ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=approach,action%20it%20meant%20to%20do)). Each VM opcode function was broken down line-by-line and each line was classified as a specific action (such as pushing a value to the stack, performing arithmetic on the top of the stack, a conditional jump, a call invocation, etc.). 

  Part 3 systematically enumerates these actions with examples. For instance, **stack operations** in Shape’s VM are unusual: the VM doesn’t use normal `stack.push()` or `stack.pop()` calls at all. Instead, it manipulates the stack array length and indices directly. Pushing is done via assignments like `stack[stack.length] = value` rather than using `push()` ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=When%20it%20came%20to%20adding,to%20adapt%20myself%20as%20well)), and popping is done by decrementing `stack.length` (often after using a value) ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=Since%20ShapeSecurity%27s%20VM%20did%20not,were%20accessed%20or%20modified)). In fact, when two values are used to compute a result, the code often writes the result back into one of those stack slots and then shortens the stack by one ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=_vmContext.stack%5B_vmContext.stack.length%20,1)) ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=Since%20ShapeSecurity%27s%20VM%20did%20not,were%20accessed%20or%20modified)). The author consolidated all such “value consumed from stack” cases into a single generic action type since the specific operation (add, multiply, bitwise AND, etc.) could vary but the stack behavior was similar ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=)) ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=_vmContext.stack%5B_vmContext.stack.length%20,1)). Another category is **VM memory access**: the VM has a `vmMemory` object (acting like a register file or variable storage). Actions that read from or write to this memory were identified – e.g. an action pattern `_vmContext._vmMemory.setKey(X)` (which stores a value) versus `_vmContext._vmMemory.getKey(Y)` (which retrieves a value, often then pushed to stack) ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=There%20were%20two%20actions%20associated,with%20the%20vmMemory)) ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=_vmContext)).

  Control flow is also handled in a non-standard way. **Conditional branches** in the bytecode are implemented by directly setting the VM’s instruction pointer (`yIndex` and `xIndex` in the VM context) to new values based on a condition ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=A%20jump%20from%20the%20last,stack)). The author observed two patterns: one where the condition is the last stack value (e.g., `if(stack[top]) { yIndex=…; xIndex=…; }`), and another where the condition is a computed boolean stored in a temporary variable ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=A%20jump%20from%20the%20last,stack)). If the condition is true, the VM jumps to a new `x,y` location, otherwise it proceeds sequentially ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=if%20%28_%24F%29%20,xIndex%20%3D%20_%24C%3B)). Interestingly, not every such jump corresponds to a high-level `if`/`else`—some represent short-circuit logic (`&&` or `||`), nullish coalescing, optional chaining, or loop control (like a for-loop’s continuation check) ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=,Loop%20test%20conditions)). In other words, the VM’s branching mechanism is generalized, and part of reverse-engineering it is recognizing when a jump is acting like an `if` versus when it’s simulating a JavaScript `&&` operator or a loop boundary ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=,Loop%20test%20conditions)). The author notes that a future installment will focus specifically on unraveling these control-flow structures.

  Throughout the series, the BottingRocks author emphasizes the need for a **proper decompiler or tracer** to handle Shape’s VM. Manually reading the bytecode is impractical (“humans cannot read bytecode left-to-right for thousands of lines” ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=originally%20normal%20Javascript%20code%20into,matter%2C%20we%20cannot%20read%20bytecode))), so one must either build a tool to **trace execution paths** or lift the bytecode back into a higher-level code. The author’s end goal is effectively to *automate* the process – they mention the ideal solution is a decompiler that can follow every path and output equivalent JavaScript for each VM thread ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=For%20that%20reason%20alone%2C%20working,following%20the%20ops%20it%20executes)). (Later community discussions indicate the series was expected to continue with control-flow reconstruction and perhaps an actual decompiler release, though as of late 2024 some parts were still pending.)

- **Sveba’s “Dissecting Shape Security’s VM” (Feb 2024):** Another researcher, Sveba, published a detailed blog post sharing their approach to **simplifying Shape’s VM handlers** ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=Analysis)) ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=)). This work, drawing from their 2023 experience, similarly notes that Shape uses a **custom stack-based VM with a randomized instruction set** and “super-operators” (combined instructions) ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=As%20previously%20mentioned%2C%20the%20instruction,merging%20of%20multiple%20atomic%20instructions)). Sveba’s approach centers on **dependency graph analysis**. They take a given complex opcode handler (which might perform multiple operations in sequence) and represent each statement as a node in a graph, with edges denoting data dependencies ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=instructions)). By examining the dependency graph, one can often visually segment the handler into sub-blocks that correspond to atomic operations ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=Disclaimer%3A%20Code%20lines%201%2C%204%2C,lack%20dependencies%20with%20other%20nodes)). In the blog, Sveba shows a graph of a sample handler and identifies three distinct groups of nodes, each matching a known simpler operation (in the example, an opcode that really does two pushes and a bitwise AND) ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=function%20OPCODE_HANDLER%28_context%29%20,context.stack.length%5D%20%3D%20%24_a)) ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=Upon%20examining%20the%20graph%2C%20we,them%20with%20individual%20atomic%20operations)). 

  After splitting an opcode into these constituent operations, Sveba matches each to a library of known **AST patterns**. They developed a map of functions to detect specific operations by examining the AST of each statement ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=During%20each%20traversal%2C%20we%20determine,instance%2C%20consider%20the%20following%20statement)). For example, if a statement contains the `&` operator, it likely represents a bitwise AND operation ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=statement%20satisfies%20specific%20criteria,instance%2C%20consider%20the%20following%20statement)). If another statement writes to `_context.stack[_context.stack.length]`, that’s a push to the stack. By programmatically recognizing these patterns, they classify each line of a handler. Then they can replace the obfuscated handler with a sequence of **atomic opcodes** or a simpler semantic description. Sveba essentially reduces the infinite variety of combined instructions back into a canonical set of micro-operations, much like dismantling a macro into assembly instructions. This is akin to **instruction decoding** or **lifting**: each superoperator is expressed as a series of standard operations (the blog calls them “atomic instructions” ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=As%20previously%20mentioned%2C%20the%20instruction,merging%20of%20multiple%20atomic%20instructions))). This strategy handles Shape’s tactic of randomizing and merging VM instructions by focusing on what each part of the code *does*, rather than what the opaque function name or index might imply.

  Sveba’s blog also discusses how the **instruction set rotates**. Shape randomizes opcode assignments such that the same bytecode value won’t always mean the same operation across different seeds ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Shape%20Security%20implements%20a%20custom,The%20approach%20I%20took%20in)). However, the *atomic pieces* (e.g. “add two numbers”, “push constant to stack”, “read from memory”) remain present in all versions. By hooking those invariant pieces, one can trace any VM instance. (This notion is corroborated by others’ dynamic approaches – see below.) Sveba’s work is more static analysis oriented, using code transformation and pattern matching to simplify the VM.

- **Community Discussions:** The above researchers and others have shared insights on social media (Twitter/X and Reddit) as well. The complexity of Shape’s VM has made it a frequent topic in reverse-engineering circles. For instance, the BottingRocks posts were widely circulated on Reddit’s r/ReverseEngineering and r/netsec, where users noted that Shape Security, along with a few other anti-bot providers like Kasada and Google’s reCAPTCHA, are known for using **VM-based obfuscation** as a defense ([Reverse Engineering TikTok's VM Obfuscation (Part 2) : r/netsec](https://www.reddit.com/r/netsec/comments/107bxy3/reverse_engineering_tiktoks_vm_obfuscation_part_2/#:~:text=Anti,gmail%20and%20possibly%20other%20places)). On Twitter (X), reverse engineers have discussed strategies such as hooking into the running VM. One researcher (@bottingrocks) mentioned using dynamic hooks in scenarios where static AST tooling (like Babel) was too slow or cumbersome, showcasing a custom deobfuscator that patches an anti-bot script (in that case, Akamai’s) to extract its behavior. These discussions highlight a common theme: **dynamic analysis** is often combined with static techniques to tackle Shape’s protection.

## Dynamic Instrumentation and Deobfuscation Tools 
Given Shape’s VM is essentially an *embedded interpreter*, one powerful approach is to instrument it at runtime. A notable example is an open-source toolkit by user **g2asell2019** on GitHub, explicitly built to handle Shape’s obfuscated VM. This **“Shape Security Decompiler Toolkit”** is a full dynamic toolkit for deobfuscation ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Full%20dynamic%20tool%20kit%20that,of%20Shape%27s%20Virtual%20Machine%20obfuscation)) ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Shape%20Security%20Decompiler%20Tool)). It works by **injecting a custom tracer into Shape’s VM script** at runtime, allowing every executed opcode to be logged ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=This%20tool%20kit%20is%20capable,lift%20these%20traces%20into%20javascript)) ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Shape%20Security%20implements%20a%20custom,The%20approach%20I%20took%20in)). The tool then **lifts** the recorded bytecode execution trace into human-readable JavaScript. In essence, instead of trying to decode the VM by hand, it runs the VM (for example, in a headless browser or Node) with hooks on the VM’s internal functions.

According to its README, the toolkit targets **micro-instructions rather than full VM opcodes** ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Shape%20Security%20implements%20a%20custom,The%20approach%20I%20took%20in)). In practice, this means it patches the loaded Shape script to intercept the low-level operations (e.g., the VM’s stack pushes, pops, arithmetic ops, etc.). Because Shape’s “full” instructions (the superoperators) are arbitrary combinations, the tool finds the **common building blocks** that persist across versions and hooks those ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Shape%20Security%20implements%20a%20custom,The%20approach%20I%20took%20in)). By logging each micro-operation as the VM runs, the toolkit can reconstruct the sequence of operations in a form closer to original JavaScript logic. The result is a devirtualized script that can be analyzed or executed directly. 

This dynamic approach has the advantage of not needing to understand every possible opcode upfront – it “learns” what the code does by observing it in action. However, it comes with challenges: the VM code might have **self-defense or tamper-checks**. The author of the toolkit cautions that because they directly modify the VM script to add hooks, there’s a risk of triggering anti-tampering logic (e.g., integrity checks) ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Downside)). In Shape’s case, the toolkit tracks all conditional branches in the bytecode, which helps identify dead code or fake branches, but it doesn’t outright remove any anti-debug measures. Users of such a tool must be mindful that the output could include some artifacts from defenses if those weren’t fully accounted for ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Since%20the%20deobfuscator%20hooks%20directly,checks%20should%20still%20be%20prevalent)).

Aside from g2asell2019’s project, there have been other community efforts. Some individuals have written custom **JavaScript debuggers or frida scripts** to hook Shape’s functions in real time, or even built partial emulators to run the bytecode outside the browser. There was also interest in the **ShapeSecurity-protection-reverse-engineering** repository (seen on GitHub) – which appears to be another attempt, although less is publicly documented about it. The general strategy is consistent: *instrument* the VM either by modifying its code or by using JS engine features (like `Proxy` or `Function.prototype.toString` patching) to intercept calls. 

Dynamic instrumentation yields insight into things like the **encrypted signals** that Shape produces. By letting the actual code run, one can capture the final values before they’re encrypted or sent. For example, using a tracer, an engineer can grab the device fingerprints (mouse movements, timings, etc.) that Shape gathers and see how they’re combined into the `x-gyjwza5z-*` headers. This kind of analysis was historically done by manually stepping through the VM code; now tools can automate it.

## Reverse Engineering Techniques and Methodologies 
Reverse-engineering Shape’s JS VM requires a blend of **static analysis** and **dynamic analysis** skills. Key techniques applied by successful researchers include:

- **Abstract Syntax Tree (AST) Transformations:** Both Sveba and the BottingRocks author leverage AST tooling to make sense of the obfuscated code. By parsing the minified kernel script into an AST, they could rename symbols consistently, split chained expressions, and reformat code without altering its function ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=At%20the%20beginning%20of%20my,and%20analyzing%20easier%20to%20perform)). This step is crucial to convert the opaque, minified VM into a form where logical blocks can be recognized. For instance, renaming all properties and variables from random one-letter names to descriptive names (like `vmContext`, `stack`, `yIndex`, etc.) makes the code much easier to follow ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=This%20is%20what%20my%20beautified,up%20with%20own%20naming%20scheme)) ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=For%20that%20reason%20alone%2C%20working,following%20the%20ops%20it%20executes)). AST transformations were also used to isolate single actions per line (e.g., ensure each `ExpressionStatement` in an op does only one thing) ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=The%20functions%20inside%20OPS_FUNCTIONS%20were,the%20exception%20of%20a%20few)). This prepared the ground for pattern matching each operation.

- **Control Flow Graph & Dependency Analysis:** Shape’s VM handlers are essentially basic blocks of operations. By constructing a dependency graph of statements (nodes connected by variable usage), one can partition a complex handler into sub-components that likely correspond to atomic operations ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=instructions)) ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=Upon%20examining%20the%20graph%2C%20we,them%20with%20individual%20atomic%20operations)). This graph-based approach was highlighted by Sveba’s work. It helps **discover the boundaries** between merged operations – for example, seeing that one group of statements only feeds into each other suggests those lines implement one logical step of the original logic. Graph analysis, combined with knowledge of typical VM instruction patterns, allows identification of constructs like arithmetic, conditional jumps, and function calls within the tangled code.

- **Pattern Recognition for Instruction Decoding:** Once individual operations are separated, researchers apply pattern matching to decode them. This is effectively creating a dictionary of **“signatures”** for VM actions. Examples: *“`_context.stack[_context.stack.length] = ...` at the end of a handler”* is recognized as a push operation; *“`_context.stack[_context.stack.length-2] = _context.stack[_context.stack.length-2] + _context.stack[_context.stack.length-1]`”* matches a binary arithmetic operation (addition in this case); *“`_context.yIndex = ...; _context.xIndex = ...` inside an `if`”* indicates a conditional jump ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=A%20jump%20from%20the%20last,stack)). Both static analysts and dynamic tool authors benefit from these patterns. In code, these patterns were detected via AST queries (e.g., check if a BinaryExpression uses `>>>` to identify a bitwise shift operation) or by simple string matching on the deobfuscated source ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=During%20each%20traversal%2C%20we%20determine,instance%2C%20consider%20the%20following%20statement)). By decoding each low-level instruction, the reverse engineers essentially rebuild the VM’s **instruction set documentation**, which Shape itself keeps secret.

- **Dynamic Execution Tracing:** As noted, hooking the live VM provides a wealth of information. Researchers have instrumented the VM to log each executed opcode (or micro-op) along with context. This dynamic tracing can be done by modifying the code (as g2asell2019’s toolkit does) or by using browser devtools debugging to step through the VM’s execution for a given session. Dynamic analysis is especially useful to extract ephemeral data – for example, the **actual values of signals and keys** at runtime. Shape’s design passes a lot of config at runtime (encryption keys, custom base64 alphabets, etc., via the launcher script) ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=%2A%20Launcher%20,request%20base)). A dynamic approach can grab those and even bypass the obfuscation by using the VM as an “oracle” to decrypt strings or compute outputs. Reverse engineers on Twitter have shared tips like: attach to the browser’s JavaScript engine and override certain native functions (if Shape tries to detect debuggers) or log when the script calls important functions (like the final routine that packages the headers). This real-time strategy complements static decoding – static analysis might tell you *how* encryption is done, but dynamic tracing lets you see *what data* was produced.

- **Emulator or Decompiler Building:** Ultimately, the endgame for many is to build an **emulator** or decompiler for Shape’s VM. This means writing code that can take Shape’s obfuscated bytecode and run it or translate it outside of a browser. The lifter in the decompiler toolkit is essentially a rudimentary emulator that outputs JavaScript code for the observed bytecode path. Others have discussed creating a full decompiler that would output structured code (with `if` statements, loops, etc.) by analyzing the patterns of jumps and calls in the bytecode ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=For%20that%20reason%20alone%2C%20working,following%20the%20ops%20it%20executes)). This requires implementing the control-flow logic: for example, recognizing sequences of jumps as an actual `while` loop, or a pair of jumps implementing a `try/catch`. BottingRocks Part 3 gives insight into how try/catch is implemented in the VM (using an `errorTracker` stack and special opcodes to jump to exception handlers and finally blocks) ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=errorHandling,jump%20to%20the%20catch%20side)) ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=The%20function%20,end%20of%20the%20finally%20side)). Understanding these patterns is necessary to have the decompiler reconstruct high-level constructs. Although building a complete automated deobfuscator for Shape is extremely challenging, the progress made in 2023–2024 shows that much of the VM’s behavior can be recovered and understood through careful RE methodology.

## Examples of Deobfuscation Breakthroughs

To illustrate the above techniques, here are a few concrete examples where reverse engineers unraveled Shape’s obfuscation:

- **Encoded Strings via XOR:** Shape heavily obfuscates string constants used in the client script. Rather than storing plaintext strings, the VM seed contains an array of seemingly random base64 strings (`OBFUSCATED`) and uses a XOR-based recipe to construct needed strings at runtime ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=Every%20single%20string%20that%20is,function)). Researchers discovered that for any two strings needed, the VM would take one from the `OBFUSCATED` array and one key (often from the bytecode/HEAP), decode them from base64, then XOR their bytes (with an additional single-byte offset) to produce a new string ([ShapeSecurity's Javascript VM: Part 2](https://www.botting.rocks/shapesecuritys-javascript-vm-part-2/#:~:text=function%20getXorValue,0%5D%20%26%20255)). This was consistent across versions – by identifying the `getXorValue` routine, they could decrypt all the strings used by the VM. In practice, once the method was understood, one can dump the `OBFUSCATED` array and apply the same XOR logic to retrieve all human-readable strings (like function names or messages) that Shape had hidden. This significantly improves static analysis because those strings often hint at what the code is doing.

- **Super-operators Split into Atomic Ops:** Shape’s bytecode instructions are deliberately complex combos (e.g., one “opcode” might do: load a constant, load a value from memory, add them, and store result on stack). Reverse engineers tackled this by breaking them into **atomic operations**. Sveba’s dependency-graph technique and the BottingRocks line-by-line classification achieved the same goal: they could take a monolithic handler function and divide it into, say, three simpler steps that correspond to known operations (like *push constant*, *read memory*, *bitwise AND*, in the example given) ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=function%20OPCODE_HANDLER%28_context%29%20,context.stack.length%5D%20%3D%20%24_a)) ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=As%20previously%20mentioned%2C%20the%20instruction,merging%20of%20multiple%20atomic%20instructions)). By cataloging these micro-ops, the REs essentially **recreated the VM’s instruction set** in a clean form. One researcher noted that Shape’s VM is a **CISC-style VM** (Complex Instruction Set Computing) with a large variety of instruction forms ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Shape%20Security%20implements%20a%20custom,The%20approach%20I%20took%20in)). Their approach was to identify the RISC-like micro-operations inside each CISC instruction and focus on those. This made it possible to handle the “infinite” combinations, since any super-opcode is just a sequence of a finite set of micro-ops. For example, the BottingRocks deobfuscator eventually recognized patterns like *“overwrite stack[-2] with operation on stack[-2] and stack[-1], then decrement stack length”* as a generic binary operation template, regardless of whether the actual math was +, -, *, %, or bitwise shifts ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=_vmContext.stack%5B_vmContext.stack.length%20,1)) ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=_vmContext.stack%5B_vmContext.stack.length%20,1)). Identifying these patterns meant that even if an opcode was totally new, as long as it was composed of known small steps, the reverse engineer could parse it. This is a classic deobfuscation win: reducing complexity by **lifting the abstraction level** (from randomized opcodes down to stable primitives).

- **Encrypted Signal Packaging:** The ultimate output of the Shape client script is a set of encoded “signals” sent to the server (often as headers or hidden form fields). Reverse engineers managed to decode and understand this packaging. BottingRocks Part 1 described how the kernel seed contains the logic to collect various signals (like timestamps, navigator properties, input events, etc.), and then encrypts/encodes them using keys that were passed in by the launcher ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=%2A%20Kernel%20,encryption%20keys%20and%20the%20custom)) ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=%2A%20Launcher%20,request%20base)). By devirtualizing the code, researchers saw that each signal (or group of signals) was XORed or encrypted with a dynamic key and then concatenated, often base64-encoded with a custom alphabet, resulting in the gibberish string seen in the `x-gyjwza5z-a` header ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=%22x,f%22%3A%20%22A9BJosyMAQAAZpEmnOwCZxjY3txkFz1zX7rKF9WpV6wa)). Through dynamic tracing, one could capture these signals before encryption – effectively defeating the protection to see what data is being sent. Furthermore, the knowledge that **new seeds every 30 minutes** shuffle the process meant that automation had to account for retrieving or breaking each new seed. Some advanced bots in the wild ended up automating a mini-reversal for each page load: for example, using a headless browser to execute the Shape script and extract the computed headers, rather than trying to reimplement the algorithm from scratch every time. The RE efforts in 2023–2025 provided the community with enough understanding to do this reliably. In summary, they decoded the once “opaque” blob of Shape’s signals into its components: a series of key–value device fingerprints, encrypted by known operations. This level of insight is what allows scrapers and bot developers to **bypass Shape’s defenses**, by either replicating the client computation or feeding spoofed data into the server that passes Shape’s validation.

## Conclusion and Sources

Reverse-engineering Shape Security’s JavaScript VM obfuscation has been an arms race. Researchers in the community have made significant strides by combining static code analysis (AST transformations, graph-based deconstruction) with dynamic instrumentation (hooking and tracing the live VM). They have published detailed write-ups ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=For%20that%20reason%20alone%2C%20working,following%20the%20ops%20it%20executes)) ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=A%20jump%20from%20the%20last,stack)) and even open-sourced tooling to demystify Shape’s “black box” VM ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Shape%20Security%20implements%20a%20custom,The%20approach%20I%20took%20in)). These efforts revealed how Shape’s VM works under the hood: from how it **virtualizes JavaScript logic into custom bytecode** ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=ShapeSecurity%27s%20VM%20internals%20are%20supposed,matter%2C%20we%20cannot%20read%20bytecode)), to how it **encrypts signals and thwarts debugging**, and how one can methodically **devirtualize** it back into readable form. 

In the 2023–2025 timeframe, the consensus techniques include building a partial **emulator or lifter** for the bytecode, using **dependency graphs** or pattern matching to split “superinstructions,” and leveraging **dynamic hooks** to capture execution in real-time. The result is that while Shape’s protection is still among the hardest (frequently changing and very opaque), it is no longer impenetrable. Knowledge sharing via blogs and forums has empowered more reverse engineers to break down Shape’s VM – an impressive example of reverse engineering skill applied to modern JavaScript obfuscation. The cat-and-mouse game continues, but the community’s understanding of Shape’s VM has never been better, as evidenced by the rich analyses and tools cited here.

**Sources:**

- Sveba – *“Dissecting Shape Security’s Virtual Machine”*, Feb 2024 ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=Shape%20Security%20implements%20a%20custom,The%20approach%20I%20took%20in)) ([Dissecting Shape Security's Virtual Machine](https://svebaa.github.io/personal/blog/shape-security/#:~:text=During%20each%20traversal%2C%20we%20determine,instance%2C%20consider%20the%20following%20statement)).  
- Adrian (TellMeMore) – *“ShapeSecurity’s JavaScript VM”* parts 1–3 on Botting.rocks, Jan 2024 ([ShapeSecurity's Javascript VM: Part 1](https://www.botting.rocks/shapesecuritys-javascript-vm-part-1/#:~:text=%2A%20Kernel%20,encryption%20keys%20and%20the%20custom)) ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=When%20it%20came%20to%20adding,to%20adapt%20myself%20as%20well)) ([ShapeSecurity's Javascript VM: Part 3](https://www.botting.rocks/shapesecuritys-javascript-vm-part-3/#:~:text=,Loop%20test%20conditions)).  
- g2asell2019 – *Shape Security Decompiler Toolkit (GitHub)*, 2023 ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=This%20tool%20kit%20is%20capable,lift%20these%20traces%20into%20javascript)) ([GitHub - g2asell2019/shape-security-decompiler-toolkit: Full dynamic tool kit that is capable of deobfuscating and producing a javascript representation of Shape's Virtual Machine obfuscation](https://github.com/g2asell2019/shape-security-decompiler-toolkit#:~:text=lifter%20that%20lifts%20the%20executed,to%20then%20hook%20into%20those)).  
- Reddit discussion – *TikTok VM Obfuscation (mentions Shape)*, Jan 2023 ([Reverse Engineering TikTok's VM Obfuscation (Part 2) : r/netsec](https://www.reddit.com/r/netsec/comments/107bxy3/reverse_engineering_tiktoks_vm_obfuscation_part_2/#:~:text=Anti,gmail%20and%20possibly%20other%20places)).  
- Kasada – *Bot Mitigation Game Has Changed* (industry context on JS VMs), 2023 ([The Bot Mitigation Game Has Changed, Again - Kasada](https://www.kasada.io/the-bot-mitigation-game-has-changed-again/#:~:text=Timeline%3A%20Google%20,2023)) ([The Bot Mitigation Game Has Changed, Again - Kasada](https://www.kasada.io/the-bot-mitigation-game-has-changed-again/#:~:text=Bot%20developers%20are%20experts%20at,release%20items)).  
- F5 DevCentral – *What is Shape Security?* (product description), circa 2020 ([What is Shape Security? - DevCentral - F5](https://community.f5.com/kb/technicalarticles/what-is-shape-security/284359#:~:text=Shape%27s%20Client%20Signals%20are%20collected,machine%20implemented%20in%20JavaScript)).