Got it. I’ll do a deep dive into GoMobile for Android, covering its full history, the current state of the command-line tools (`gomobile`, `gobind`), and how to use them in a practical Android compilation case study. I’ll also look into what's broken or outdated when using older documentation, differences in module import behavior vs standard Go apps, and how GoMobile relates to the Go compiler.

I’ll gather information from the latest official Go, GoMobile, and Gobind documentation as well as community-reported issues and GitHub discussions. I’ll let you know when it’s ready.

# GoMobile for Android Development – A Comprehensive Report

## History and Evolution of GoMobile

GoMobile (the Go mobile project) was introduced around 2015 as an **experimental** effort to bring Go to Android and iOS platforms ([Go 1.5 is released - The Go Programming Language](https://go.dev/blog/go1.5#:~:text=The%20new%20darwin%2Farm64%20port%20and,not%20part%20of%20this%20release)) ([mobile module - golang.org/x/mobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile#:~:text=Image%3A%20Caution%20image)). Early versions of GoMobile required Go 1.5 or later, since Go 1.5 added crucial features like the `android` and `ios` ports and new build modes for mobile support ([Go 1.5 is released - The Go Programming Language](https://go.dev/blog/go1.5#:~:text=The%20new%20darwin%2Farm64%20port%20and,not%20part%20of%20this%20release)) ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=Note%3A%20You%20need%20to%20have,4%20if%20using%20macOS%20Sierra)). The initial toolchain was primitive but demonstrated that Go code could be compiled into mobile libraries and apps. Key milestones in GoMobile’s evolution include:

- **2015 (Go 1.5)** – The first release of the Go Mobile project. It introduced the `gomobile` tool to simplify building Go on Android/iOS ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=Note%3A%20You%20need%20to%20have,4%20if%20using%20macOS%20Sierra)). At this stage, the project was *“early work”* and required external dependencies (e.g. Android NDK) to be configured manually. Mobile support was marked experimental and remained outside the standard Go distribution ([Go 1.5 is released - The Go Programming Language](https://go.dev/blog/go1.5#:~:text=The%20new%20darwin%2Farm64%20port%20and,not%20part%20of%20this%20release)).

- **2016-2017** – Continuous improvements were made to GoMobile’s architecture. Support for 64-bit architectures (ARM64) on Android and iOS was added in line with platform requirements. The **`gobind`** tool (part of GoMobile) matured to generate bindings for Java (Android) and Objective-C (iOS) from Go code. Around 2017, the project introduced *reverse bindings* – allowing Go code to call into Java/Objective-C APIs via special import paths ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=Gobind%20also%20supports%20accessing%20API,call%20the%20static%20method%20currentTimeMillis)). Reverse binding features (importing e.g. `"Java/android/app/Activity"` in Go) were proposed and implemented to let Go programs interact with native platform frameworks ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=import%20)), significantly expanding GoMobile’s capabilities.

- **2018-2019** – The Go toolchain’s move to Go Modules (Go 1.11+) prompted updates in GoMobile. Older instructions using `go get` in GOPATH mode were replaced with module-aware commands. By Go 1.16, module support in GoMobile was fully in place. For example, where older docs used `go get` to install `gomobile`, the modern approach is `go install golang.org/x/mobile/cmd/gomobile@latest` ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=To%20install%3A)). Documentation was updated to note that *“GoMobile supports Go Modules now”*, meaning you can run `gomobile bind -v -o app.aar -target=android ./package` in a module project without GOPATH gymnastics ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=,under%20project%20directory%20works%20now)). This period also saw Android 8+ enforcing 64-bit support; GoMobile’s default builds were adjusted to include **ARM64** libraries in addition to 32-bit ARM, ensuring compatibility with Google Play’s 64-bit requirement.

- **2020-2021** – Enhancements for Apple platforms were introduced. GoMobile began supporting the creation of **XCFrameworks** for iOS (combining device and simulator binaries) and added targets for Mac Catalyst and macOS, reflecting Apple’s newer platform unifications ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=installed)). On Android, the packaging remained via AAR, but internal changes improved stability. Notably, the project still had no official v1.0 release (GoMobile’s module version remains v0.x), underscoring its experimental nature ([mobile module - golang.org/x/mobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile#:~:text=Image%3A%20Caution%20image)).

- **2022-2023** – Modernization of GoMobile’s tooling for the latest Android SDK/NDK took place. Earlier versions of GoMobile assumed legacy environment variables and paths (e.g. `ANDROID_HOME` and a single `ndk-bundle` directory). In 2022, changes were made to **remove reliance on deprecated environment variables** and support the Android *“side-by-side”* NDK installation layout ([x/mobile: Gomobile is not compatible with modern Android SDKs and NDKs · Issue #52470 · golang/go · GitHub](https://github.com/golang/go/issues/52470#:~:text=,it%20is%20now)). For example, instead of requiring `$ANDROID_HOME/ndk-bundle`, GoMobile can now locate the newest NDK under `$ANDROID_HOME/ndk/<version>` automatically. The minimum Android API level was raised to 16 (Android 4.1+) ([x/mobile: Gomobile is not compatible with modern Android SDKs and NDKs · Issue #52470 · golang/go · GitHub](https://github.com/golang/go/issues/52470#:~:text=,it%20is%20now)) since older APIs are no longer supported by modern SDKs. These architectural updates fixed compatibility issues with new SDKs and resolved long-standing setup pitfalls.

As of **2025**, GoMobile is still labeled *experimental* but is significantly more robust than in 2015. It leverages the standard Go compiler toolchain (no custom fork of Go) and continues to track Go’s six-month release cycle for improvements. The project remains in the Go sub-repository `golang.org/x/mobile` and has not reached a stable v1.0 (meaning breaking changes can still occur). Nevertheless, it’s used in production by many for cross-platform library development and even fully-native Go apps on Android/iOS. Major changes over the years – such as module support and updated Apple/Android packaging – have addressed initial limitations and aligned GoMobile with evolving platform requirements.

## GoMobile Command-Line Tools: `gomobile` and `gobind`

GoMobile provides two primary command-line tools: **`gomobile`**, which is the high-level build tool, and **`gobind`**, which is a language binding generator. Together, these tools allow Go code to be compiled into libraries or apps that run on Android and iOS. Below we examine each tool’s usage and syntax in depth.

### The `gomobile` Tool

The `gomobile` command is a one-stop tool for building and running mobile apps or libraries written in Go ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=bind%20%20%20%20,print%20version)). You install it separately from Go (since it’s in the `x/mobile` repo). The latest installation steps are:

```bash
$ go install golang.org/x/mobile/cmd/gomobile@latest   # Install the gomobile tool
$ gomobile init                                        # Initialize for mobile build
``` 

The `gomobile init` step prepares the environment by building the Go standard library for target mobile architectures (this may take a few minutes on first run) ([Using Golang + Gomobile To Build Android Application (with code) - DEV Community](https://dev.to/nikl/using-golang-gomobile-to-build-android-application-with-code-18jo#:~:text=)). It also can install certain dependencies (e.g. it can compile OpenAL for Android if `-openal` flag is provided) ([x/mobile: gomobile init not work · Issue #28449 · golang/go · GitHub](https://github.com/golang/go/issues/28449#:~:text=The%20help%20mentions%20the%20ANDROID_HOME,env%20var)). In modern versions, `gomobile init` will automatically detect your Android NDK location if the Android SDK is installed (it looks under the SDK for an NDK). On first use, ensure you have: 

- **Go 1.16+** (as required by GoMobile) ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=%24%20gomobile%20init)),  
- A Java JDK (for `javac`, version 7 or newer) ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=file%20can%20be%20imported%20using,prefix%20for%20the%20generated%20classes)),  
- Android SDK installed (API level 16 or higher) ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=file%20can%20be%20imported%20using,prefix%20for%20the%20generated%20classes)), with the path set via `ANDROID_HOME`. 

Having these prerequisites in place is crucial before using the `gomobile` commands.

The general usage syntax for `gomobile` is: 

```bash
gomobile <command> [arguments] [options] [package]
``` 

The tool supports several sub-commands, outlined in the official docs ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=bind%20%20%20%20,print%20version)):

| Subcommand      | Description                                                       |
|-----------------|-------------------------------------------------------------------|
| **`gomobile bind`**    | Build a **language binding library** from a Go package for Android and/or iOS ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=bind%20%20%20%20,print%20version)). This produces a compiled library (AAR for Android, or framework/XCFramework for iOS) that can be used in platform-native apps. |
| **`gomobile build`**   | Compile a **standalone app** from a Go package (with `main` function) for Android or iOS ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=bind%20%20%20%20,print%20version)). On Android this produces an APK, and on iOS an app bundle (.app or .ipa). |
| **`gomobile install`** | Like `build`, but also **installs** the app onto a connected device or emulator (uses adb for Android) ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=If%20you%20have%20the%20adb,APK%20to%20your%20mobile%20device)). Useful for testing Go-based apps quickly. |
| **`gomobile clean`**   | Remove object files and cached files produced by GoMobile (resets the gomobile build cache). |
| **`gomobile version`** | Print the version of the GoMobile tool (usually the Git revision of `x/mobile`). |

You can get help on each subcommand via `gomobile help <command>`. Let’s dive deeper into the two most used commands, **`bind`** and **`build`**:

- **`gomobile bind`** – This command generates language bindings and compiles a library for use in an Android or iOS app (an “SDK package”). It is used when you want to write your core logic in Go and call it from Java (Android) or Objective-C/Swift (iOS). The basic syntax is: 

  ```bash
  gomobile bind [-target android|ios|iossimulator|macos|maccatalyst] [-o output_file] [build flags] <package>
  ``` 

  By default, `-target=android` is assumed if you don't specify a target ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=gomobile%20bind%20%5B,package)). For Android, `gomobile bind` produces an **Android Archive (AAR)** file as output, containing: the compiled Go code as native .so libraries and the Java stub classes to call into that code ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=The%20,ios%2C%20iossimulator%2C%20macos%2C%20maccatalyst)). (The default output name is `<packagename>.aar` unless you use `-o` to name it ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=The%20,ios%2C%20iossimulator%2C%20macos%2C%20maccatalyst)).) This AAR can be dropped into an Android Studio project as a library. Internally, `gomobile bind` uses `gobind` to generate Java and Objective-C code, compiles the Go package for mobile ABIs, and packages everything.

  Key points for `gomobile bind`:
  - The **`-target` flag** can be used to specify one or multiple platforms. For example, `-target=android` (for Android AAR) or `-target=ios` (for an iOS framework). You can even combine Apple targets like `-target=ios,iossimulator` to produce a universal XCFramework for both device and simulator ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=installed)). If not explicitly set, `android` is the default target ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=gomobile%20bind%20%5B,package)).
  - **Multiple architectures**: By default, an Android AAR built with `gomobile bind` will include native libraries for **all supported architectures** (ARMv7, ARM64, 386, and x86_64) in one fat AAR ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=By%20default%2C%20,target%3Dandroid%2Farm%2Candroid%2F386)). Similarly, an iOS XCFramework can include slices for arm64 and x86_64. You can limit architectures if needed by specifying them in the target. For example, `-target=android/arm,android/386` would only build ARM and x86 libraries ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=By%20default%2C%20,target%3Dandroid%2Farm%2Candroid%2F386)).
  - You need the Android SDK (and NDK) available. The docs note that *“This requires 'javac' (1.7+) and Android SDK (API level 16 or newer) to build the library for Android. The environment variable ANDROID_HOME must be set to the path to Android SDK.”* ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=file%20can%20be%20imported%20using,prefix%20for%20the%20generated%20classes)). Ensure `ANDROID_HOME` is pointing to your SDK directory (where `platforms` and `ndk/` reside).
  - Additional flags: `-o` lets you set the output filename (e.g. `-o mylib.aar`). `-javapkg` can be used to specify a custom Java package prefix for generated classes (otherwise they default to a generic package derived from your Go package name or module path). For iOS, a `-prefix` flag can prefix Objective-C class names to avoid naming collisions ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=For%20Apple%20,prefix%20flag)). There are also verbose and build flags: `-v` for verbose output (showing the underlying `go build` commands), and you can pass standard `go build` flags like `-tags` or `-ldflags` after a `--` separator if needed ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=The%20,the%20list%20of%20packages%20built)).

  **Output of `gomobile bind` (Android)**: An AAR file is essentially a zip archive. If you open the resulting AAR, you will find a `classes.jar` (containing the Java bindings that call into Go via JNI) and `jni/*` folders with architecture-specific `.so` files (the compiled Go code) ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=The%20,ios%2C%20iossimulator%2C%20macos%2C%20maccatalyst)). For example, `jni/arm64-v8a/lib<name>.so`, `jni/armeabi-v7a/lib<name>.so`, etc., plus possibly an `AndroidManifest.xml` (usually minimal for an AAR). This AAR can be imported in Android Studio (via *File > New > New Module > Import .JAR/.AAR Package*) and then used as a dependency in an Android app ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=For%20,7%2B%29%20and%20Android%20SDK)).

- **`gomobile build`** – This command compiles a Go program into a **native mobile app** (APK for Android or .app for iOS). It’s used when you want to write an entire app in Go (using Go for the app’s entry point and logic, typically with the `golang.org/x/mobile/app` package for event handling). The syntax is: 

  ```bash
  gomobile build [-target android|ios|iossimulator|macos|maccatalyst] [-o output] [-bundleid bundle.id] [build flags] <package>
  ``` 

  The `<package>` must be a Go package with a `main` function (the entry point). For Android, `gomobile build` produces an `.apk` file (Android app) ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=Run%20,an%20Android%20APK)). For iOS, it produces an `.app` bundle (which can be further packaged into an IPA for distribution) ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=Building%20and%20deploying%20to%20iOS)). By default, the output is named after the package (e.g. `basic.apk` for package `basic`) ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=Run%20,an%20Android%20APK)), unless `-o` is used. 

  Key points for `gomobile build`:
  - **Target**: Like bind, you can specify `-target=android` or `-target=ios`. On iOS, note that building an .app requires a Mac host with Xcode, and you’ll need code signing (a provisioning profile and certificate) to deploy the app to a device ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=Run%20,package%20as%20an%20iOS%20application)). For Android, you can run the APK on any device/emulator for testing; no signing is needed for debug builds.
  - **Android APK details**: If your Go package directory contains an `AndroidManifest.xml`, GoMobile will merge it into the APK; otherwise it generates a default manifest for you ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=Build%20command%20will%20build%20an,apk)). The default manifest will have a single Activity that loads the Go runtime. The resulting APK is a **fat APK** containing multiple architectures by default (arm, arm64, x86, x86_64) ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=For%20,target%3Dandroid%2Farm%2Candroid%2F386)) ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=generated,target%3Dandroid%2Farm%2Candroid%2F386)), so it can run on a wide range of devices. You can filter architectures similar to bind (e.g. `-target=android/arm64` for a single-ABI APK) ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=generated,target%3Dandroid%2Farm%2Candroid%2F386)).
  - **Running and installing**: You can use `gomobile install <package>` as a shortcut to build and immediately install the APK on a connected device via adb ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=If%20you%20have%20the%20adb,APK%20to%20your%20mobile%20device)). This saves the manual step of using adb or Android Studio to install the APK.

  Under the hood, `gomobile build` and `install` use the standard Go cross-compiler to build your code for mobile, then they package the binary into an app container. On Android, a small Java stub is included to load the Go native code. On iOS, a stub Objective-C main is used to launch the Go runtime. These details are abstracted away – from the developer’s perspective, you just write a normal Go `main` (optionally using mobile/app for UI events), and GoMobile handles the rest.

In summary, the `gomobile` tool dramatically simplifies the process of targeting Android/iOS. It wraps `go build` with the correct GOOS/GOARCH settings, includes any necessary glue code, and outputs a ready-to-use artifact (library or app). Most tasks you’ll perform with GoMobile will involve `gomobile bind` (if integrating Go code into an existing app) or `gomobile build/install` (if writing a pure Go mobile app).

### The `gobind` Tool

The `gobind` command is a lower-level utility that generates the **language bindings** which allow Java or Objective-C code to call Go functions. In typical usage, you do *not* invoke `gobind` directly – the `gomobile bind` command runs it internally ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=Typically%20gobind%20is%20not%20used,org%2Fx%2Fmobile%2Fcmd%2Fgomobile)). However, understanding `gobind` provides insight into how Go code is translated for mobile.

In essence, `gobind` reads a Go package and produces **bridging code** for Java and Objective-C:
- It creates Java source files (for Android) and/or Objective-C source files (for iOS) that expose the Go package’s exported types and functions as idiomatic classes/methods.
- It also generates some Go code that acts as a wrapper, allowing the Go runtime to interface with the Java/ObjC world.

If one were to use `gobind` manually, the process would be: run `gobind -lang=java <package>` to generate Java bindings, run `gobind -lang=go <package>` to generate a Go support package, then compile the Go code as a C-archive or C-shared library for the target platform ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=Bindings%20require%20additional%20Go%20code,command)). This is complex to do by hand – which is why `gomobile bind` automates it (it effectively performs those steps under the hood).

**Usage:** The general usage is `gobind -lang=<lang> [package]`. Supported `-lang` options are `java`, `objc`, or `go` (and you might supply multiple languages in one invocation). In practice, you will rarely call this yourself; instead, you simply use `gomobile bind`, which calls `gobind` for the appropriate languages and then triggers a build. 

**What `gobind` produces:**
- For **Java**: It generates Java classes mirroring your Go API. Each exported Go struct or function becomes a Java class or method. For example, if you have a Go package `mypkg` with a function `NewCounter() *Counter` and a struct `Counter` with methods, `gobind` will produce a Java class `Mypkg` with a static native method `newCounter()`, and a Java class `Counter` with instance methods like `inc()` and property accessors ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=In%20Java%2C%20the%20generated%20bindings,are)). The actual implementation of these methods is marked `native` and is provided by the Go library (via JNI).
- For **Objective-C**: It generates an `.h` and `.m` file that expose the Go package as an Objective-C class or set of functions. For instance, a Go package `hello` might generate a `Hello.objc.h`/`.m` that can be compiled into an iOS framework, allowing Swift/ObjC to call `[Hello Greetings:@"name"]` which calls into Go.
- For **Go**: This is perhaps non-obvious – `gobind` also generates Go code. The reason is that the foreign language bindings often need some Go-side glue. `gobind -lang=go` produces a Go source file that implements all the required interfaces for Java/ObjC to call into the Go runtime. This includes cgo bridges and registration of the exported symbols. When `gomobile bind` runs, it actually compiles your package **plus** this generated Go file into a single library.

**Example:** Consider the trivial package `hello`:

```go
package hello

import "fmt"

// Greetings returns a greeting for the given name.
func Greetings(name string) string {
    return fmt.Sprintf("Hello, %s!", name)
}
``` 

When you run `gomobile bind -target=android` on this package, `gobind` will generate:
  - A Java class `Hello` with a static method `greetings(String name) -> String`. You would use this in Android as `Hello.greetings("world")` to get the string. (Go functions become static methods on a class named after the package, with name downcased: `Greetings` -> `greetings` ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=public%20abstract%20class%20Mypkg%20,)).)
  - Behind the scenes, the generated Java class calls a JNI function that ends up in the compiled `libhello.so`. The `libhello.so` contains a Go function that wraps `hello.Greetings` and returns the result to Java.
  - If this were iOS, `gobind` would instead generate an Objective-C interface, perhaps a class or function `HelloGreetings(NSString *name)` that calls into Go.

Typically, you won’t see these files, but they are stored in a temporary work directory when you run the bind. If something goes wrong, using `-v` will show the commands and you can inspect the generated code for debugging.

**Type Support and Restrictions:** Because `gobind` must translate between Go types and Java/ObjC types, it only supports a subset of types. All exported functions and types in your Go package must use supported types or they will be omitted from the binding. According to the documentation, supported types include:
- Basic primitives: **integers, floats, booleans, strings** ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=,point%20types)).
- **Byte slices** (`[]byte`), which are passed by reference and can be mutated ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=)).
- **Functions** whose parameters and results are supported types (functions can also return an `error` as a second result, which will be converted to an exception in the target language) ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=,in%20%27error%27%20type)).
- **Structs** and **interfaces** with exported methods that have supported types ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=,methods%20have%20supported%20function%20types)).

Anything else – for example, **channels**, **maps**, **complex numbers**, **pointer types**, or sophisticated interface types – are not supported in the cross-language binding. If you try to export a function using an unsupported type, `gobind` will skip generating that function (and typically will print or embed a comment like *“skipped function X with unsupported parameter or return types”* ([x/mobile/cmd/gobind: custom types mapped to supported ... - GitHub](https://github.com/golang/go/issues/27733#:~:text=GitHub%20github,The%20binding%20works))). If your entire package has no bindable API (e.g. all functions take unsupported types or nothing is exported), `gomobile bind` will fail with an error *“no exported names in the package”* ([go - Gomobile no exported names in the package - Stack Overflow](https://stackoverflow.com/questions/41847117/gomobile-no-exported-names-in-the-package#:~:text=I%20am%20trying%20to%20bind,ran%20as%20a%20go%20script)). (This can also happen if you forget to capital-case your functions – for instance, a package with only `func doThing()` unexported would trigger **“no exported names”**). The takeaway is to design your Go API to use simple types (or structs composed of simple types) for parameters and returns so that `gobind` can do its job ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=All%20exported%20symbols%20in%20the,Supported%20types%20include)).

**Memory management:** `gobind` and the generated code handle passing objects between Go’s garbage-collected heap and Java/ObjC’s memory management. For instance, when you pass a Go object to Java, it’s wrapped in a proxy class. Finalizers are used on each side to inform the other runtime when an object is no longer needed ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=)). One important caveat is to avoid reference cycles between Go and Java objects (each holding a reference to the other) which can prevent garbage collection ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=a%20memory%20leak)). In general, treat the cross-boundary objects as not owning each other to avoid leaks.

In summary, **`gobind`** is the engine that makes Go and Java/ObjC interoperate. As a developer using GoMobile, you mostly interact with it indirectly via `gomobile bind`. But understanding its constraints (supported types, naming conventions, etc.) is crucial for writing Go code that will cleanly translate into an Android SDK library or iOS framework.

## Case Study: Compiling a Go Package for Android with GoMobile

To solidify the concepts, let’s walk through a full example of using GoMobile to compile a Go package for Android. We’ll cover prerequisites, environment setup, the build process, and the output integration.

**Scenario:** Imagine we have a Go library that provides some functionality we want to use in an Android app – for example, a simple library that returns greeting messages. We will use GoMobile to compile this into an Android AAR library and then briefly discuss how to use it in an Android project.

### 1. Prerequisites and Environment Setup

Before using GoMobile, ensure the following are installed on your development machine:

- **Go** (at least version 1.16) – Verify with `go version`. GoMobile uses the Go compiler for cross-compilation ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=%24%20gomobile%20init)).
- **Java Development Kit (JDK)** – needed for `javac` to build Java stubs. Version 8 or higher is recommended (GoMobile requires >= 1.7) ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=file%20can%20be%20imported%20using,prefix%20for%20the%20generated%20classes)).
- **Android SDK** – which includes build-tools and SDK platforms. Install via Android Studio or the command-line SDK manager. Make sure you have at least API level 16 (Android 4.1) or newer SDK installed ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=file%20can%20be%20imported%20using,prefix%20for%20the%20generated%20classes)). Set the `ANDROID_HOME` environment variable to the SDK’s path (e.g., `~/Android/Sdk` on macOS/Linux) so that GoMobile can find it ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=Structure%20,prefix%20for%20the%20generated%20classes)).
- **Android NDK** – the Native Development Kit, which provides native toolchains and headers. Today, the NDK is often installed side-by-side in the SDK (`$ANDROID_HOME/ndk/<version>`). GoMobile will attempt to locate a suitable NDK automatically. If you have multiple versions, it picks the latest that meets its needs ([cmd/gomobile/env.go - mobile - Git at Google](https://go.googlesource.com/mobile/+/master/cmd/gomobile/env.go#:~:text=%2F%2F%20Use%20the%20newest%20compatible,var%20selected%20string)) ([cmd/gomobile/env.go - mobile - Git at Google](https://go.googlesource.com/mobile/+/master/cmd/gomobile/env.go#:~:text=return%20selected%2C%20nil%20,androidHome%2C%20sideBySideErr%2C%20legacyErr%29)). If the NDK is not found, you may need to install it via the SDK manager. (In older setups, you might set `ANDROID_NDK_HOME`, but as of recent GoMobile versions this is optional and considered deprecated in favor of the default SDK location ([x/mobile: Gomobile is not compatible with modern Android SDKs and NDKs · Issue #52470 · golang/go · GitHub](https://github.com/golang/go/issues/52470#:~:text=NDK%20system%29%20,it%20is%20now)).)

Once these are in place, we install and init GoMobile:
```bash
$ go install golang.org/x/mobile/cmd/gomobile@latest
$ gomobile init
``` 
The `gomobile init` will compile the Go standard library for mobile (for arm, arm64, etc.) and set up caches. If everything is correct, it should complete silently. In case of an environment issue, it will report an error. For example, if GoMobile cannot find an NDK, it might error out with a message like *“gomobile: no Android NDK found in $ANDROID_HOME/ndk-bundle nor in $ANDROID_NDK_HOME”* ([go - no Android NDK found in $ANDROID_HOME/ndk-bundle nor in $ANDROID_NDK_HOME in Ubuntu 18.04 - Stack Overflow](https://stackoverflow.com/questions/61052574/no-android-ndk-found-in-android-home-ndk-bundle-nor-in-android-ndk-home-in-ubu/71654923#:~:text=gomobile%20is%20not%20finding%20ndk)). This means you need to install the NDK or point GoMobile to it. (With the latest GoMobile, this specific error is less common, as it now checks the side-by-side NDK directories. But it’s a common setup pitfall.) Ensure `ANDROID_HOME` is set correctly and try again. Once `gomobile init` succeeds, you’re ready to build.

### 2. Writing a Go Package to Bind

Create a Go package that we want to use on Android. For this case study, we’ll use the example `hello` package (similar to the official GoMobile example):

```go
// hello/hello.go
package hello

import "fmt"

// Greetings returns a greeting message.
func Greetings(name string) string {
    return fmt.Sprintf("Hello, %s!", name)
}
```

This package has an exported function `Greetings` which takes a string and returns a string. It uses only supported types (string) and basic Go features, so it’s perfect for binding. (If we had more complex logic, that’s fine – as long as the exposed API sticks to GoMobile’s supported types.)

Before proceeding, double-check that the package builds normally for your host:
```bash
$ go build ./hello
``` 
This should produce no errors. If you forget to export (capitalize) the function, GoMobile will later complain *“no exported names in the package”*, so ensure at least one function/type is exported for binding.

### 3. Compiling the Go Package for Android

Now we use GoMobile to compile the `hello` package into an Android library:

```bash
$ gomobile bind -target=android -o hello.aar ./hello
```

Let’s break down this command:
- **`gomobile bind`** – We choose the *bind* command because we want an AAR library to use in an Android app, not a standalone APK.
- **`-target=android`** – Specifies we’re targeting Android. (This is actually optional since android is the default, but we include it for clarity.) We could add architecture qualifiers (e.g. `android/arm64`) if we only wanted a specific ABI, but by default it will build all four (arm, arm64, x86, x86_64) into the AAR ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=By%20default%2C%20,target%3Dandroid%2Farm%2Candroid%2F386)).
- **`-o hello.aar`** – This sets the output file name. If omitted, it would default to the package name (hello.aar anyway in this case). We include it to be explicit.
- **`./hello`** – The import path of the Go package to bind. Here, our package is in the local `hello` directory (or it could be a module path). You can also specify a fully qualified import path like `golang.org/x/mobile/example/bind/hello` if using the example package.

When you run this, `gomobile` will output the usual Go build progress if verbose, or nothing on success (it might emit a few build lines or a warning if any, but generally it’s quiet on success). After a short time, you should see the file `hello.aar` in your current directory.

**Verifying the AAR**: The AAR is a zip file. If curious, you can unzip `hello.aar` to inspect:
```
classes.jar
jni/armeabi-v7a/libhello.so
jni/arm64-v8a/libhello.so
jni/x86/libhello.so
jni/x86_64/libhello.so
```
You’ll see it includes `libhello.so` for each architecture, and a `classes.jar`. The `classes.jar` contains the generated `Hello` class (and any supporting classes) with the native methods. This matches our expectations from the `gobind` discussion: our Go function `Greetings` is now accessible via a Java static method `Hello.greetings(String)` implemented in those native libs.

### 4. Using the Generated Android Library

With `hello.aar` produced, the Go side of things is done. The next step is to use this in an Android project. While detailing Android app integration is beyond the scope of this report, we’ll outline the basic steps:

- **Import into Android Studio**: In your Android app project, import the AAR. For example, copy `hello.aar` into the app/libs directory and add it as a dependency, or use Android Studio’s *Import .AAR* wizard ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=For%20,7%2B%29%20and%20Android%20SDK)). This will add the `hello` library to your project.
- **Add JNI permission**: (Usually not needed explicitly, but ensure your app’s Gradle config is set to include the ABIs you want. By default, all ABIs are included since the AAR has all four. If you want to slim the APK, you can use `ndk { abiFilters }` in Gradle.)
- **Call the Go code from Java/Kotlin**: The AAR gives you a `io.gomobile.hello.Hello` class (the exact package name may depend on how `gomobile` packaged it; often it defaults to `go` or no package, meaning the class might just be `Hello` in the root package). If you used `-javapkg`, it would be under that package. Assuming default, you can now do something like:
  ```java
  import hello.Hello;  // or just Hello if no package
  
  // ...
  String greeting = Hello.greetings("Android");
  textView.setText(greeting);
  ```
  This will invoke the Go function. When `Hello.greetings()` is called, under the hood it loads the native lib (if not already loaded) and calls into the Go runtime to execute `hello.Greetings`. The result, a Go string, is marshaled back as a Java `String`. 

- **Run the app**: When you run the Android app, the Go library will be loaded. The first call into the library might trigger some one-time init (Go runtime initialization). After that, each call executes Go code as needed. For example, if we call `Hello.greetings("Android")`, the TextView will show “Hello, Android!” as returned from our Go function. (In the official sample, they did exactly this – update a TextView with `hello.Greetings` output on app launch ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=Image%3A%20Android%20Studio)).)

That’s it – we successfully compiled a Go package into an Android-ready library and used it from Java. The entire process – aside from initial setup – is only a couple of commands.

**Alternate scenario – building a full Go app**: If instead of integrating into a Java app, we wanted to build a full Go Android APK, the process would be: write a `main` package (likely using the `mobile/app` package for event loop and any OpenGL UI), then run `gomobile build -target=android` on it. This yields an APK that can be installed. The “basic” example in `x/mobile/example/basic` demonstrates this: it’s an all-Go app that draws a triangle using OpenGL ES, built with `gomobile build` ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=Run%20,an%20Android%20APK)). For such cases, you would use `gomobile install` to load it on a device for testing ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=If%20you%20have%20the%20adb,APK%20to%20your%20mobile%20device)). However, pure Go apps on Android are less common than using `gomobile bind` to create libraries, since most developers still want to leverage the native UI toolkits (Android XML layouts, SwiftUI/UIKit on iOS, etc.) and just use Go for shared logic.

### 5. Resulting Outputs and Next Steps

After using GoMobile, the primary output is the compiled binary (AAR or APK). In our case study:
- We obtained `hello.aar`. This can be checked into your project repository or distributed. It’s a self-contained artifact. To update it, you’d rebuild from Go source again.
- If we built an APK, the output would be `basic.apk` (for example), which could be installed or even uploaded to the Play Store (though one would likely want to merge it with Java Java resources for a full app).

Keep in mind the GoMobile output (whether library or app) still depends on the Go runtime. The .so files embedded include Go’s garbage collector, scheduler, etc. They tend to be a few MB in size as overhead. This is normal – essentially your Android app now carries a mini Go runtime. Ensure to test on devices for performance and binary size. ProGuard (code shrinking) won’t reduce the native lib size, so any optimization must be done in Go (e.g., stripping debug symbols with `-ldflags=-w -s` if needed).

This case study shows that with minimal effort, we compiled Go code for Android. The ability to write logic in Go and call it from Java means you can share code between Android and iOS (by also doing `gomobile bind -target=ios` to get an iOS framework). GoMobile handles the heavy lifting of cross-compiling and binding, letting you focus on writing Go code.

## Differences Between Go Code for Android and Standard Go Code

Writing Go code for use with GoMobile is very similar to writing ordinary Go, but there are important differences and restrictions to be aware of. These arise from the mobile environment and the gobind translation layer. We’ll highlight how Go code for Android (and iOS) differs from typical Go code for desktop/server in terms of package usage, APIs, and compatibility.

### Platform-Specific Packages and APIs

When targeting Android/iOS, you obviously cannot use certain platform-specific libraries that are meant for desktop (for example, you wouldn’t use `os/exec` to spawn processes on Android, since Android apps are sandboxed and that may not work). However, for the most part **the Go standard library “just works” on Android**, because Android’s Linux-based kernel and Bionic C library support many of the same syscalls. Networking (`net` package), file I/O (`os` package), encryption (`crypto`), etc., all work on Android as they do on Linux. There are a few caveats:
- **No GUI toolkits in Go** – There’s no direct support for Android UI toolkits in Go. If you write a pure Go app, you use `golang.org/x/mobile/app` which provides a basic event loop, and you might draw with OpenGL via `golang.org/x/mobile/gl`. But you cannot import `fyne` or `github.com/therecipe/qt` or such in a mobile context without heavy adjustments. For most, the approach is to do UI in Java/Kotlin on Android, and call Go for logic.
- **Mobile platform APIs** – If your Go code needs to call Android APIs (e.g., to vibrate the phone or use camera), you cannot directly import an Android Java class in Go… unless you use **reverse bindings**. Reverse bindings (still experimental) allow Go to call native APIs via special import paths like `"Java/..."`. For instance, Go can import `"Java/android/os/Vibrator"` to get access to Android’s Vibrator class and call its methods ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=Gobind%20also%20supports%20accessing%20API,call%20the%20static%20method%20currentTimeMillis)). This is a powerful feature that has no equivalent in desktop Go. It works similarly for iOS (import `"ObjC/..."` for Cocoa Touch classes) ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=import%20)). Under the hood, this uses gobind to bridge Go calls into Java/ObjC. This is something unique to GoMobile code – normal Go on Windows/Linux cannot import `Java/foo/bar` packages. If you use reverse bindings, your Go code becomes Android-specific (it literally is calling Android APIs).
- **System calls and cgo** – If your Go code uses `syscall` or cgo to call into C libraries, you must ensure those calls are available on Android. Many Linux syscalls exist, but some might not or could require different parameters. Generally, stick to higher-level packages to avoid syscall portability issues. If you have to use cgo (say your Go code wraps a C library), you’ll need an Android-compatible build of that C library. GoMobile can compile C snippets via NDK, but if it’s a large library, integration can be complex. There’s no difference in the Go language here, just the practical need to have the C code cross-compiled. The Go compiler’s C-archive/C-shared modes make this possible.
- **Use of `golang.org/x/mobile` packages** – GoMobile provides some mobile-specific packages (in the `x/mobile` repo) like `app`, `gl`, `asset`, `sensor`, etc. These are designed for mobile use. For example, the `app` package provides a cross-platform interface to handle lifecycle and input events on Android/iOS. This package has no meaning on desktop platforms. Conversely, desktop-specific packages (like `net/http/pprof` or GUI libs) have no meaning on mobile. So when writing cross-platform Go, you may need to use build tags or conditional code. For instance, you might have `// +build android` and `// +build linux` variants if certain code should run only on Android vs others on desktop.

In summary, **importing Java/ObjC packages via special import paths is a feature exclusive to GoMobile** ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=Gobind%20also%20supports%20accessing%20API,call%20the%20static%20method%20currentTimeMillis)). Regular Go code cannot do that. This allows Go code to directly call Android APIs, but it ties the code to the mobile platform and should be used sparingly and carefully (since it introduces additional complexity and potential for reference cycles as discussed).

### Language and Binding Restrictions

The Go language itself doesn’t change when targeting Android, but what you can **expose** across language boundaries is restricted. When writing a Go library intended for mobile (to be called from Java/ObjC), you must design your API to fit within gobind’s supported types. The **supported types subset** was discussed earlier ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=All%20exported%20symbols%20in%20the,Supported%20types%20include)), but to recap the practical differences:
- **Exported API shape** – Only exported (public) Go functions, methods, structs, and interfaces are considered for binding. Anything unexported is invisible to Java/ObjC. This is more restrictive than normal Go (where unexported code can still be used internally freely). Here, if it’s unexported, it might as well not exist from the Android side. So you might sometimes need to *export more than you normally would*, just so the Java side can trigger it. On the other hand, you might also create a more minimal API surface on purpose.
- **Data types** – You cannot return a Go map or channel or complex struct to Java; gobind will refuse. For example, a Go function returning a `map[string]int` will be skipped with a warning *“unsupported parameter or return types”*. You’d need to change your API to return, say, a slice of key-value pairs or a custom struct. In one Reddit example, a method was skipped because it had an unsupported parameter, confusing the developer until they realized the limitation ([Is this an undocumented GoMobile limitation? : r/golang - Reddit](https://www.reddit.com/r/golang/comments/17pafbd/is_this_an_undocumented_gomobile_limitation/#:~:text=Is%20this%20an%20undocumented%20GoMobile,unsupported%20parameter%20or%20return)). So, writing mobile-targeted Go often means simplifying types. Enums become integers or strings, sets become lists, etc., to fit the binding.
- **Error handling** – Go’s `error` type is supported in a special way: if a Go function returns `(T, error)`, gobind will convert that into either returning a value or throwing an exception in Java/ObjC. In Java, an `error` becomes a checked exception (actually a runtime exception) named `Exception`. This is quite convenient – it means you can use Go errors and they will appear as errors on the Java side ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=,in%20%27error%27%20type)). But one must remember that a panic in Go *cannot* be caught on the Java side; if a panic escapes, it will crash the app (the program will exit) ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=Exceptions%20and%20panics%20are%20not,boundary%2C%20the%20program%20will%20exit)). This differs from a desktop Go program where a panic unwinds the Go stack but not the whole OS process (you could recover). In GoMobile, a panic crossing to Java has no recovery, so avoid panicking across the language boundary.
- **Performance** – Each call from Java to Go (or vice-versa via reverse bind) goes through a JNI bridge. This has overhead compared to a normal Go function call. This isn’t a “language” difference per se, but it does mean you might structure code differently. For example, instead of many fine-grained calls crossing the boundary, batch work into fewer calls if possible to reduce overhead. The Go Mobile wiki notes that *“language bindings have a performance overhead”* and to be aware of it ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=,limitations%20of%20the%20target%20language)). In purely Go code on desktop, you wouldn’t think about crossing a language boundary at all.
- **Memory management** – In a normal Go app (Linux/Windows), you have just Go’s garbage collector. In GoMobile scenarios, you now have Go’s GC and the Java Dalvik/ART GC working concurrently. The binding system holds references to objects to keep them from being collected while still in use across the boundary ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=)). If you create a Go object and hand it to Java, GoMobile will keep a reference so it’s not freed, and vice versa. One consequence is the earlier warning: avoid reference cycles (Java object A holds Go object B, and B holds A) ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=For%20example%2C%20in%20Java%3A%20if,if%20they%20are%20otherwise%20unreachable)), or they will never be freed by either GC. This is a new consideration that typical Go programs don’t have – you normally rely on Go’s GC to handle cycles, but it can’t see into Java’s heap. Similarly, Java’s GC can’t see Go’s heap. This is a **unique constraint of GoMobile** development.

### Build and Toolchain Differences

From a build perspective, targeting Android/iOS alters the compilation process:
- **Cross-compilation** – With GoMobile, you are cross-compiling your code for GOOS=android (or ios) and various GOARCH (arm, arm64, etc.). Go’s cross-compiler does this behind the scenes. On a desktop Go build, you usually build for your own OS/arch unless you explicitly cross-compile. Here, cross-compiling is the norm and is orchestrated by `gomobile`. One practical difference: if you use cgo, Go needs access to the cross-compiler for C (the Android NDK’s clang). `gomobile init` takes care of setting up or locating these cross-compilers ([x/mobile: gomobile init not work · Issue #28449 · golang/go · GitHub](https://github.com/golang/go/issues/28449#:~:text=The%20help%20mentions%20the%20ANDROID_HOME,env%20var)). If you were to cross-compile manually (e.g., `GOOS=android GOARCH=arm go build -buildmode=c-shared`), you’d have to configure environment variables like `CC` to point to `arm-linux-androabi-clang`. GoMobile spares you that hassle.
- **Linking** – On Android, Go code is linked into a `.so` shared library. On desktop, you typically link into an executable. This means certain things like internal linking vs external linking might differ. When building a `.so` for Android, GoMobile uses `-buildmode=c-shared` (for AAR) ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=Bindings%20require%20additional%20Go%20code,command)). When building a framework for iOS, it uses `-buildmode=c-archive` (packed into a .framework) ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=Bindings%20require%20additional%20Go%20code,command)). These build modes produce different artifacts than the usual executable. It’s mostly transparent to you, but for example, initialization of the Go runtime is handled in a library context (the Go main function is not present unless you built an app).
- **Application lifecycle** – In a normal Go program, `main.main()` is the entry point and the program runs in a console or server environment. In an Android app using GoMobile, if you’re writing a library, there is no Go `main` – the Go code is invoked via JNI from the Android side. The Go runtime starts when the first call into Go happens (or when the .so is loaded). If you write a full Go app (via `gomobile build`), there *is* a Go `main`, but it’s not a standard one – you write it using the `app.Main(func(app.App){ ... })` construct from `x/mobile/app`, which hands control to the Go runtime on a separate thread while the Android UI thread is managed by the framework. Essentially, the Go program is embedded in the Android app lifecycle. Things like responding to onPause/onResume come via the `app` package events. This is clearly different from a typical Go program lifecycle. On desktop you might loop forever, on Android you yield control appropriately.

To sum up, **Go code intended for Android** via GoMobile is largely the same as Go code anywhere, *except* you must design your API with the limitations of the binding in mind and be mindful of the mobile context. Stick to supported types and patterns for anything that crosses into Java/ObjC. Use build tags if you have to include platform-specific code (for example, one file with `// +build android` that imports `"Java/android/..."` and another for desktop that doesn’t). Remember that your Go code will run inside a mobile app’s process, so things like UI must be done through the appropriate channels (Java UI toolkit or `mobile/app`), and you can’t just print to stdout expecting a console (you might use Android logging facilities via reverse bind or have your Go log messages appear in `logcat` by writing to stderr, which Android redirects to logcat by default).

In practice, many pure logic Go packages work on Android with *no changes at all*. It’s only when you expose them via gobind that you apply the type restrictions, or when you need to interact with the OS that you use mobile-specific imports.

## Pitfalls with Outdated Documentation and Deprecated APIs

GoMobile has evolved significantly, so using outdated documentation or deprecated APIs can lead to errors and frustration. It’s important to rely on the latest official docs (like the Go Mobile wiki and package docs) ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=Note%3A%20You%20need%20to%20have,4%20if%20using%20macOS%20Sierra)) ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=file%20can%20be%20imported%20using,prefix%20for%20the%20generated%20classes)). Here are some common issues that arise from outdated information, along with the symptoms you might encounter:

- **Installation via `go get` vs `go install`**: Older tutorials might instruct installing GoMobile with `go get`, or turning off Go modules (e.g., `GO111MODULE=auto`) ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=Tools%20developer)). As of Go 1.17+, the recommended way is `go install ...@latest`. If you use `go get` in module mode, you might inadvertently add `golang.org/x/mobile` to your go.mod or get an old version. Solution: use the official instruction – `go install golang.org/x/mobile/cmd/gomobile@latest` ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=To%20install%3A)) – to get the latest tool. This ensures you have the newest features and bug fixes.

- **Missing `gomobile init` or misconfigured NDK**: The `gomobile init` step is sometimes glossed over in docs but is crucial. Not running it can result in build errors like **“no such file or directory”** when the toolchain is not prepared. Always run `gomobile init` after installing the tool. Conversely, some outdated docs suggest `gomobile init` will automatically download the NDK. In the past, `gomobile init` *advertised* that it *“install[s] NDK toolchains”*, giving the impression it fetches the NDK for you ([x/mobile: gomobile init not work · Issue #28449 · golang/go · GitHub](https://github.com/golang/go/issues/28449#:~:text=Them%20the%20docs%20and%20the,will%20be%20installed%20for%20you)). In reality, modern GoMobile expects you to have the NDK (via Android Studio) and simply sets up the standalone toolchain from it. If you run `gomobile init` without an NDK in place, older versions might have silently done nothing (no output, leading you to think it worked when it hadn’t) ([x/mobile: gomobile init not work · Issue #28449 · golang/go · GitHub](https://github.com/golang/go/issues/28449#:~:text=that%20the%20NDK%20will%20be,installed%20for%20you)). Newer versions will error out clearly if NDK is missing (e.g., *“could not locate Android SDK”* or *“no usable NDK found”*). **Pitfall**: expecting `gomobile init` to do everything. **Solution**: Install Android NDK yourself and ensure `ANDROID_HOME` is set; use `gomobile init` just to configure.

- **Deprecated `-ndk` flag**: You might find old Q&A or guides telling you to run `gomobile init -ndk <path>` to point to your NDK. This was valid years ago. As of GoMobile 0.2+ (circa 2020), the `-ndk` flag is removed or ignored – the tool now auto-detects the NDK location. If you try to use it, you’ll get an error *“flag provided but not defined: -ndk”* ([go - no Android NDK found in $ANDROID_HOME/ndk-bundle nor in $ANDROID_NDK_HOME in Ubuntu 18.04 - Stack Overflow](https://stackoverflow.com/questions/61052574/no-android-ndk-found-in-android-home-ndk-bundle-nor-in-android-ndk-home-in-ubu/71654923#:~:text=%24%20gomobile%20init%20,gomobile%20build%20and%20gomobile%20install)). For example, a user following an old StackOverflow answer might do so and see that message. The fix is to simply ensure `ANDROID_HOME` is set and run `gomobile init` without flags, or set `ANDROID_NDK_HOME` if you have a very custom NDK path. In short, don’t use the `-ndk` flag; it’s deprecated.

- **Android environment variables changes**: Historically, one had to set both `ANDROID_HOME` (SDK path) and `ANDROID_NDK_HOME` (NDK path). Modern Android tooling uses `ANDROID_SDK_ROOT` and has NDK under the SDK directory. GoMobile’s recent updates mean it first checks `ANDROID_NDK_HOME` (if set, for backward compatibility) ([cmd/gomobile/env.go - mobile - Git at Google](https://go.googlesource.com/mobile/+/master/cmd/gomobile/env.go#:~:text=,return%20ndkRoot%2C%20nil)), then falls back to searching under `ANDROID_HOME/ndk/` for installed NDKs ([cmd/gomobile/env.go - mobile - Git at Google](https://go.googlesource.com/mobile/+/master/cmd/gomobile/env.go#:~:text=androidHome%2C%20err%20%3A%3D%20sdkpath,determined%20will%20be%20least%20preferred)). If you set `ANDROID_NDK_HOME` to an incorrect path or forget to install the NDK, you’ll get errors. Outdated documentation that insists on setting `ANDROID_NDK_HOME` may cause confusion – it’s no longer strictly required if your NDK is in the standard location. The official advice now is simply ensure the NDK is installed in the SDK. If you see an error about *“no usable NDK found”*, check that the NDK is installed and updated ([x/mobile: Gomobile is not compatible with modern Android SDKs and NDKs · Issue #52470 · golang/go · GitHub](https://github.com/golang/go/issues/52470#:~:text=NDK%20system%29%20,Staged%20Alias%20Headers%20as%20well)). If multiple NDKs are present, GoMobile picks the latest supported.

- **Using an unsupported API level**: Early GoMobile supported down to API 15 (Android 4.0.3). That was later bumped to API 16 as a minimum ([x/mobile: Gomobile is not compatible with modern Android SDKs and NDKs · Issue #52470 · golang/go · GitHub](https://github.com/golang/go/issues/52470#:~:text=,it%20is%20now)). If you tried to target an older device or specify `-androidapi=15`, it likely won’t work now. Also, very old devices (ARMv5 or MIPS architecture) aren’t supported by GoMobile (Go’s supported archs are arm (ARMv7), arm64, 386, amd64) ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=Note%3A%20Go%20Mobile%20runs%20on,devices%20is%20not%20yet%20supported)). Most documentation already stated that (e.g., MIPS not supported ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=Note%3A%20Go%20Mobile%20runs%20on,devices%20is%20not%20yet%20supported))), but it’s worth noting if someone digs up a 2015-era blog claiming Android 2.3 support – that’s obsolete. Today you can assume Android 4.1+ only.

- **“No exported names in the package” error**: This common error can stump newcomers. It often happens if you follow a tutorial but make a mistake like writing your Go functions lowercase (unexported), or if you run `gomobile bind` on the wrong package (e.g. a `main` package which doesn’t export anything). The error *“gomobile: no exported names in the package”* means gobind found nothing to bind ([go - Gomobile no exported names in the package - Stack Overflow](https://stackoverflow.com/questions/41847117/gomobile-no-exported-names-in-the-package#:~:text=I%20am%20trying%20to%20bind,ran%20as%20a%20go%20script)). Sometimes users see this even when they *do* have exports, due to a subtle issue: if the package name in source doesn’t match the import path, or if module replacements confuse it. But 99% of the time it’s an API design issue. Outdated documentation might not emphasize this, but current docs do: only a subset of types and only exported symbols will be available ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=All%20exported%20symbols%20in%20the,Supported%20types%20include)). **Solution**: Ensure you have at least one exported function/type with supported types. If you intended to bind multiple packages, note that `gomobile bind` takes only one package path. If you have a large project, consider making a single wrapper package that imports others and re-exposes APIs in one place, because `gomobile bind` won’t produce one AAR from multiple packages unless they’re all imported by the one you specify.

- **Reverse binding pitfalls**: The reverse binding feature (importing Java/ObjC in Go) is cutting-edge and not as documented in older guides. If you find an old thread about it, be cautious. For instance, reverse bindings require your Go package to import `"golang.org/x/mobile/bind/java"` (for Java) or similar magic. This is advanced and beyond the typical usage, but one might run into it following an outdated example. The symptom could be strange compile errors about not finding `Java/` import, or runtime issues if using an unmerged experimental patch. The official proposals #16876 and #17102 hold the details ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=For%20more%20details%20on%20binding,org%2Fissues%2F17102%20%28Objective%20C)). In short: rely on official examples (there are some in `x/mobile/example` for reverse-bind) rather than random blog code, as that area changed quickly.

- **Deprecated OpenAL/audio APIs**: GoMobile included some experimental packages like `x/mobile/exp/audio` and support for OpenAL (for game audio). The `gomobile init -openal` flag can build OpenAL from source. If you find references to an `audio` package or see older examples using OpenAL, know that these parts were experimental. Some may have been removed or changed. For example, a user trying to use `golang.org/x/mobile/exp/audio` might find it doesn’t compile or is in flux. The official current path for audio in GoMobile is not clearly established (developers often use platform APIs via reverse bindings). Thus, outdated docs on audio can lead to dead ends. The error messages vary (missing package, etc.). The best approach is to search the current `x/mobile` repository docs for how to handle audio or simply use Java/ObjC for audio and call Go for processing.

- **Bitcode on iOS**: (Though our focus is Android, if we mention iOS…) At one point, Xcode required bitcode in iOS apps. GoMobile’s iOS frameworks didn’t support bitcode initially, causing app store rejection. Documentation around 2015–2018 might not cover this. This was resolved by adding bitcode support, and later Apple dropped the bitcode requirement in 2022. But if using outdated info, one might worry about bitcode flags which are no longer an issue. If someone passes `-tags=ios,bitcode` or such based on old advice, it’s unnecessary now. Always check the date of guidance.

To avoid these pitfalls:
- **Follow the latest official documentation** – The Go wiki “Mobile” page and the package docs on go.dev reflect the current state (for example, noting module support and new target flags) ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=,under%20project%20directory%20works%20now)) ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=For%20,target%3Dandroid%2Farm%2Candroid%2F386)).
- **Keep GoMobile updated** – It’s not part of Go’s core, so run `go install ...@latest` periodically to get fixes. Many issues on GoMobile are fixed but only if you update (since it’s versioned separately).
- **Heed error messages** – They often hint at the solution. For instance, *“flag provided but not defined: -ndk”* clearly tells you that flag is not valid for your version ([go - no Android NDK found in $ANDROID_HOME/ndk-bundle nor in $ANDROID_NDK_HOME in Ubuntu 18.04 - Stack Overflow](https://stackoverflow.com/questions/61052574/no-android-ndk-found-in-android-home-ndk-bundle-nor-in-android-ndk-home-in-ubu/71654923#:~:text=%24%20gomobile%20init%20,gomobile%20build%20and%20gomobile%20install)). *“unable to find package X”* might hint you have a module import issue. *“skipped function Y”* in generated code indicates an unsupported type, so adjust your function signature.

By staying current and understanding the common gotchas listed above, you can avoid the traps of outdated information and ensure a smooth experience with GoMobile.

## Relationship Between GoMobile and the Go Toolchain

GoMobile is not a separate language or a fork of Go – it’s essentially a set of wrappers and tools that *extend* the Go toolchain for mobile development. Understanding how GoMobile interacts with the Go compiler and tools can demystify a lot of what happens during a build.

Key points about the relationship:

- **Uses the Go compiler**: All Go code is still compiled by the standard Go compiler (`cmd/compile` and `cmd/link`). GoMobile doesn’t provide a new compiler; it invokes `go build` under the hood, specifying the appropriate GOOS/GOARCH and build mode. For example, when we run `gomobile bind -target=android`, it internally might call something equivalent to:
  ```bash
  GOOS=android GOARCH=arm64 go build -buildmode=c-shared -o <tempdir>/arm64/libhello.so <package>
  GOOS=android GOARCH=arm   go build -buildmode=c-shared -o <tempdir>/arm/libhello.so <package>
  ... (and so on for x86, x86_64)
  ```
  and then bundle those .so files and Java stubs into an AAR. This is why certain Go versions are required – new build modes like `c-shared` were introduced in Go 1.5 and improved in later versions, enabling this workflow ([Go 1.5 is released - The Go Programming Language](https://go.dev/blog/go1.5#:~:text=packages%20as%20shared%20libraries%20to,design%20doc)) ([Go 1.5 is released - The Go Programming Language](https://go.dev/blog/go1.5#:~:text=The%20new%20darwin%2Farm64%20port%20and,not%20part%20of%20this%20release)).

- **Special build modes**: As mentioned, GoMobile relies on build modes that turn Go code into libraries. Normally, `go build` produces an executable (for `main` packages) or nothing (for libraries, you use them in other code). But with `-buildmode=c-shared` (for Android) and `-buildmode=c-archive` (for iOS), the Go compiler produces a shared object (.so) or a static archive (.a with accompanying header) that can be linked into foreign programs ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=Bindings%20require%20additional%20Go%20code,command)). These modes are part of the Go toolchain (run `go help buildmode` for a list). GoMobile is effectively a thin wrapper that selects these modes and handles the multi-arch glue.

- **NDK/Clang integration**: When Go compiles to Android/ARM, it might need to invoke the C compiler for any cgo parts or to link against Android system libraries (like linking against the Android libc, a.k.a. bionic). The Go linker can do internal linking for pure Go, but cgo might call clang. GoMobile sets up the environment so that the right cross-compiler (clang from NDK) is used for linking. The `gomobile init` step, for instance, can create stand-alone toolchains (this was how it worked historically) or configure paths so that when `go build` needs a compiler, it finds it ([x/mobile: gomobile init not work · Issue #28449 · golang/go · GitHub](https://github.com/golang/go/issues/28449#:~:text=The%20help%20mentions%20the%20ANDROID_HOME,env%20var)). If you were doing this manually, you’d set `CC=$ANDROID_HOME/ndk/…/clang --target=armv7a-linux-android16` and similar flags. GoMobile automates that.

- **`adb` and deployment**: The `gomobile install` command uses the Android Debug Bridge (adb) to install and run the APK on a device ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=If%20you%20have%20the%20adb,APK%20to%20your%20mobile%20device)). This isn’t part of the Go toolchain at all – it’s an external Android tool. GoMobile simply calls out to it (assuming it’s on your PATH). This shows GoMobile’s role as a *convenience wrapper* around not just Go build, but also around platform-specific tools (adb for Android, Xcode codesign and deployment for iOS).

- **Go toolchain modifications**: The GoMobile project occasionally requires changes or proposals in the main Go toolchain. One example was support for **external linking on Darwin/arm64** which was necessary to build iOS/Mac frameworks. The Go team implemented those in Go 1.5 and later partly to enable GoMobile use cases ([Go 1.5 is released - The Go Programming Language](https://go.dev/blog/go1.5#:~:text=packages%20as%20shared%20libraries%20to,design%20doc)) ([Go 1.5 is released - The Go Programming Language](https://go.dev/blog/go1.5#:~:text=more%20mature%20new%20ports%20are,PowerPC%2C%20big%20and%20little%20endian)). Another example is the addition of `-buildmode=c-archive` and `-buildmode=c-shared` which were described in a design doc and implemented to allow “Go packages to be linked into C programs” ([Go 1.5 is released - The Go Programming Language](https://go.dev/blog/go1.5#:~:text=GOMAXPROCS%20%C2%A0value%20,21)) – GoMobile leverages exactly that capability but for Java/ObjC programs. So, there is a close synergy: GoMobile’s needs have driven some Go toolchain features, and in turn GoMobile is built entirely on those features.

- **No runtime differences**: The Go code that runs on Android uses the same Go runtime (garbage collector, scheduler) as it would on Linux/amd64, just compiled for ARM/ARM64. There are some conditional bits – for instance, the garbage collector might have tuning for mobile (like different default GOMAXPROCS on mobile devices, though since Go 1.5 it defaults to number of cores everywhere). By and large, there isn’t a “mobile version” of the runtime. If you encounter a bug in how Go behaves on Android, it’s likely a bug in Go’s Android port, not in GoMobile per se.

- **Compilation process**: When you run `gomobile bind`, after generating binding code, GoMobile uses the `go` command to compile. You can actually replicate parts of this yourself:
  - Gobind generates a Go file (say, `_gobind.go`) that contains scaffolding (this file imports `Java/java` packages if needed, and uses cgo with references to the Java VM, etc.). It then calls `go build` on a package that consists of your package + this generated file.
  - The Go compiler produces `.a` files for each package for each arch, and then the Go linker produces the `.so`.
  - For iOS, it might produce a `.a` archive (which then is combined into a framework). On iOS, multiple architectures (arm64, x86_64) are combined using the `lipo` tool into one fat binary, or now they use the new XCFramework format to bundle them.
  - Java binding code compiled by `javac` is packaged into `classes.jar`. This is done by invoking `javac` on the generated Java source, which `gomobile bind` handles (it finds `javac` via JAVA_HOME).
  - Finally, the AAR is zipped up. If you run with `-v`, you can often see each step logged.

- **Original toolchain unchanged**: Importantly, using GoMobile does not require modifying your Go installation. It sits on top. You use it as an add-on. This is beneficial because you can update Go independently of GoMobile and vice versa. The coupling is only that certain Go versions might be required for certain GoMobile versions (e.g., new GoMobile might require at least Go 1.16 as noted) ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=%24%20gomobile%20init)).

- **Integration example**: The gobind docs note *“These details are handled by the `gomobile bind` command.”* when describing the manual steps of generating bindings and compiling with buildmodes ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=Bindings%20require%20additional%20Go%20code,command)). This highlights that `gomobile` is essentially orchestrating a sequence of standard build operations for you. If curious, you can look at the `gomobile` source (particularly `cmd/gomobile/bind.go`) – you’ll find it parsing flags, calling `gobind`, then calling `go build` with appropriate parameters for each target arch, then calling `jar`/`javac`, etc. ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=The%20build%20flags%20,documentation%2C%20see%20%27go%20help%20build)) ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=The%20named%20package%20must%20define,a%20main%20function)). It’s not doing any magic that the Go toolchain doesn’t support; it’s making the Go toolchain do the heavy lifting in a coordinated way.

In effect, **GoMobile is a layer on top of the Go toolchain**, plus some glue for mobile packaging. If you understand Go’s cross-compilation and linking options, you can see that GoMobile mostly just automates them and adds code generation. This is good news for reliability – it means improvements in Go (faster compiler, smaller binaries, new architectures like WASM, etc.) can benefit GoMobile without a complete rewrite.

As a final note, the GoMobile project’s code itself lives in a repository, and it depends on the Go toolchain. The relationship is such that sometimes you might need to use a matching version of GoMobile for a given Go release if something changes. But generally, they keep things compatible. The original question of *how does GoMobile relate to the Go compiler?* – the answer is: **it’s an add-on that uses the Go compiler as-is, extending its usage to mobile targets by generating binding code and packaging the results**. The original Go compiler doesn’t “know” about Android Studio or Xcode – GoMobile is the intermediary that translates Go packages into something those environments can use.

## References

- Go Mobile Project Wiki – *“Mobile”* (Go Wiki) ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=Note%3A%20You%20need%20to%20have,4%20if%20using%20macOS%20Sierra)) ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=Run%20,an%20Android%20APK)) ([Mobile · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/Mobile/33f9c0dcdedd09ab602abe75e02a6c6cbfe07256#:~:text=,limitations%20of%20the%20target%20language))  
- GoMobile Tool Documentation (golang.org/x/mobile/cmd/gomobile) ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=bind%20%20%20%20,print%20version)) ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=file%20can%20be%20imported%20using,prefix%20for%20the%20generated%20classes)) ([gomobile command - golang.org/x/mobile/cmd/gomobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile#:~:text=generated,target%3Dandroid%2Farm%2Candroid%2F386))  
- Gobind Tool Documentation (golang.org/x/mobile/cmd/gobind) ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=Gobind%20generates%20language%20bindings%20that,C)) ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=Bindings%20require%20additional%20Go%20code,command)) ([gobind command - golang.org/x/mobile/cmd/gobind - Go Packages](https://pkg.go.dev/golang.org/x/mobile/cmd/gobind#:~:text=,point%20types))  
- Go Blog: *“Go 1.5 is released”* – mentions the go mobile experiment ([Go 1.5 is released - The Go Programming Language](https://go.dev/blog/go1.5#:~:text=The%20new%20darwin%2Farm64%20port%20and,not%20part%20of%20this%20release))  
- Go Packages: `golang.org/x/mobile` – README and examples ([mobile module - golang.org/x/mobile - Go Packages](https://pkg.go.dev/golang.org/x/mobile#:~:text=%2A%20Building%20all,Building%20libraries%20for%20SDK%20apps)) ([hello package - golang.org/x/mobile/example/bind/hello - Go Packages](https://pkg.go.dev/golang.org/x/mobile@v0.0.0-20250408133729-978277e7eaf7/example/bind/hello#:~:text=Functions%20%C2%B6))  
- GitHub Issues and Commit Messages (GoMobile updates) – e.g., NDK path updates ([x/mobile: Gomobile is not compatible with modern Android SDKs and NDKs · Issue #52470 · golang/go · GitHub](https://github.com/golang/go/issues/52470#:~:text=,it%20is%20now)) ([x/mobile: Gomobile is not compatible with modern Android SDKs and NDKs · Issue #52470 · golang/go · GitHub](https://github.com/golang/go/issues/52470#:~:text=Image%3A%20%40gopherbot%20gopherbot%20%20closed,91))  
- Stack Overflow Q&A – illustrating common errors (no NDK found, no exported names) ([go - no Android NDK found in $ANDROID_HOME/ndk-bundle nor in $ANDROID_NDK_HOME in Ubuntu 18.04 - Stack Overflow](https://stackoverflow.com/questions/61052574/no-android-ndk-found-in-android-home-ndk-bundle-nor-in-android-ndk-home-in-ubu/71654923#:~:text=gomobile%20is%20not%20finding%20ndk)) ([go - Gomobile no exported names in the package - Stack Overflow](https://stackoverflow.com/questions/41847117/gomobile-no-exported-names-in-the-package#:~:text=I%20am%20trying%20to%20bind,ran%20as%20a%20go%20script))  

Each of these sources provides insight into different aspects of GoMobile’s usage and evolution, and together they form the basis of the information compiled in this report.