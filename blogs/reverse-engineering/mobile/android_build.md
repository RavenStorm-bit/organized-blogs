Awesome — I’ll put together a deep-dive breakdown of how an Android app is built under the hood, with a focus on native code integration (Rust, Go, C++), how AAR packages are structured and built, and what Android Studio does behind the scenes (including the implicit build structure and conventions).

I’ll be back with a full breakdown that demystifies the whole pipeline — from source to APK or AAR — and shows how all the pieces fit together.

# Android Build Pipeline with Native Code (Rust, Go, C++) #

Building an Android app involves multiple steps that transform source code into a final APK (application) or AAR (library) package. Gradle (via the Android Gradle Plugin, AGP) orchestrates this pipeline by invoking compilers and tools for each source set (Java/Kotlin, C/C++/Rust/Go, Android resources) and then packaging the outputs. Below we break down the build process, the structure of Android Archive (AAR) libraries, typical project setup, and how native code written in C++, Rust, or Go integrates into the build.

## Overview: From Source Code to APK/AAR ##

**1. Source Compilation:** Gradle triggers language-specific compilers to turn source files into binary artifacts ([Gradle build overview  |  Android Studio  |  Android Developers](https://developer.android.com/build/gradle-build-overview#:~:text=A%20build%20system%20transforms%20your,organize%20and%20run%20these%20commands)). For example, Java/Kotlin code is compiled into JVM bytecode (`.class` files) by **javac** or **kotlinc**, while C/C++ code is compiled by **Clang** from the Android NDK. If native code is present in a module (e.g. in a `src/main/cpp` directory), the Android Gradle Plugin will invoke the NDK toolchain (via CMake or ndk-build) to build it into a **shared library** (`.so`) that can run on Android ([Add C and C++ code to your project  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/add-native-code#:~:text=Add%20C%20and%20C%2B%2B%20code,read%20JNI%20tips%20for%20Android)). Similarly, Android resource files (XML layouts, images, etc.) are processed by the **AAPT2** tool: first compiled into binary format, then linked into the final app resource table.

**2. Bytecode Enhancement:** Gradle may run additional bytecode tools such as **annotation processors** (for libraries like Dagger or Room) during compilation. After `.class` files are produced, the **D8 dexer** (and **R8** if code shrinking is enabled) converts the bytecode into Dalvik bytecode (`classes.dex`) suitable for the Android runtime ([JNI tips  |  Android NDK  |  Android Developers](https://developer.android.com/training/articles/perf-jni#:~:text=JNI%20is%20the%20Java%20Native,at%20times%20is%20reasonably%20efficient)). (Library projects producing an AAR skip the DEX step – their `.class` files are packaged directly into the AAR’s `classes.jar`.)

**3. Native Library Build:** For each ABI (CPU architecture) targeted, Gradle invokes the NDK build. When using CMake, Gradle passes the required flags (target ABI, API level, NDK paths) to CMake automatically using the Android toolchain file ([CMake  |  Android NDK  |  Android Developers](https://developer.android.com/ndk/guides/cmake#:~:text=The%20target%20ABI,supported%20ABIs%2C%20see%20Android%20ABIs)). It generates the native code library for **armeabi-v7a**, **arm64-v8a**, **x86**, etc., as needed. By default, all supported ABIs are built; you can restrict this with `abiFilters` in Gradle config ([CMake  |  Android NDK  |  Android Developers](https://developer.android.com/ndk/guides/cmake#:~:text=The%20target%20ABI,supported%20ABIs%2C%20see%20Android%20ABIs)). The result is one or more `.so` files (e.g. `libmynative.so`) per ABI, placed in Gradle’s intermediates and ultimately packaged into the APK under `lib/<ABI>/` (or into an AAR under `jni/<ABI>/`). Gradle’s `externalNativeBuild` mechanism uses the provided CMakeLists or Android.mk to compile and link native code and ties those tasks into the Gradle build lifecycle ([Add C and C++ code to your project  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/add-native-code#:~:text=,native%20library%20into%20the%20app)).

**4. Merging and Packaging:** Gradle then merges all inputs into the final output. For an **APK** (app), it combines the DEX files, compiled resources (and `resources.arsc` table), the app’s **AndroidManifest.xml** (merged with library manifests), assets, and the compiled `.so` libraries into one package. The APK is essentially a zip file containing `AndroidManifest.xml`, `classes.dex`, `resources.arsc`, `res/` directories, `lib/<ABI>/*.so` libraries, and asset files. The APK is then **signed** (debug or release keys) and aligned for distribution. For an **AAR** (library), Gradle packages the **un-dexed `.class` files** (in a `classes.jar`), the library’s **AndroidManifest.xml**, resources (`res/`), a resource symbol file (`R.txt`), consumer ProGuard rules if any, and any native `.so` libraries. These contents are packaged into a `.aar` (which is also a zip archive) ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#aar-contents#:~:text=The%20file%20extension%20for%20an,AndroidManifest.xml)) ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#aar-contents#:~:text=,for%20%20218)).

**5. Variants and Build Types:** The build process above is repeated for each **build variant**. A typical project defines *build types* like **Debug** (with no/minimal optimization, debuggable) and **Release** (optimized, with shrinking/obfuscation) ([Gradle build overview  |  Android Studio  |  Android Developers](https://developer.android.com/build/gradle-build-overview#:~:text=Build%20types%20vary%20declared%20build,for%20staging%20or%20internal%20testing)). You might also define *product flavors* (e.g. "free" vs "pro") – Gradle will generate a variant for each combination (e.g. `freeDebug`, `freeRelease`, `proDebug`, `proRelease`) ([Gradle build overview  |  Android Studio  |  Android Developers](https://developer.android.com/build/gradle-build-overview#:~:text=AGP%20creates%20variants%20for%20each,AGP%20will%20create%20variants)). Each variant can have its own source sets and can produce a separate APK/AAR. Android Studio allows you to select the active variant, and Gradle ensures the correct sources, native libraries, and resources for that variant are built and packaged.

## Gradle Coordination with CMake and the NDK ##

Gradle’s Android plugin coordinates the native build using the `externalNativeBuild` block in the module’s `build.gradle`. You specify either a **CMake** build script or an **ndk-build** (Makefile) script. Gradle then handles invoking the native toolchain for each ABI and build type:

- **CMake Integration:** If a `CMakeLists.txt` is provided, Gradle will call CMake for each ABI, using the NDK’s custom toolchain file (`android.toolchain.cmake`). This toolchain file is responsible for configuring cross-compilation (e.g. it ensures the proper compiler, linker, sysroot for the target ABI are used) ([CMake  |  Android NDK  |  Android Developers](https://developer.android.com/ndk/guides/cmake#:~:text=The%20CMake%20toolchain%20file)) ([CMake  |  Android NDK  |  Android Developers](https://developer.android.com/ndk/guides/cmake#:~:text=Build%20parameters%20such%20as%20ABI%2C,see%20the%20Toolchain%20arguments%20section)). Gradle automatically sets CMake variables like `ANDROID_ABI` and `ANDROID_PLATFORM` based on your Gradle config (such as `abiFilters` and `minSdkVersion`) ([CMake  |  Android NDK  |  Android Developers](https://developer.android.com/ndk/guides/cmake#:~:text=The%20target%20ABI,supported%20ABIs%2C%20see%20Android%20ABIs)). **Do not** manually set these in your CMake; Gradle will provide them. You can pass additional CMake arguments via Gradle if needed (e.g. `android.defaultConfig.externalNativeBuild.cmake.arguments`).

- **ndk-build Integration:** If you use an `Android.mk`/`Application.mk`, Gradle can invoke **ndk-build** similarly. You would declare `externalNativeBuild.ndkBuild.path` to point to your Android.mk. Gradle then runs ndk-build for the ABIs. (Note: CMake and ndk-build cannot be used together in one module ([Add C and C++ code to your project  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/add-native-code#:~:text=Android%20Studio%20supports%20CMake%2C%20which,module%20is%20not%20currently%20supported)).)

During the Gradle configuration phase, the Android plugin defines tasks for native builds (e.g. `externalNativeBuildDebug`, `...Release`). These tasks ensure the native libraries are built before the APK/AAR packaging task runs. Gradle will also **parallelize** ABI builds where possible to speed up builds. After compilation, the output `.so` files for each ABI are copied into the appropriate packaging directories. Gradle takes care to include the correct `.so` for each ABI in the final APK or AAR. For example, if you build an APK with arm64-v8a and x86 support, the APK will contain `lib/arm64-v8a/mynative.so` and `lib/x86/mynative.so`. On the device, Android will load only the matching library for the device’s ABI at runtime.

## AAR Structure and Native Libraries ##

An **Android Archive (AAR)** is the output of a Library module. It contains all the pieces needed for another app or library module to consume that library. The **anatomy of an AAR** is as follows:

- **AndroidManifest.xml** – *Mandatory.* The library’s manifest (e.g. declaring any required permissions or components). When an app uses the AAR, this gets merged into the app’s manifest.
- **classes.jar** – *Optional (but present in most cases).* Compiled Java/Kotlin bytecode of the library (all the `.class` files). This is the library’s API and implementation in Java bytecode form.
- **res/** – *Optional.* Android resource files (layouts, drawables, etc.) packaged with the library.
- **R.txt** – *Optional.* A text file listing the resource IDs assigned to the library’s resources. This is used at compile time to ensure resource references are consistent (helpful for tooling and merging).
- **public.txt** – *Optional.* If present, declares which resources are marked as public API.
- **assets/** – *Optional.* Any asset files bundled with the library.
- **libs/** – *Optional.* Any Java `.jar` dependencies the library includes. (Normally, Gradle would handle dependencies separately, but AAR can embed additional jars if needed.)
- **jni/<abi>/** – *Optional.* Native libraries for one or more ABIs ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#aar-contents#:~:text=,supported%20ABIs%29%20%2A%20%60%2Fproguard.txt)). Each subdirectory (e.g. `jni/arm64-v8a/`) contains the compiled `.so` files for that ABI that the library provides. For example, an AAR that wraps a native C++ library might include `jni/arm64-v8a/libmynative.so`, `jni/x86/libmynative.so`, etc. When an app includes the AAR, these `.so` are extracted into the final APK.
- **proguard.txt** – *Optional.* Consumer ProGuard (R8) rules. If the library requires certain keep rules (for reflection or JNI), they can be provided here. Gradle will apply these rules to the app’s shrinker config automatically ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#aar-contents#:~:text=app%2C%20it%20uses%20the%20directives,library%20in%20a%20separate%20step)) ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#aar-contents#:~:text=,supported%20ABIs%29%20%2A%20%60%2Fproguard.txt)).
- **lint.jar** – *Optional.* Lint checks specific to the library.
- **api.jar** – *Optional.* Stub classes for APIs (used for compile-time only, rarely used).
- **prefab/** – *Optional.* Contains metadata for *Prefab* packages (C/C++ header and library packaging). We discuss this under native distribution.

**How native code is bundled in an AAR:** Just like an APK, an AAR can contain native .so libraries. These appear under the `jni/` directory as noted above. For example, using Go mobile bindings produces an AAR with `jni/abi/libgojni.so` inside ([cmd/gomobile/bind_androidapp.go - mobile - Git at Google](https://go.googlesource.com/mobile/+/master/cmd/gomobile/bind_androidapp.go#:~:text=%2F%2F%20AndroidManifest,jar%20%28optional%2C%20not%20relevant)). When you add a dependency on an AAR, Gradle will ensure these native libs are packaged into your app’s APK. **Important:** The AAR itself is not an installable app, so to test an AAR with native code you include it in an app project. At build time, the app’s packaging task will pick up the .so from the AAR and include it in the APK’s lib folder. At runtime, Android will be able to load the library via the same mechanism as if it were built directly in the app.

## JNI: Calling Native Code from Java/Kotlin ##

To expose native functionality to the Java/Kotlin layer, Android relies on the **Java Native Interface (JNI)**. JNI is a standard interface that allows Java bytecode to interact with native code (usually C/C++). On Android, JNI is the bridge between the Dalvik/ART managed world and your C/C++ (or Rust/Go) code ([JNI tips  |  Android NDK  |  Android Developers](https://developer.android.com/training/articles/perf-jni#:~:text=JNI%20is%20the%20Java%20Native,at%20times%20is%20reasonably%20efficient)). Key points about using JNI in Android:

- **Native Methods:** You declare “native” methods in Java/Kotlin, which have no implementation in Java but are linked to a function in the native library. For example, you might declare `public static native int doFoo(int x);` in Java. This tells the JVM that the implementation is in a native library.

- **Loading Libraries:** Before calling any native method, you must load the library containing it. This is done via `System.loadLibrary("mynative")` in a static initializer or at runtime. This call causes the Android runtime to load `libmynative.so` from the app’s library path. If multiple ABIs are packaged, the runtime will load the correct one for the device automatically ([Building and Deploying a Rust library on Android](https://mozilla.github.io/firefox-browser-architecture/experiments/2017-09-21-rust-on-android.html#:~:text=static%20%7B%20System.loadLibrary%28)). (For instance, on an arm64 device it loads `arm64-v8a/libmynative.so`.) It’s common to put a static block in your library class to load it, so the user doesn’t have to remember to load the native lib:

  ```java
  static {
      System.loadLibrary("mynative");
  }
  ```

  This will execute when the class is first used, ensuring the native library is loaded into memory ([Building and Deploying a Rust library on Android](https://mozilla.github.io/firefox-browser-architecture/experiments/2017-09-21-rust-on-android.html#:~:text=static%20%7B%20System.loadLibrary%28)).

- **JNI Function Signatures:** By default, the native function that implements a Java `native` method must follow a naming convention: `Java_<Package>_<Class>_<method>(JNIEnv* env, jobject thiz, ...)`. For example, `Java_com_example_MyLib_doFoo(JNIEnv* env, jclass clazz, jint x)` would correspond to `MyLib.doFoo(int x)`. The JNI function receives a pointer to the JNI environment and the Java object (or class for static methods) as arguments, along with any parameters. **Alternatively**, you can use `JNI_OnLoad` and dynamic registration to map Java methods to arbitrary C function names, but the static naming approach is simpler for small libs.

- **JNI in Kotlin:** Because Kotlin compiles to Java bytecode, the JNI mechanism is identical. Your Kotlin `external fun foo(x: Int): Int` is equivalent to a Java native method.

- **Data interchange:** JNI provides APIs to convert between Java types and native types. For example, you can get a C string (`const char*`) from a `java.lang.String` using `GetStringUTFChars`, or create a Java `Bitmap` from native data. It’s important to minimize crossings between Java and native code – each call has some overhead ([JNI tips  |  Android NDK  |  Android Developers](https://developer.android.com/training/articles/perf-jni#:~:text=Try%20to%20minimize%20the%20footprint,beginning%20with%20the%20most%20important)). Best practice is to keep the JNI interface thin, doing larger computations on one side or the other rather than in many small cross-calls.

- **Using JNI with Rust/Go:** These languages can also interface via JNI (Rust can use the `jni` crate to call JNI functions, and Go’s gomobile tool hides JNI behind generated code). Regardless of language, at the end of the day a compiled `.so` library is loaded and JNI is the bridge to call into it from Java.

## Project Structure and Build Conventions ##

An Android Studio project is typically organized into one or more **modules** (e.g. an “app” module for your application, and possibly library modules). Each module has a *build.gradle* (or *build.gradle.kts*) and a standardized directory structure:

- **Source Sets:** The default source set is `src/main/`. Under this, you have `java/` (or `kotlin/`) for source code, `res/` for resources, `AndroidManifest.xml` for the app or library manifest, and possibly `assets/` and `jniLibs/`. For native code, the convention is to put C/C++ source in `src/main/cpp/` (Android Studio will create this by default for new C++ support) ([Add C and C++ code to your project  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/add-native-code#:~:text=Add%20C%20and%20C%2B%2B%20code,read%20JNI%20tips%20for%20Android)). Older projects might use `jni/` in place of `cpp/`, but both are recognized if configured. You can also have `src/<flavor>/` or `src/<buildType>/` directories for flavor-specific or build-type-specific overrides.

- **Gradle Build Files:** The module’s Gradle file uses the **Android plugin** (`com.android.application` for apps, `com.android.library` for libraries). In it, you declare `defaultConfig` (like applicationId, minSdkVersion, targetSdkVersion, versionCode, etc.), any build flavor dimensions and product flavors, and build types (which by default include “debug” and “release”). You also configure source sets or default file locations if you deviate from the convention. For native code, the `externalNativeBuild { cmake {...} }` section lives here, pointing to your CMakeLists and optionally setting ABI filters or other options.

- **Generated Files:** During build, Android Studio/Gradle generates files like **R.java** (in modern AGP, each library gets an `R.jar` instead, but conceptually this contains resource ID constants), and **BuildConfig.java** (a class with constants like the package name, version, and a DEBUG flag). These appear under the `build/generated/` folder for each variant. If you use libraries like Data Binding or View Binding, additional code is generated (e.g. binding classes). All these are packaged into the app or AAR as needed.

- **Intermediates and Outputs:** Gradle puts intermediate outputs in `build/intermediates/` (separate subfolders for processed resources, merged manifests, compiled R class, etc. for each build variant). Compiled APKs are output to `build/outputs/apk/` (or `outputs/bundle` for App Bundles, and `outputs/aar/` for library AARs). When native code is built, you'll find compiled objects and libs under `build/intermediates/cmake/<variant>/obj/<ABI>/` and packaged libs under `build/intermediates/merged_native_libs/`. Most of this is managed for you by the Android plugin.

- **Build Variants UI:** Android Studio provides a Variants panel to switch the active variant. This affects which source set is used and which APK is run. For example, if you switch to the “release” variant, Android Studio will compile with release config (which may turn off debug logging, use proguard, etc.) ([Gradle build overview  |  Android Studio  |  Android Developers](https://developer.android.com/build/gradle-build-overview#:~:text=Build%20types%20vary%20declared%20build,for%20staging%20or%20internal%20testing)). It will also build native code with release flags (e.g. `-O2 -DNDEBUG` for C++ by default). Each variant will have its own set of .so outputs. Gradle ensures that when you build an app, you only package one set of native libraries per ABI for that variant. If you need to deliver different packages for different ABIs, you can use **ABI splits** or App Bundle feature, but by default a single universal APK contains all ABIs.

## Integrating Native Code: C++, Rust, and Go ##

Android’s NDK was primarily designed for C and C++, but you can also include Rust or Go code in your app. The approaches share similarities (all produce native libraries), but the toolchains and integration methods differ:

### C/C++ with the NDK ###

Using C/C++ is the most straightforward with official support. You write your C/C++ source, typically including the JNI header (`jni.h`) for JNI functions or using NDK APIs. Key points:

- **Build Toolchain:** Android NDK provides a modified LLVM **Clang** compiler that targets Android ABIs. Gradle/Android Studio will download the NDK and CMake for you. The **CMake build script** (CMakeLists.txt) defines how to compile the sources into a library. When Gradle runs the build, it calls CMake with the Android toolchain, resulting in `.so` files. For example, placing native code in `cpp/` and adding a CMakeLists that creates a library will lead Gradle to compile it and package the `.so` ([Add C and C++ code to your project  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/add-native-code#:~:text=Add%20C%20and%20C%2B%2B%20code,read%20JNI%20tips%20for%20Android)).

- **Gradle Integration:** In `build.gradle`, you enable C++ support by pointing to your CMake script:

  ```groovy
  android {
      defaultConfig { 
          externalNativeBuild {
              cmake { cppFlags "-O2" } 
          }
      }
      externalNativeBuild {
          cmake { path "src/main/cpp/CMakeLists.txt" }
      }
  }
  ``` 

  Gradle will **configure CMake** with the NDK paths, ABI list, and build type. After compilation, Gradle automatically packs the resulting `*.so` libraries into the APK or AAR. “ExternalNativeBuild” is a first-class part of AGP ([Add C and C++ code to your project  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/add-native-code#:~:text=Android,native%20library%20into%20the%20app)), so you typically don’t need custom scripts – just the CMakeLists and source files.

- **Linking and Libraries:** Your C/C++ code can use Android NDK libraries like `log` (for `__android_log_print`), `bitmap`, OpenGL ES, etc., by linking against them (e.g. `find_library(log-lib log)` in CMake and linking it). By default, the NDK uses the **`libc++` C++ standard library**, which can be linked statically or as a shared lib. If you build multiple libraries, you can either have each include its own C++ runtime or include one copy of `libc++_shared.so` in the final APK. Gradle will automatically package any dependent shared libs (except system libs) it finds in your build outputs.

- **JNI Interface:** You’ll typically write JNI functions in C/C++ to expose the native logic. For example, a C++ function `stringFromJNI` that returns a `jstring` can be called from Java. The C/C++ code sees `JNIEnv*` (to call back into Java if needed) and can use the rich JNI API. The performance is native-level for the C++ code itself, with a small overhead on each call crossing the boundary ([JNI tips  |  Android NDK  |  Android Developers](https://developer.android.com/training/articles/perf-jni#:~:text=JNI%20is%20the%20Java%20Native,at%20times%20is%20reasonably%20efficient)). C++ is often used for CPU-intensive tasks, math, graphics, or to use existing C/C++ libraries on Android.

### Rust Integration via JNI ###

Rust is not officially part of the NDK toolchain, but it can produce libraries that work on Android. Rust’s advantages (memory safety, performance) make it attractive for certain components. How to integrate Rust:

- **Build Toolchain:** You need Rust’s target triples for Android. Rustup can install targets like `aarch64-linux-android`, `armv7-linux-androideabi`, etc. Rust can compile a library for Android as a **cdylib** (C-compatible dynamic library). You must ensure the Rust compiler knows where the NDK libraries and linker are – this can be done by configuring cargo or using community tools. For example, Mozilla provides a Gradle plugin that automates calling `cargo build` for Android targets ([GitHub - mozilla/rust-android-gradle](https://github.com/mozilla/rust-android-gradle#:~:text=libname)) ([GitHub - mozilla/rust-android-gradle](https://github.com/mozilla/rust-android-gradle#:~:text=A%20list%20of%20Android%20targets,to%20build%20with%20Cargo%3B%20required)). Alternatively, you might manually call `cargo build --target=aarch64-linux-android` (and other targets) and copy the output libs.

- **Gradle Integration:** Since AGP doesn’t natively call Rust, a common approach is to use a **Gradle plugin or script**. The Mozilla **rust-android-gradle** plugin can be applied to run Cargo builds as part of Gradle ([GitHub - mozilla/rust-android-gradle](https://github.com/mozilla/rust-android-gradle#:~:text=Usage)) ([GitHub - mozilla/rust-android-gradle](https://github.com/mozilla/rust-android-gradle#:~:text=plugins%20%7B%20id%20%22org.mozilla.rust,)). You specify the Rust project path and targets, and it will produce `.so` files for each ABI and embed them in the APK/AAR. Another approach is to treat the Rust lib as a prebuilt: run cargo separately and drop the `.so` into `src/main/jniLibs/<abi>/`. Gradle will package any `.so` in `jniLibs` by default. This was demonstrated in a Mozilla example, where the Rust build outputs were symlinked into an Android Studio project’s `jniLibs` directories for each ABI ([Building and Deploying a Rust library on Android](https://mozilla.github.io/firefox-browser-architecture/experiments/2017-09-21-rust-on-android.html#:~:text=ln%20,android%2Frelease%2Flibgreetings.so%20jniLibs%2Fx86%2Flibgreetings.so)) ([Building and Deploying a Rust library on Android](https://mozilla.github.io/firefox-browser-architecture/experiments/2017-09-21-rust-on-android.html#:~:text=static%20%7B%20System.loadLibrary%28)).

- **JNI Binding:** Rust can interface with JNI either by writing functions with the JNI C signature or by using the [`jni` crate](https://docs.rs/jni) to create JNI functions in Rust. In practice, you might write Rust functions like:

  ```rust
  #[no_mangle]
  pub extern "C" fn Java_com_example_MyLib_doFoo(env: JNIEnv, clazz: jclass, x: jint) -> jint {
      // ... implement function in Rust ...
      return x * 2;
  }
  ```

  This is a JNI function that Java can call (if `MyLib.doFoo` is a native method). You can also use Rust’s powerful FFI to call into C or C++ libraries if needed. The Rust code is compiled into the same `.so` format, so from Java it’s indistinguishable from a C++ native library. You still load it with `System.loadLibrary` (e.g. `System.loadLibrary("mylib")`) and call the native methods. The process of loading and calling is identical ([Building and Deploying a Rust library on Android](https://mozilla.github.io/firefox-browser-architecture/experiments/2017-09-21-rust-on-android.html#:~:text=static%20%7B%20System.loadLibrary%28)).

- **Linking and Considerations:** Rust will link against Android’s libc (Bionic) and can link to other NDK libs (you can call NDK APIs by declaring `extern "C"` functions in Rust and linking, or use Rust crates that do so). Ensure that the Rust library’s **package name and library name** don’t conflict with others – the `.so` name is usually `lib<name>.so` based on your Cargo package. The Gradle plugin uses the `libname` you provide to include the correct files in the AAR/APK ([GitHub - mozilla/rust-android-gradle](https://github.com/mozilla/rust-android-gradle#:~:text=The%20library%20name%20produced%20by,Cargo%3B%20required)). One caveat: Rust’s standard library and dependencies will bloat the binary somewhat (though still reasonably small). You should also strip debug symbols from the release builds (Cargo does this in release by default) or use split debug info. In terms of performance, Rust can achieve similar speed to C++ with better memory safety, at the cost of a more complex build setup.

### Go Integration (via Go Mobile) ###

Go is another language that can target Android. Go is not normally used for Android app development, but the Go team provides **Go Mobile** tools that make it possible to write libraries (or even entire apps) in Go. There are two primary ways to use Go in an Android app: 1) build an `.so` library with exported C functions, or 2) use the `gomobile bind` tool to create an AAR with idiomatic Java bindings for Go code.

- **Build Toolchain:** Go has cross-compilation support. By setting `GOOS=android` and `GOARCH` for the ABI, you can compile a Go package. However, simply producing a raw binary isn’t enough – for Android you usually build a shared library. If you use `go build -buildmode=c-shared`, Go will produce a `.so` file and a C header file. That `.so` includes the Go runtime and your code, and you could call its functions via JNI or C directly. The easier method is to use **gomobile**, which automates this and generates Java stubs. Install it with `go install golang.org/x/mobile/cmd/gomobile@latest` and run `gomobile init` ([Go Wiki: Mobile - The Go Programming Language](https://go.dev/wiki/Mobile#:~:text=You%20need%20to%20have%20Go,above%20to%20install%20mobile%20tools)).

- **gomobile bind (Recommended):** Using `gomobile bind` is the high-level approach. It takes a Go package and generates an AAR for you. For example: `gomobile bind -v -o hello.aar -target=android my/go/package` will produce an `hello.aar` library ([Go Wiki: Mobile - The Go Programming Language](https://go.dev/wiki/Mobile#:~:text=You%20need%20to%20have%20Go,above%20to%20install%20mobile%20tools)) ([Go Wiki: Mobile - The Go Programming Language](https://go.dev/wiki/Mobile#:~:text=%24%20gomobile%20bind%20,org%2Fx%2Fmobile%2Fexample%2Fbind%2Fhello)). This AAR will contain:
  - A `classes.jar` with Java classes (and interfaces) that mirror the Go package’s exported functions/types.
  - The compiled native library (typically named `libgojni.so`) under `jni/<abi>/` for each ABI ([cmd/gomobile/bind_androidapp.go - mobile - Git at Google](https://go.googlesource.com/mobile/+/master/cmd/gomobile/bind_androidapp.go#:~:text=%2F%2F%20AndroidManifest,jar%20%28optional%2C%20not%20relevant)).
  - The required AndroidManifest (often minimal or none).
  
  You can then simply include this AAR in your Android Studio project (as a module or Maven artifact). The generated Java classes internally use JNI to call into the Go runtime. For example, if your Go package has a function `func Add(x int, y int) int`, gomobile will create a Java class with a method `int Add(int x, int y)` that calls the native lib. From the Android developer perspective, you just call those methods as if they were normal Java code; the heavy lifting of JNI is done in the background by the gomobile-generated code.

- **Manual integration via C:** The alternative is manual: write some Go code, compile with `c-shared`, then write JNI C/C++ code to call it. This is generally more complex because you must manage thread attachment to the Go runtime, etc. The Go mobile bindings avoid these pitfalls by managing a single Go runtime instance and exposing high-level APIs. Given that, **gomobile is the best practice** for using Go in an Android app, unless you have very specific needs.

- **Gradle Integration:** There isn’t a native Gradle task for Go, so usually you run `gomobile` externally. However, you can script it via Gradle (e.g., a Gradle task that executes the gomobile command to regenerate the AAR whenever the Go code changes). Once you have the AAR, you treat it like any other library – put it in your project’s libs and add `implementation files('hello.aar')` or publish it to a Maven repo for reuse.

- **Go Runtime and Performance:** The `.so` generated by Go will include the Go runtime (garbage collector, scheduler, etc.). This makes it relatively large compared to a pure C++ `.so`. Also, calling into Go has overhead similar to JNI (plus Go <-> C calls overhead). One should be cautious to not frequently jump between Java and Go for trivial things. That said, Go is perfectly capable of intensive tasks and can make use of multiple CPU cores easily (since it has goroutines). Keep in mind that you now have two garbage-collected runtimes (ART and Go’s) in one process, which is unusual but manageable.

### Comparison of Approaches ###

Each language offers different workflows. The table below summarizes how C++, Rust, and Go integrate into an Android build:

| **Language** | **Toolchain & Build** | **Gradle Integration** | **Native Output** | **Java/Kotlin Interface** |
| --- | --- | --- | --- | --- |
| **C/C++ (NDK)** | Uses Android NDK (Clang). Build with CMake or ndk-build scripts. | **Built-in support:** Gradle’s `externalNativeBuild` invokes CMake/ndk-build automatically ([Add C and C++ code to your project  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/add-native-code#:~:text=Android,native%20library%20into%20the%20app)). Minimal config needed aside from the build script. | `.so` libraries per ABI (packaged under `lib/<ABI>/` in APK or `jni/<ABI>/` in AAR) ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#aar-contents#:~:text=,for%20%20218)). | Write JNI native methods in C/C++ and call them via Java `native` declarations ([JNI tips  |  Android NDK  |  Android Developers](https://developer.android.com/training/articles/perf-jni#:~:text=JNI%20is%20the%20Java%20Native,at%20times%20is%20reasonably%20efficient)). Typically manual JNI code. |
| **Rust** | Uses Rust compiler (`rustc`) with Android targets (e.g. `aarch64-linux-android`). Must link with NDK stub libraries for system calls/JNI. | **Custom integration:** e.g. use Mozilla’s Gradle plugin to run Cargo ([GitHub - mozilla/rust-android-gradle](https://github.com/mozilla/rust-android-gradle#:~:text=libname)), or run `cargo build` externally. Gradle doesn’t natively know Rust, but plugins can bundle the Rust `.so` into the APK/AAR. | `.so` libraries per ABI (produced by Cargo). These can be packaged just like C++ libs (into `jni/<ABI>/` for AAR). The library name (Cargo crate name) is used for the `.so` and should be loaded via that name ([GitHub - mozilla/rust-android-gradle](https://github.com/mozilla/rust-android-gradle#:~:text=The%20library%20name%20produced%20by,Cargo%3B%20required)) ([Building and Deploying a Rust library on Android](https://mozilla.github.io/firefox-browser-architecture/experiments/2017-09-21-rust-on-android.html#:~:text=static%20%7B%20System.loadLibrary%28)). | Use JNI as the bridge. Commonly, use the Rust `jni` crate to implement JNI functions or call Java from Rust. The Java side calls `System.loadLibrary` on the Rust lib and uses native methods. From Java it’s the same as calling a C++ lib via JNI. |
| **Go** | Uses Go compiler with mobile support. Go 1.x can cross-compile to Android; the `gomobile` tool automates this. | **Custom integration:** Use `gomobile bind` to generate an AAR (which you then include) ([Go Wiki: Mobile - The Go Programming Language](https://go.dev/wiki/Mobile#:~:text=Go%20Mobile%20introduces%20a%20tool%2C,build%20and%20the%20binding%20process)). Alternatively, script `go build` to produce .so and handle JNI manually. No first-class Gradle support, but AAR output makes it easy to consume. | `.so` libraries per ABI (including the Go runtime). With gomobile, an AAR is output containing `classes.jar` + `libgojni.so` ([cmd/gomobile/bind_androidapp.go - mobile - Git at Google](https://go.googlesource.com/mobile/+/master/cmd/gomobile/bind_androidapp.go#:~:text=%2F%2F%20AndroidManifest,jar%20%28optional%2C%20not%20relevant)). Without gomobile, you get a `.so` and a header for C calls. | With **gomobile**: a generated Java API is provided – you call Go code as if it were a normal Java library (gomobile uses JNI under the hood). Without it, you’d write JNI C/C++ code to call into the Go .so (complex). Most use gomobile for a clean interface. |

*(Sources: Android Developer docs for C/C++ integration ([Add C and C++ code to your project  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/add-native-code#:~:text=Add%20C%20and%20C%2B%2B%20code,read%20JNI%20tips%20for%20Android)) ([Add C and C++ code to your project  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/add-native-code#:~:text=Android,native%20library%20into%20the%20app)), AAR structure ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#aar-contents#:~:text=,for%20%20218)), JNI definition ([JNI tips  |  Android NDK  |  Android Developers](https://developer.android.com/training/articles/perf-jni#:~:text=JNI%20is%20the%20Java%20Native,at%20times%20is%20reasonably%20efficient)), Mozilla Rust-Android-Gradle docs ([GitHub - mozilla/rust-android-gradle](https://github.com/mozilla/rust-android-gradle#:~:text=libname)), Go Mobile documentation ([Go Wiki: Mobile - The Go Programming Language](https://go.dev/wiki/Mobile#:~:text=Go%20Mobile%20introduces%20a%20tool%2C,build%20and%20the%20binding%20process)), Go Mobile source showing AAR contents ([cmd/gomobile/bind_androidapp.go - mobile - Git at Google](https://go.googlesource.com/mobile/+/master/cmd/gomobile/bind_androidapp.go#:~:text=%2F%2F%20AndroidManifest,jar%20%28optional%2C%20not%20relevant)).)*

## Best Practices for Native Libraries in AARs ##

When building reusable AARs that include native code, consider the following guidelines to ensure consumers can use them effectively:

- **Hide JNI Behind a Java API:** It’s best to provide a clean Java/Kotlin interface to your native library. Consumers of your AAR shouldn’t need to know about the native code at all. For example, you might have a class `CryptoLib` with methods like `encrypt()` that internally call native methods. This way, consumers just add your AAR and use the `CryptoLib` API. Manage the `System.loadLibrary` call inside your library (e.g. in a static initializer) so the consumer doesn’t have to remember to load the native lib ([Building and Deploying a Rust library on Android](https://mozilla.github.io/firefox-browser-architecture/experiments/2017-09-21-rust-on-android.html#:~:text=static%20%7B%20System.loadLibrary%28)).

- **Include All Required ABIs:** Ensure you build and package `.so` for all Android-supported ABIs you intend to target (at least armv7, arm64, x86, x86_64; you may omit x86 if not needed, but arm64 and armv7 are critical for devices). The Gradle plugin will package all `.so` files under `jni/<abi>/`. When a consuming app builds, it will only pick the ones it needs (if the app restricts ABIs via `abiFilters` or splits). Missing an ABI will cause runtime crashes on devices of that ABI. If your library doesn’t support an ABI, document it clearly.

- **Use `consumerProguardFiles`:** If your native library relies on certain Java classes/method signatures (via JNI) or reflection, add ProGuard rules in a file and declare it in `consumerProguardFiles` in Gradle ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#aar-contents#:~:text=To%20add%20the%20ProGuard%20rules,file)) ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#aar-contents#:~:text=,supported%20ABIs%29%20%2A%20%60%2Fproguard.txt)). This ensures that when an app enables code shrinking, it won’t obfuscate or strip out things your native code needs. For example, if you call a Java method from native via reflection, mark it `-keep`. If you use JNI with method names, typically you keep class and method names as they are (the default ProGuard config keeps native method names, but be mindful).

- **Testing and Symbol Visibility:** Test your AAR by including it in a sample app on multiple architectures. It’s good to run on at least one 32-bit (armv7) and one 64-bit (arm64) device/emulator to ensure the packaged libs work. Strip debugging symbols from release builds (you can package a separate symbol file or use the Google Play symbol upload for native crash deobfuscation). Also, avoid exposing unnecessary symbols from your native library – use `extern "C"` only for JNI functions and keep the rest static or hidden if possible. This prevents name collisions if an app uses multiple native libs.

- **Prefab for C/C++ Consumption:** If you expect consumers of your AAR to write their own native code that needs to **link against your native library** (for example, your AAR provides a C function or you want to offer a C/C++ SDK in addition to the Java API), use **Prefab** to export headers and libraries. Prefab is a mechanism (supported since AGP 4.0/4.1) to package native headers and prebuilt libs inside an AAR in a standardized way ([Native dependencies with the Android Gradle plugin  |  Android Studio  |  Android Developers](https://developer.android.com/build/native-dependencies#:~:text=AAR%20dependencies%20of%20your%20Gradle,libraries%20of%20the%20native%20dependency)) ([Native dependencies with the Android Gradle plugin  |  Android Studio  |  Android Developers](https://developer.android.com/build/native-dependencies#:~:text=To%20export%20your%20native%20libraries%2C,file)). To use it, you enable `prefabPublishing` in your library module and specify which libraries/headers to export ([Native dependencies with the Android Gradle plugin  |  Android Studio  |  Android Developers](https://developer.android.com/build/native-dependencies#:~:text=buildFeatures%20,)) ([Native dependencies with the Android Gradle plugin  |  Android Studio  |  Android Developers](https://developer.android.com/build/native-dependencies#:~:text=prefab%20,)). This will place a `prefab/` directory in the AAR. Consumers can then add `prefab true` in their Gradle buildFeatures and use CMake’s `findPackage` to import your library ([Native dependencies with the Android Gradle plugin  |  Android Studio  |  Android Developers](https://developer.android.com/build/native-dependencies#:~:text=Each%20dependency%20exposes%20a%20config,should%20include%20the%20following)) ([Native dependencies with the Android Gradle plugin  |  Android Studio  |  Android Developers](https://developer.android.com/build/native-dependencies#:~:text=add_library%28app%20SHARED%20app)). For example, if your AAR (artifact name `mynative.aar`) exports a library `mylib`, a consumer’s CMakeLists could do: 
    
    ```cmake
    find_package(mylib REQUIRED CONFIG)    # Provided by your AAR via Prefab
    target_link_libraries(myAppLib PRIVATE mylib::mylib)
    ``` 
    
    This makes using your native library in other native code much simpler – Gradle will automatically provide the correct include paths and .so/.a files to the consumer’s build ([Native dependencies with the Android Gradle plugin  |  Android Studio  |  Android Developers](https://developer.android.com/build/native-dependencies#:~:text=add_library%28app%20SHARED%20app)). If you don’t use Prefab, the only way for a consumer’s native code to use your lib is to manually retrieve your headers and treat your .so as a shared library, which is clunky. So, consider Prefab if your audience includes C/C++ developers.

- **Versioning and Compatibility:** Native code can introduce ABI compatibility concerns. If you update your native library, it’s wise to keep the Java API stable. If breaking changes in the native code occur, reflect that in the version number of your AAR. Also, pay attention to the **NDK API level** you compile against. The `minSdkVersion` in Gradle will set the NDK platform API (e.g. android-21). If you use native APIs only available on newer Android releases, older devices will fail to load the library. Using the correct `minSdkVersion` (and testing on that API level) will ensure your native calls are available. The build system will link against the appropriate stubs for the minSdk. For example, if minSdk is 16, and you mistakenly use a function introduced in API 21, you’d get a runtime UnsatisfiedLinkError on old devices. Tools like `ndk-stack` and readelf can help verify your .so’s needed library symbols.

- **Documentation for Consumers:** Document the usage of your library, especially any initialization required. For instance, if an app needs to call an init method or handle special cases (like requesting permissions before calling into native code), make it clear. If multi-threading or specific CPU features (NEON, etc.) are involved, mention that too (Gradle/NDK will handle CPU feature variants if you split them, e.g. armeabi-v7a vs armeabi-v7a with NEON, but usually you rely on runtime CPU feature detection or assume baseline features).

By following these practices, an Android library with native components can be as easy to use as a pure-Java library. Gradle’s build pipeline and Android Studio’s support for C/C++ make it feasible to blend languages like C++, Rust, and Go into Android apps, each compiled to native code and packaged in the final APK or AAR. Using the official tools and configurations (Gradle + CMake, or language-specific tools like gomobile for Go) will streamline the process of going from high-level source code down to a fully built app with native capabilities.

**Sources:** The above information is based on official Android Developer documentation and trusted resources, including Android Studio project structure and library module guides ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#:~:text=An%20Android%20library%20is%20structurally,files%2C%20and%20an%20Android%20manifest)) ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#aar-contents#:~:text=The%20file%20extension%20for%20an,AndroidManifest.xml)), NDK integration guides ([Add C and C++ code to your project  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/add-native-code#:~:text=Add%20C%20and%20C%2B%2B%20code,read%20JNI%20tips%20for%20Android)) ([Add C and C++ code to your project  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/add-native-code#:~:text=Android,native%20library%20into%20the%20app)), JNI reference materials ([JNI tips  |  Android NDK  |  Android Developers](https://developer.android.com/training/articles/perf-jni#:~:text=JNI%20is%20the%20Java%20Native,at%20times%20is%20reasonably%20efficient)), and tool-specific docs for Rust and Go integration (Mozilla’s Rust plugin docs ([GitHub - mozilla/rust-android-gradle](https://github.com/mozilla/rust-android-gradle#:~:text=libname)) and the Go mobile wiki ([Go Wiki: Mobile - The Go Programming Language](https://go.dev/wiki/Mobile#:~:text=You%20need%20to%20have%20Go,above%20to%20install%20mobile%20tools))). These sources provide further detail on configuring Gradle, the build process, and best practices for native code in Android.