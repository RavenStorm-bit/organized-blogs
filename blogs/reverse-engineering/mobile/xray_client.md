Got it. I’ll dive into the full codebases of Xray-core, v2rayNG, and the wrapper repo to understand how Xray-core is compiled and integrated into the Android app.

I’ll provide a detailed annotated guide explaining:
- Key components and flow of each codebase.
- Whether Xray-core is compiled as a standalone executable or shared library.
- How it is compiled and embedded into Android apps, including the use of gomobile or any JNI bridge.
- How to compile Xray-core manually for Android (64-bit ABIs), with all build steps.
- How to interface with the compiled binary from a Java/Kotlin Android app.

I’ll break this down with clear explanations, code examples, and instructions for setting up your dev environment.

I’ll get back to you once the guide is ready.

# Introduction  
In this guide, we will explore three related codebases – **XTLS/Xray-core**, **v2rayNG (by 2dust)**, and **SaeedDev94’s Xray Android client** – to understand how they work and interconnect. Xray-core is a Go-based proxy/VPN core (a fork of v2ray-core with XTLS support ([XTLS - Project X](https://xtls.github.io/en/#:~:text=XTLS%20,core))), while v2rayNG and SaeedDev94’s Xray are Android client apps that use the core. We’ll break down the structure and key functions of each project, explain how Xray-core is integrated on Android (as a binary vs. a library), and detail how to build and interface with Xray-core on Android. This comprehensive guide will also cover the Android build environment, compilation steps for 64-bit ABIs (arm64-v8a, x86_64), and how an Android app can call into the Go code (via JNI or executables). 

**Repositories Covered:**

- **XTLS/Xray-core:** The core engine implementing protocols (VMess, VLESS, Shadowsocks, etc.), routing, and transports (TCP, WS, gRPC, etc.). This is written in Go and typically runs as a standalone service or embedded library.  
- **2dust/v2rayNG:** A popular Android client for V2Ray/Xray. It provides a GUI and VPN integration, and can use either Xray-core or v2fly (V2Ray) core ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=A%20V2Ray%20client%20for%20Android%2C,core%20%20and%20%2083)) ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=or%20using%20Gradle%20wrapper,and%20Makefiles%20for%20Go%20Developers)). It integrates the Go core via a library (AAR) built from the Go code.  
- **SaeedDev94/Xray:** Another Android GUI client for Xray-core ([GitHub - SaeedDev94/Xray: Xray GUI Client For Android](https://github.com/SaeedDev94/Xray#:~:text=Image%3A%20App%20Cover)). It has similar functionality (VPN support, sock5 proxy) and demonstrates an alternate integration approach, using an official wrapper library (libXray) and an included tun2socks component (`hev-socks5-tunnel`). 

We’ll examine each codebase’s structure and then focus on **how Xray-core is compiled and used on Android**, including whether it’s an executable or a shared library, the role of the gomobile tool and JNI, and how the Android clients invoke the Go functionality. 

# Xray-core Code Structure and Features (XTLS/Xray-core)  
**Xray-core** (in the XTLS/Xray-core repository) is the heart of these clients. It is a Go project that implements the “Project X” proxy platform. Key parts of Xray-core’s code structure include: 

- **Main Package:** The entry point (`main()` function) sets up the application. It typically reads a JSON config and starts the proxy services. In Xray-core, the main package ties together config parsing and launching of inbound/outbound handlers (the code is similar to v2ray-core, with added XTLS features).  
- **Config Loader:** Xray-core can load configuration in JSON form. The package `github.com/xtls/xray-core/common/serial` provides JSON parsing (e.g. `v2serial.LoadJSONConfig`) which the Android apps use to load user configs ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=func%20MeasureOutboundDelay,)).  
- **Core Components:** The core defines structures like `Instance` (often representing a running proxy instance) and various managers. For example, there are packages for routing, DNS, inbound proxies (socks, http, VLESS, etc.), outbound proxies (VMess, Trojan, Shadowsocks, etc.), and utilities for encryption (ciphers), obfuscation, mux, etc. Xray-core being a superset of v2ray-core means it inherits that modular design ([XTLS - Project X](https://xtls.github.io/en/#:~:text=XTLS%20,core)) and adds extras (e.g. XTLS).  
- **XTLS and REALITY:** Xray-core’s distinguishing feature is support for XTLS (a custom TLS encryption optimization) and REALITY (a new protocol). These are implemented in Xray-core’s codebase (e.g. under `transport/internet/xtls` for XTLS).  
- **Platform Abstractions:** Xray-core is primarily platform-agnostic. It reads config and opens network sockets. On Android, it doesn’t directly handle VPN or TUN; those are handled by the client app, which presents Xray-core with a standard networking environment (usually via a local SOCKS interface). 

**How Xray-core fits in:** In an Android app, Xray-core is not a full app by itself – it’s used as an engine to run proxies. Both v2rayNG and Saeed’s Xray *embed* Xray-core to handle the heavy lifting of proxying. The apps prepare a JSON configuration (based on user’s server selections and settings) and feed it to Xray-core, which then sets up all the proxy tunnels. For example, the app may tell Xray-core to listen on a local SOCKS5 port and forward traffic to a V2Ray/VLESS server. The core can then run entirely in the background, controlled via its API. 

# v2rayNG (Android Client) – Structure and Integration  
**v2rayNG** is an Android app (Kotlin-based) that provides a UI for managing proxies and uses Xray-core or V2Ray-core under the hood ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=A%20V2Ray%20client%20for%20Android%2C,core%20%20and%20%2083)). Key structural elements of v2rayNG include: 

- **UI and Config Management:** The app has Activities/Fragments for server list, connection settings, etc. It stores user profiles (server configs) and can generate a combined JSON for the core. For example, if you select a particular server, the app will build a JSON config with that server as an outbound, and likely include a local `socks` inbound for the VPN service to direct traffic into. 
- **VpnService:** v2rayNG uses Android’s VpnService API to capture device traffic. In the code, there is a class (e.g. `V2RayVpnService`) that extends `VpnService` ([v2rayNG - Apps on Google Play](https://play.google.com/store/apps/details?id=com.v2ray.ang&hl=en_US#:~:text=v2rayNG%20,or%20share%20personal%20information%2C)). When the user activates the VPN mode, this service creates a virtual TUN interface and routes device traffic into it. The app then needs to forward packets from this TUN to Xray-core. 
- **tun2socks Integration:** v2rayNG includes native components like **badvpn’s tun2socks** and **libancillary** (seen as submodules ([v2rayNG/.gitmodules at master · 2dust/v2rayNG · GitHub](https://github.com/2dust/v2rayNG/blob/master/.gitmodules#:~:text=match%20at%20L244%20%5Bsubmodule%20))). Tun2socks (from badvpn) is a C/C++ routine that reads packets from the TUN interface and forwards them to a SOCKS5 proxy. In v2rayNG’s build files, you can find scripts like `compile-tun2socks.sh` and a Makefile for tun2socks ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=compile)), indicating that it compiles tun2socks into a native library. At runtime, the VpnService likely calls into this native library (via JNI) and passes it the file descriptor of the TUN interface plus the address of a local SOCKS proxy. This way, all intercepted traffic is piped through a localhost SOCKS5 server.  
- **Core as a Library:** The “local SOCKS5 server” mentioned above is actually provided by Xray-core. v2rayNG doesn’t run Xray-core as a separate process; instead, it includes it as a **Java native library (AAR)**. The project’s README notes that *“the v2ray core inside the aar”* can be updated by compiling from the Golang project ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=or%20using%20Gradle%20wrapper,and%20Makefiles%20for%20Go%20Developers)). Specifically, v2rayNG uses the **AndroidLibXrayLite** project to produce an `aar` library containing Xray-core ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=outdated,and%20Makefiles%20for%20Go%20Developers)). This `.aar` includes the compiled Go code (.so for each ABI) plus Java stub classes to call Go. The v2rayNG app references this AAR (often named `libv2ray.aar`). In older versions, it was named libv2ray; in current versions it might be libxray. The development guide explicitly points to **Go Mobile (gomobile)** as the method to build this library ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=outdated,and%20Makefiles%20for%20Go%20Developers)). 
- **Wrapper Code (AndroidLibXrayLite):** Inside v2rayNG’s source (or submodules) there is wrapper code written in Go to interface with Xray-core. This is the **AndroidLibXrayLite** repository (added as a submodule ([v2rayNG/.gitmodules at master · 2dust/v2rayNG · GitHub](https://github.com/2dust/v2rayNG/blob/master/.gitmodules#:~:text=%5Bsubmodule%20))). AndroidLibXrayLite contains Go files like `libv2ray_main.go` and `libv2ray_support.go` ([GitHub - 2dust/AndroidLibXrayLite](https://github.com/2dust/AndroidLibXrayLite#:~:text=libv2ray_main)) which define a Go package `libv2ray` ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=package%20libv2ray)). This package uses Xray-core’s Go API: it calls into Xray-core to load configs and start/stop the service. For instance, it defines a struct `V2RayPoint` with methods like `RunLoop()` to start the core, `StopLoop()` to stop it, and `QueryStats()` to fetch statistics ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=func%20%28v%20,)) ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=func%20,int64)). It uses Xray-core’s libraries (imported via Go modules) – e.g. using `v2ray.com/core` (renamed under Xray’s module path) for Instance management, or `v2ray.com/core/serial` for config loading ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=func%20MeasureOutboundDelay,)). The Android app calls these Go methods through the generated Java interface. 
- **Lifecycle:** When the user taps “Connect” in v2rayNG, the app does roughly the following: start the VpnService (establish TUN), initialize the Go environment and config. They likely copy or open asset files like `geoip.dat` and `geosite.dat` (GeoIP and domain rule databases) – the README notes these should be placed under app data ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=)). Then, the app calls something like `Libv2ray.initEnv(pathToAssets)` (to set up file paths) and then `Libv2ray.startVpn(configJson)`. Under the hood, these calls invoke the Go `InitV2Env` ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=func%20InitV2Env,)) and `NewV2RayPoint(...).RunLoop()` functions, which start the Xray-core instance with the given config. The config will include an inbound SOCKS listening on 127.0.0.1 (for tun2socks to connect to) and the user’s outbound settings. At this point, tun2socks is pumping traffic into Xray-core’s SOCKS inbound, and Xray-core handles proxying that data out to the actual servers. 
- **Multi-Core Support:** v2rayNG can in theory use either Xray-core or v2fly’s v2ray-core. The README mentions support for both cores ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=A%20V2Ray%20client%20for%20Android%2C,core%20%20and%20%2083)). In practice, Xray-core (with XTLS) is often used. The AndroidLibXrayLite repo’s go.mod shows a dependency on `github.com/xtls/xray-core` at a specific commit ([AndroidLibXrayLite/go.mod at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/go.mod#:~:text=require%20)), meaning it’s using Xray-core. If someone wanted v2fly core, they’d use a similar AndroidLibV2rayLite (the app provided both as options historically). The integration mechanism is the same; only the underlying module differs. 

**Summary:** v2rayNG’s architecture has a clear separation: the Java/Kotlin code handles UI, VPN permissions, and starting/stopping the service; the Go library (via gomobile) runs the core proxy logic. This design avoids needing to spawn an external process. Everything runs inside the app’s process as a service. The key takeaway is that **Xray-core is compiled into v2rayNG as a shared library using gomobile** (with an AAR named `libv2ray.aar) ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=outdated,and%20Makefiles%20for%20Go%20Developers)), and the app invokes Go functions (start, stop, etc.) via that library. 

# SaeedDev94’s Xray Android Client – Structure and Integration  
SaeedDev94’s **Xray** app is another Android GUI client for Xray-core ([GitHub - SaeedDev94/Xray: Xray GUI Client For Android](https://github.com/SaeedDev94/Xray#:~:text=Image%3A%20App%20Cover)). It has similar functionality to v2rayNG (managing servers, running a VPN service), but the implementation details differ slightly: 

- **UI and Components:** The app is written in Kotlin (as indicated by `.kt` files in the repository). It contains a `service` package with classes like `TProxyService.kt` and `VpnTileService.kt` ([Xray/app/src/main/java/io/github/saeeddev94/xray/service at master · SaeedDev94/Xray · GitHub](https://github.com/SaeedDev94/Xray/tree/master/app/src/main/java/io/github/saeeddev94/xray/service#:~:text=TProxyService)). The `TProxyService` likely extends Android’s `VpnService`, similar to v2rayNG’s approach, to capture traffic. (The name suggests “Transparent Proxy Service”.) The `VpnTileService` is probably for Quick Settings tile support (to quickly toggle the VPN). There is also a `viewmodel` package (for managing UI state) and a `Settings.kt` for app preferences ([Xray/app/src/main/java/io/github/saeeddev94/xray at master · SaeedDev94/Xray · GitHub](https://github.com/SaeedDev94/Xray/tree/master/app/src/main/java/io/github/saeeddev94/xray#:~:text=Settings)). This structure follows modern Android architecture (UI + ViewModel + Service). 
- **Integration of Xray-core:** The Xray app also **embeds Xray-core as a library**, but it leverages the official **libXray** wrapper from XTLS. In the repo, under `XrayCore/` we see two submodules: `Xray-core` and `libXray` ([Xray/.gitmodules at master · SaeedDev94/Xray · GitHub](https://github.com/SaeedDev94/Xray/blob/master/.gitmodules#:~:text=match%20at%20L234%20%5Bsubmodule%20%22XrayCore%2FXray)). **libXray** is an official wrapper library that “improves the client development experience” for Xray-core ([GitHub - XTLS/libXray](https://github.com/XTLS/libXray#:~:text=%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)). Essentially, libXray provides a higher-level API on top of Xray-core, making it easier to start/stop the core and handle configurations in mobile apps. For example, libXray’s code includes `xray_wrapper.go` and `android_wrapper.go` which expose functions to start Xray with a given JSON config, to set asset paths, and to retrieve logs/stats ([GitHub - XTLS/libXray](https://github.com/XTLS/libXray#:~:text=%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)) ([GitHub - XTLS/libXray](https://github.com/XTLS/libXray#:~:text=You%20need%20to%20put%20Xray,the%20same%20directory%20to%20compile)). The SaeedDev94 Xray app likely uses libXray’s API instead of writing its own Go glue code. 
- **Building the AAR:** The repository contains a script `buildXrayCore.sh` to compile the core library via gomobile ([github.com](https://github.com/SaeedDev94/Xray/raw/refs/heads/master/buildXrayCore.sh#:~:text=mod%20tidy%20,check_target%20prepare_go%20build_android%20refresh_dependencies)). This script takes a target architecture as an argument (allowed ARCHs: arm, arm64, 386, amd64) ([github.com](https://github.com/SaeedDev94/Xray/raw/refs/heads/master/buildXrayCore.sh#:~:text=URL%3A%20https%3A%2F%2Fgithub.com%2FSaeedDev94%2FXray%2Fraw%2Frefs%2Fheads%2Fmaster%2FbuildXrayCore.sh%20%21%2Fbin%2Fbash%20TARGET%3D,replace%20github.com%2Fxtls%2Flibxray%3D.%2FlibXray%20%23%20go)) and then: (a) installs Go mobile toolchain, (b) runs `gomobile bind` to build an AAR for Android API 26 for that architecture ([github.com](https://github.com/SaeedDev94/Xray/raw/refs/heads/master/buildXrayCore.sh#:~:text=mod%20tidy%20,check_target%20prepare_go%20build_android%20refresh_dependencies)). The output is `app/libs/XrayCore.aar` ([github.com](https://github.com/SaeedDev94/Xray/raw/refs/heads/master/buildXrayCore.sh#:~:text=mod%20download%20%7D%20build_android%28%29%20,check_target%20prepare_go%20build_android%20refresh_dependencies)). This AAR package includes the compiled Xray-core + libXray code as a `.so` (native shared object) and generated Java classes. The script is designed to be run for each ABI – indeed the versioning scheme in the README indicates separate APKs per ABI (arm32, arm64, x86, x64) ([GitHub - SaeedDev94/Xray: Xray GUI Client For Android](https://github.com/SaeedDev94/Xray#:~:text=APK%20variants%20guide)). Each APK includes the corresponding `XrayCore.aar` (ensuring a smaller APK per platform and avoiding unused native binaries). This approach is similar to v2rayNG’s, except libXray is used internally. 
- **VPN and tun2socks:** Instead of badvpn, this project uses **hev-socks5-tunnel** (another tun2socks implementation). The repository’s `.gitmodules` shows a submodule for `app/src/main/jni/hev-socks5-tunnel` ([Xray/.gitmodules at master · SaeedDev94/Xray · GitHub](https://github.com/SaeedDev94/Xray/blob/master/.gitmodules#:~:text=%5Bsubmodule%20%22app%2Fsrc%2Fmain%2Fjni%2Fhev)). Hev-socks5-tunnel is a high-performance user-space TCP/IP stack that forwards TUN traffic to a SOCKS5 server. The app presumably compiles this C library (via NDK) and uses it similarly to how v2rayNG uses badvpn. In the app’s runtime, when `TProxyService` starts, it may create the TUN interface and then launch the hev-socks5-tunnel code (via JNI call or by loading the .so) to connect the TUN to a local socks. The local SOCKS5 server is provided by Xray-core’s inbound. The Xray app’s changelog (from an APK site) explicitly notes updates to hev-socks5-tunnel version ([Xray APK Download for Android - AndroidFreeware](https://www.androidfreeware.net/download-xray-apk.html#:~:text=%2A%20Updated%20hev,pressing%20the%20Quick%20Settings%20tile)), confirming this role. 
- **App Logic:** When a user starts the VPN, the app (likely via a ViewModel and the Service) will do something like: ensure the core AAR is loaded, use libXray to initialize (perhaps setting the asset directory for geo files), build a JSON config for Xray-core, and call `Xray.start(config)`. LibXray’s documentation suggests using a Python script to build, but at runtime it exposes functions such as `Run(configBytes []byte)` or similar via gomobile. The app then starts the native socks5 tunnel to forward traffic to `127.0.0.1:port` (the port configured in Xray-core’s inbound). At that point, Xray-core (running in-process via libXray) handles all outbound proxying. If the user chooses “proxy only” mode (like a regular SOCKS5 proxy without VPN), the app can skip the VpnService and just start Xray-core’s SOCKS server, allowing the user to set up proxy manually in other apps. In fact, the README mentions you can use it independently of Xray-core just as a SOCKS proxy (like SocksDroid) ([GitHub - SaeedDev94/Xray: Xray GUI Client For Android](https://github.com/SaeedDev94/Xray#:~:text=This%20is%20a%20simple%20GUI,Like%20SocksDroid)) – this implies the app can run *only* the tun->socks and not start Xray-core, or possibly run Xray-core in a mode where it’s just a local socks proxy (with no remote outbound, useful for local tunneling). 
- **Code Highlights:** The `Xray.kt` file likely contains high-level management code (perhaps an Application class or an object that coordinates starting/stopping the core). The `service/TProxyService.kt` will have the VPN service implementation, where you see calls such as `Builder()` to configure the VPN interface (addresses, routes) and code to start the native tunnel. The actual calling into the Go library might be abstracted in a class (sometimes projects have a Singleton to manage the libv2ray/libxray instance). For example, in similar projects, you’d see something like `LibXray.load()`, `LibXray.start(configText)`, etc., which under the hood call JNI to the Go library. 

**Summary:** SaeedDev94’s Xray app is architecturally similar to v2rayNG: an Android UI + VPN service wrapper around the Xray-core engine. The difference is using the official libXray wrapper and a different tun2socks component. In both cases, **Xray-core runs as a shared library inside the app’s process**, not as an external executable. The Android app calls functions of the Go library (through Java bindings). This design provides better control and stability on Android (since the VPN and core run in one process under Android’s management, and no separate binary execution is needed). 

# Xray-core on Android: Executable vs. Shared Library  
A central question is whether Xray-core is used as an **executable binary or a shared library** on Android. From the above analysis, both v2rayNG and Saeed’s Xray use it as a *shared library* (packaged in an AAR) rather than a standalone binary. Here’s what that means and why: 

- **Executable Option:** Because Xray-core is written in Go, it can be cross-compiled as a standalone Android binary (an ELF executable). In fact, official Xray-core releases often include Android builds (usually the file with no extension – e.g. `Xray-linux-64`, `Xray-android-64`). These are meant to be run from the command line. A user on GitHub queried if the Android Xray-core file (no extension) is a library for Android Studio or an executable ([Using X-Ray Core for Android · Issue #2808 · XTLS/Xray-core · GitHub](https://github.com/XTLS/Xray-core/issues/2808#:~:text=mistek131995%20%20%20commented%20,64)). The answer: it’s an executable. One can run it on Android (if you have a terminal or proper permissions) by invoking it with a config file, and it will create a proxy on 127.0.0.1 just like on desktop ([Using X-Ray Core for Android · Issue #2808 · XTLS/Xray-core · GitHub](https://github.com/XTLS/Xray-core/issues/2808#:~:text=Loading)). However, running an external process in an Android app context is tricky – you’d have to ship the binary (possibly in assets), copy it out, `chmod` it, and execute it via `Runtime.exec()`. Managing its lifecycle and capturing output would be complex. 
- **Library (Embedded) Option:** The preferred approach (used by these clients) is to compile Xray-core as a native **shared library (.so)** and call its functions directly. This is possible because Go can compile to shared libraries, and with the help of **gomobile** it can even auto-generate a Java interface. Both projects explicitly favor this method. For example, the maintainer of v2rayNG (yuhan) stated: *“gomobile is the way to go”* for using Xray-core on Android ([Using X-Ray Core for Android · Issue #2808 · XTLS/Xray-core · GitHub](https://github.com/XTLS/Xray-core/issues/2808#:~:text=yuhan6665%20%20%20commented%20,74)). Using gomobile, the Go code is packaged as an `.aar` library that Android Studio can consume. This library contains JNI bindings so that the Kotlin/Java code can invoke Go functions. In effect, **Xray-core runs in-process** as part of the app. 
- **Why a Shared Library:** Running in-process has multiple advantages on Android:
  - **Performance:** No overhead of starting a separate process or doing IPC. Function calls to the core are direct. 
  - **Control:** The app can call specific API methods (start, stop, get stats) rather than treating the core as a black-box process. For instance, v2rayNG’s integration can call `QueryStats()` on the Go library to get throughput statistics live ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=func%20,int64)), which would be harder if the core was a separate process. 
  - **VPN Integration:** The app needs to coordinate closely with the core for VPN features. By running inside the VPN service process, it’s easier to handle threading and ensure the core stops if the service stops. 
  - **Binary Size & ABI:** By using an .aar, you can bundle only the .so for the device’s ABI (with split APKs). If you tried to include a binary for every architecture, your APK would bloat. Or if you include only one (say arm64), then x86 users (emulators) cannot use the app. The library approach allows including multiple .so files under `lib/` in the APK. (v2rayNG historically had `libv2ray.aar` releases for each ABI that you could plug in ([libv2ray.aar v1.8.1 · Issue #13 · GFW-knocker/MahsaNG - GitHub](https://github.com/GFW-knocker/MahsaNG/issues/13#:~:text=on%20Sep%2028%2C%202023,com%2Fyuhan6665%2Fv2rayNG%2F)).) 
- **JNI and Gomobile:** Under the hood, using Go as a shared library means using the Java Native Interface (JNI). **gomobile** automates this. When you run `gomobile bind -target=android`, it generates:
  - A Java stub class (in a package `go.<yourpkg>`) with methods corresponding to your exported Go functions/types.
  - A compiled .so for each target ABI, which is a JNI library. The Java stub internally calls `System.loadLibrary("yourlib")` and then invokes native methods. The binding layer takes care of converting data types between Java and Go. You don’t write any manual JNI code – it’s all handled by gomobile. For example, AndroidLibXrayLite’s bind command produces an AAR where one of the classes is likely `Libv2ray` with methods like `startVPN(String json)` or similar, implemented natively. 
- **Confirmation in Code:** The v2rayNG README confirms an “aar” is used ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=or%20using%20Gradle%20wrapper,and%20Makefiles%20for%20Go%20Developers)). The build scripts we saw (for both projects) explicitly use `gomobile bind` ([github.com](https://github.com/SaeedDev94/Xray/raw/refs/heads/master/buildXrayCore.sh#:~:text=mod%20download%20%7D%20build_android%28%29%20,check_target%20prepare_go%20build_android%20refresh_dependencies)) to create a library. Thus, Xray-core is *not* launched via `Runtime.exec` or shell in these clients, but rather via direct function calls into the native code. 

In summary, **Xray-core on Android is integrated as a shared library in these apps (via gomobile), not as an external executable.** This design is recommended by the Xray developers themselves for Android use ([Using X-Ray Core for Android · Issue #2808 · XTLS/Xray-core · GitHub](https://github.com/XTLS/Xray-core/issues/2808#:~:text=yuhan6665%20%20%20commented%20,74)). (That said, advanced users could manually run the Xray-core binary on rooted devices or via Termux, but that’s outside our focus.) 

# How the Shared Library Mechanism Works (gomobile & JNI)  
Since both clients use the **gomobile** toolchain, let’s detail how Xray-core is turned into an Android-compatible library and how the Java/Kotlin code calls into it:

- **Go Mobile (gomobile):** This is a toolkit provided by the Go project (`golang.org/x/mobile`) to simplify mobile bindings. When you use `gomobile bind`, you specify a Go package, and gomobile will compile that package into:
  - An `.aar` (Android library bundle) for Android or a `.framework` for iOS, containing the compiled code and language bindings.
  - The AAR includes compiled `.so` libraries for each ABI and a `.jar` (or classes.jar) with the Java stub classes.
- **Exported Functions & Types:** Gomobile will expose only exported Go functions/types (name beginning with capital letter) from the package you bind. For example, in AndroidLibXrayLite’s `libv2ray` package, they have `func NewV2RayPoint(...) *V2RayPoint` ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=func%20NewV2RayPoint,V2RayPoint)) and methods on that type like `RunLoop()`, `StopLoop()` ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=func%20%28v%20,)) ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=func%20%28v%20,)). These become methods on a Java class (likely `V2RayPoint` in package `go.libv2ray`). Similarly, any simple function like `func InitEnv(path string)` would become a Java static method. In libXray’s case, they probably have a function like `Start(byte[] config)` that gets exposed. 
- **JNI Under the Hood:** The generated .so implements JNI functions that correspond to each Go function. For instance, a Go function `func RunLoop() error` might correspond to a JNI C function `Java_go_libv2ray_V2RayPoint_runLoop(JNIEnv*, jobject, ... )`. These call into the Go runtime to execute the Go code. All of this is invisible to the developer; you just call the Java method. 
- **Initialization:** Gomobile takes care of initializing the Go runtime on library load. When the Android app loads the .so (via `System.loadLibrary`), it sets up the Go environment. There is typically a hidden initialization step where the Go runtime is started on a new thread. This allows Go code to run concurrently with the Java UI thread. 
- **Threading:** One thing to note is that Go’s goroutines run inside the native .so. For example, Xray-core’s event loop (which listens for network connections, etc.) will run as goroutines. The Java side might just call `RunLoop()` which immediately returns (after spawning the goroutine), so the app might not block. The Go code will then call back into Java only if needed (e.g., logging callbacks, which can be set up via handler interfaces, or just printing to stdout which the app could capture if wired). The communication is mostly one-directional: app calls Go to start/stop. 
- **JNI vs. CGO alternative:** An alternative way to use Go in Android is to compile a `.so` with `-buildmode=c-shared`, which produces a C-callable library plus a generated C header. Then you’d manually write JNI code to call a `Run(config)` function from Java. The libXray project even notes that on Apple platforms, one can use a c-archive for integration ([GitHub - XTLS/libXray](https://github.com/XTLS/libXray#:~:text=But%20it%20is%20not%20possible,it%20does%20not%20support%20tvOS)). However, gomobile simplifies this greatly for Android by auto-generating everything. Both v2rayNG and Saeed’s Xray opt for gomobile (which uses JNI internally) – thus no manual JNI code appears in their repos; all native interface code is auto-generated in the AAR. 

**Conclusion:** The Android apps treat Xray-core almost like any other library. From a developer’s perspective, after running gomobile, they get a JAR with classes such as `XrayCore` or `Libv2ray`. They include this in their Gradle dependencies (placing the AAR in `app/libs/` and adding `implementation files('XrayCore.aar')`). Then they can do, for example: 

```kotlin
// Pseudocode example of how the integration might look:
import go.libv2ray.Libv2ray  // (package name depends on how gomobile named it)
...
val configJson = generateConfigJson()  // the app creates a JSON string for Xray-core
Libv2ray.initV2Env(appContext.filesDir.path, "")  // initialize environment, e.g., set asset path
val vpnServiceSupport = object : V2RayVPNServiceSupports { ... } 
val coreInstance = Libv2ray.newV2RayPoint(vpnServiceSupport, enableDns = true) 
coreInstance.runLoop(false)  // start the core in a background goroutine
...
// Later, to stop:
coreInstance.stopLoop()
``` 

*(The above is illustrative – in practice the actual class/method names may differ. For instance, libXray might expose a simpler API like `Xray.run(configBytes[])`.)* 

From the code snippet in AndroidLibXrayLite, we see `NewV2RayPoint` and `RunLoop` being used, and even a `MeasureDelay` function to test latency ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=match%20at%20L1121%20func%20,int64%2C%20error%29)) ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=func%20%28v%20,)). This rich API is available thanks to the Go wrapper layer. 

**Using the Core as an Executable:** For completeness, if one did choose to use Xray-core as a standalone executable on Android, the approach would be:
  - Cross-compile Xray-core for Android (we will explain how in the next section).
  - Bundle the binary in the APK (perhaps in assets). On first run, copy it to a writable area (like `/data/data/<app>/xray`).
  - Make it executable (`chmod 700`).
  - Use `ProcessBuilder` or `Runtime.getRuntime().exec(["/data/data/…/xray", "-config", "/data/data/…/config.json"])` to launch it. You must also pass the file descriptor of the tun interface if running under VPN mode. This might be done by having Xray-core listen on a file descriptor or using the `protect()` API to allow the core’s outbound sockets to bypass the VPN. (v2ray core has an option to protect socket, often the UI calls VpnService.protect on the socket FDs; doing that in an external process is complicated.)
  - Monitor the process output for logs or use a callback. And ensure to kill the process when VPN disconnects. 

Given these complexities, it’s evident why the shared library method is preferred in client apps. 

# Compiling Xray-core for Android (ARM64, x86_64)  
Compiling Xray-core (Go code) for Android involves cross-compiling to the target ABI. Here we detail both the **gomobile approach** and a manual Go build approach, focusing on 64-bit ABIs like **arm64-v8a** and **x86_64** (since Google requires 64-bit support on modern apps). 

## Development Environment Setup  
To build Xray-core for Android, you need the following tools and environment: 

- **Go Compiler:** Install Go (the version should be fairly recent; both projects in 2025 are likely using Go 1.20+). Ensure `$GOROOT` and `$GOPATH` (if needed) are set, and `$PATH` includes Go’s bin directory. 
- **Java JDK and Android SDK:** Needed to build the .aar and for gomobile to find Android tools. Install the Android SDK (for example via Android Studio). You specifically need: 
  - **Android NDK** (Native Development Kit) – required by gomobile to compile C/C++ parts and to link the .so. 
  - Android Build-Tools and Platform SDK (at least API level 26 or above, since our target is Oreo in these projects ([Xray APK Download for Android - AndroidFreeware](https://www.androidfreeware.net/download-xray-apk.html#:~:text=Package%20Name%20io,com%2FSaeedDev94%2FXray))). 
- **gomobile Tool:** This is a Go package. You install it by running: `go install golang.org/x/mobile/cmd/gomobile@latest`. Both projects pin specific versions; for example, Saeed’s script installs gomobile at a certain commit ([github.com](https://github.com/SaeedDev94/Xray/raw/refs/heads/master/buildXrayCore.sh#:~:text=mod%20tidy%20,trimpath)). After installing, initialize gomobile with `gomobile init`. This downloads or configures the NDK and other necessary components. (Make sure the environment variable `ANDROID_HOME` or `ANDROID_SDK_ROOT` points to your SDK, and `ANDROID_NDK_HOME` or `NDK_HOME` to the NDK path, if `gomobile init` doesn’t find them automatically.)  
- **C Compiler (if needed):** If you plan to build the binary with CGO (for example, if integrating tun2socks in-process, or building with CGO enabled), ensure you have a cross-compiler. Gomobile abstracts this, but if manually building with `GOOS=android`, you might need the appropriate GCC/Clang from the NDK. 

## Building via gomobile (AAR library method)  
Using gomobile is straightforward once the environment is ready. Here’s a step-by-step guide, which aligns with AndroidLibXrayLite’s instructions and SaeedDev94’s build script: 

1. **Get the Source Code:** You need the Xray-core code and optionally the libXray or wrapper code. For libXray approach, place `xray-core/` and `libXray/` in the same directory as instructed ([GitHub - XTLS/libXray](https://github.com/XTLS/libXray#:~:text=We%20will%20not%20answer%20questions,by%20using%20other%20compilation%20methods)). For the v2rayNG approach, clone the AndroidLibXrayLite repository which already references Xray-core in `go.mod`. For example:  
   ```bash
   git clone https://github.com/2dust/AndroidLibXrayLite.git && cd AndroidLibXrayLite
   ```  
   This project’s go.mod will fetch Xray-core automatically (at the version they pinned ([AndroidLibXrayLite/go.mod at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/go.mod#:~:text=require%20))). If using libXray, clone libXray and initialize its submodules to get Xray-core. 

2. **Install Go Mobile and Initialize:**  
   ```bash
   go install golang.org/x/mobile/cmd/gomobile@latest  
   gomobile init 
   ```  
   The `gomobile init` needs to be done once. It prepares the toolchain for Android (it may download an NDK if not found). *(In Saeed’s script, they do `gomobile init` each time just to be safe ([github.com](https://github.com/SaeedDev94/Xray/raw/refs/heads/master/buildXrayCore.sh#:~:text=mod%20download%20%7D%20build_android%28%29%20,trimpath)).)* 

3. **Tidy and Prepare Go Modules:** (Not always required, but good practice)  
   ```bash
   go mod tidy
   ```  
   Ensure dependencies (like Xray-core) are downloaded. In AndroidLibXrayLite’s README, they include this step ([GitHub - 2dust/AndroidLibXrayLite](https://github.com/2dust/AndroidLibXrayLite#:~:text=1.%20%60git%20clone%20,w%27)). 

4. **Build the AAR:** Use `gomobile bind`. For example, to build an AAR that targets **arm64-v8a**:  
   ```bash
   gomobile bind -v -target=android/arm64 -androidapi=26 -o XrayCore.aar .
   ```  
   This assumes your current directory is a Go module with the wrapper code (like AndroidLibXrayLite or libXray). The `-androidapi 26` flag sets the minimum SDK version (Oreo) ([github.com](https://github.com/SaeedDev94/Xray/raw/refs/heads/master/buildXrayCore.sh#:~:text=mod%20download%20%7D%20build_android%28%29%20,check_target%20prepare_go%20build_android%20refresh_dependencies)). You can target multiple ABIs by comma-separating (e.g. `-target=android/arm64,android/386,android/amd64,android/arm`). If you do that, the AAR will contain multiple .so files (one for each). However, note that combining x86 and arm in one AAR might increase size; projects often build separate AARs per ABI for distribution. For development, a combined AAR is fine. The `-ldflags='-s -w'` in some scripts strips debug info to reduce size ([GitHub - 2dust/AndroidLibXrayLite](https://github.com/2dust/AndroidLibXrayLite#:~:text=2.%20,w%27)). 
   
   **Expected output:** A file like `XrayCore.aar` (or `libv2ray.aar`). Inside this AAR (which is just a zip), you’d find:  
   - `/jni/arm64-v8a/libxraycore.so` (name depends on package – could be `libLibv2ray.so` or similar)  
   - `/classes.jar` containing classes such as `go.libv2ray.V2RayPoint`, `go.libv2ray.Libv2ray`, etc. 

5. **Include in Android App:** Copy the AAR into your Android project’s `app/libs` and add it to Gradle. For instance, in `app/build.gradle`:
   ```gradle
   implementation files('libs/XrayCore.aar')
   ``` 
   Gradle will merge it, making the native libs and stub classes available. If you built separate AARs for each ABI, you’d include only the one matching the build variant (the build scripts for CI handle this by producing variant-specific builds). Alternatively, include all and use ABI splits so that each APK delivered to devices contains only the needed .so. 

This gomobile method is exactly what the maintainers use. The AndroidLibXrayLite README succinctly outlines it ([GitHub - 2dust/AndroidLibXrayLite](https://github.com/2dust/AndroidLibXrayLite#:~:text=1.%20%60git%20clone%20,w%27)), and SaeedDev94’s `buildXrayCore.sh` automates it for all ABIs ([github.com](https://github.com/SaeedDev94/Xray/raw/refs/heads/master/buildXrayCore.sh#:~:text=mod%20tidy%20,check_target%20prepare_go%20build_android%20refresh_dependencies)) ([github.com](https://github.com/SaeedDev94/Xray/raw/refs/heads/master/buildXrayCore.sh#:~:text=URL%3A%20https%3A%2F%2Fgithub.com%2FSaeedDev94%2FXray%2Fraw%2Frefs%2Fheads%2Fmaster%2FbuildXrayCore.sh%20%21%2Fbin%2Fbash%20TARGET%3D,replace%20github.com%2Fxtls%2Flibxray%3D.%2FlibXray%20%23%20go)). 

## Manual Go Cross-Compile (executables or .so)  
If instead of an AAR you want a raw binary or a custom shared library: 

- **For Executable:** Use Go’s cross-compiling by setting env variables:  
  ```bash
  CGO_ENABLED=0 GOOS=android GOARCH=arm64 go build -trimpath -o xray-arm64 ./main
  ```  
  This will produce an `xray-arm64` binary for arm64-v8a (assuming no CGo is needed; Xray-core doesn’t require CGO for its main functionality). Similarly, for x86_64: `GOARCH=amd64` (Go uses `amd64` to mean x86_64). If you need 32-bit: `GOARCH=386` for x86, `GOARCH=arm` for ARMv7. The `-trimpath` and `-ldflags="-s -w"` flags are often used to minimize binary size (strip debug, remove path info). The result is an ELF binary that you can ship. Remember to include any data files (geoip, geosite) with it if you plan to use those features – the app might need to supply `-assetDir` parameter or set an env for Xray-core to find them. 
- **For Shared Library (C-Shared):** If you wanted to build a `.so` manually (not using gomobile), you could do:
  ```bash
  CGO_ENABLED=1 GOOS=android GOARCH=arm64 go build -buildmode=c-shared -o libxray.so ./mobile
  ``` 
  In this case, you’d need a `mobile` package with an appropriate exported C function (using `import "C"`). This outputs `libxray.so` and a `libxray.h` C header declaring the function. You’d then create a JNI wrapper in Java to load this .so and call the function. This is more complex and beyond the scope for most – gomobile is simpler. The libXray project mentions using `-buildmode=c-archive` or cshared for iOS/macOS integration in certain scenarios ([GitHub - XTLS/libXray](https://github.com/XTLS/libXray#:~:text=But%20it%20is%20not%20possible,it%20does%20not%20support%20tvOS)), but for Android, gomobile covers our needs. 

**Development Environment Variables:** If using the NDK or building with CGO, ensure the appropriate compiler is used. For example, for arm64, you might need to set `CC=$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android21-clang` (pointing to Clang for Android API 21+). Gomobile handles this internally; manual builds might require it if CGO is on. For pure Go (CGO_ENABLED=0), no external compiler is needed. 

# Step-by-Step: Compiling Xray-core for Android (Summary)  
Combining the above, here is a concise **step-by-step instruction** to manually compile Xray-core (with libXray wrapper) for Android arm64 and x86_64 using gomobile:

1. **Prepare environment:** Install Go, JDK, Android SDK, NDK. Set `ANDROID_HOME` and `ANDROID_NDK_HOME`. Install gomobile (`go install gomobile@latest`) and run `gomobile init` ([github.com](https://github.com/SaeedDev94/Xray/raw/refs/heads/master/buildXrayCore.sh#:~:text=mod%20tidy%20,check_target%20prepare_go%20build_android%20refresh_dependencies)). 

2. **Clone Xray-core and libXray:**  
   ```bash
   git clone https://github.com/XTLS/Xray-core.git 
   git clone https://github.com/XTLS/libXray.git 
   ```  
   Ensure they are in the same parent directory (the libXray build expects that ([GitHub - XTLS/libXray](https://github.com/XTLS/libXray#:~:text=We%20will%20not%20answer%20questions,by%20using%20other%20compilation%20methods))). For example: you might have a folder `XrayBuild/` with `Xray-core/` and `libXray/` inside it. 

3. **(Optional) Update Submodules:** If libXray uses Xray-core as a submodule, run `git submodule update --init`. (In SaeedDev94’s case, the submodules were referenced in his repo structure ([Xray/.gitmodules at master · SaeedDev94/Xray · GitHub](https://github.com/SaeedDev94/Xray/blob/master/.gitmodules#:~:text=%5Bsubmodule%20%22XrayCore%2FXray)).) If you manually placed them, ensure libXray’s go.mod points to your local Xray-core or to a matching version. libXray’s README says it’s only compatible with the latest Xray-core release ([GitHub - XTLS/libXray](https://github.com/XTLS/libXray#:~:text=a%20PR%2C%20your%20issue%20will,core)). 

4. **Run libXray build script:** The libXray project provides a Python build script as a convenient wrapper. For Android:  
   ```bash
   cd libXray  
   python3 build/main.py android
   ```  
   This will internally call gomobile to build the Android AAR using libXray + Xray-core ([GitHub - XTLS/libXray](https://github.com/XTLS/libXray#:~:text=You%20need%20to%20put%20Xray,the%20same%20directory%20to%20compile)). It should output something like `libxray.aar` or similar in a build folder. (Ensure you have Python3 and required modules if any.) 

   *If you prefer manual gomobile:* Navigate to `libXray/` (which has an `android_wrapper.go` etc.) and run:  
   ```bash
   gomobile bind -androidapi 26 -target android/arm64,android/amd64 -o XrayCore.aar .
   ```  
   This will produce one AAR containing both arm64 and x86_64 binaries. 

5. **Verify output:** After a successful build, you’ll have an AAR. You can unzip it to check `jni/arm64-v8a/` and `jni/x86_64/` have `.so` files, and that classes.jar has classes like `go.libxray.Xray` (for example). 

6. **Integrate into Android project:** Copy the AAR into `app/libs`. Add `implementation files('libs/XrayCore.aar')` to app module gradle. Sync the project – now your app code can call the libXray APIs. 

7. **Use the API in Java/Kotlin:** Based on libXray’s design, you might have a class `Xray` with static methods or an `Instance` class. Check libXray’s documentation or the generated class. For example, if libXray provides `Xray.run(configBytes)`, you’d do something like: 
   ```kotlin
   val configText = File("path/to/config.json").readText()
   Xray.run(configText.toByteArray(Charsets.UTF_8))
   ``` 
   This would start the core. Or if there’s an `Instance` object: 
   ```kotlin
   val instance = Xray.newInstance(configString) 
   instance.start() 
   // ... later 
   instance.stop()
   ``` 
   The exact usage will depend on how libXray exposes it. (For AndroidLibV2rayLite, the usage was `V2RayPoint` object with `runLoop()` as seen in the code ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=func%20%28v%20,))). 

8. **Run and Test:** Install the app on a device. If everything is set up, starting the VPN/proxy should invoke the Go library. It’s good to test on both arm64 and x86_64 (the latter can be an emulator) to ensure the correct .so is picked up. 

This process, while involved, gives you a self-contained Android library of Xray-core. The key is that **gomobile abstracts the cross-compilation and JNI binding**. 

# Android Client Integration (Invoking the Go Library)  
Finally, let’s discuss how an Android app (in Java/Kotlin) actually interfaces with the compiled Go code at runtime – effectively combining everything into the end-to-end picture:

- **Loading the Library:** When the app starts (or when first needed), the gomobile-provided classes will load the native .so. Typically, the first call to any Go-bound function will trigger a static initializer that calls `System.loadLibrary`. For example, the stub might have `static { Runtime.loadLibrary("libxray"); }`. If not, you may need to manually call it: `System.loadLibrary("xraycore")` (the name without `lib` and `.so`). In v2rayNG’s older lib, the package was `libv2ray` and the library name `libv2ray.so`, so they would load `libv2ray` in code. Make sure this happens before calling other methods. 
- **Starting the Core:** The app will typically generate the Xray configuration based on user settings. This is often a JSON string. Both v2rayNG and Xray app use the JSON approach because Xray-core’s configuration is rich and well-defined. They may also set some environment options: for instance, v2rayNG calls an init to set the **app’s file directory** as Xray’s working directory, so that core can read geoip files or store logs ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=func%20InitV2Env,)). In AndroidLibXrayLite, `InitV2Env(envPath, key)` is used for that ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=func%20InitV2Env,)). So the sequence is:
  1. Copy asset files (geoip.dat, geosite.dat) to a known path (e.g. `/data/data/<app>/files/assets/`). v2rayNG mentions these files go under `Android/data/com.v2ray.ang/files/assets` ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=)).
  2. Call init function with that path (and perhaps a user-specific key for encryption, if any – the `key` parameter in `InitV2Env` might relate to stats or something).
  3. Construct the JSON config (the app likely has a JSON template and replaces values or uses org.json library to build one).
  4. Call the “start” function. With libXray, it might be a single call (since libXray is designed to simplify usage). With libv2ray (v2rayNG’s), it was creating an object and calling runLoop. In either case, this causes the Go code to parse the JSON (using `v2ray-core`’s parser) and start all services. 
  
- **VPN Service Coordination:** In VPN mode, the app’s VpnService (TProxyService or V2RayVpnService) sets up the TUN interface and then usually informs the Go core of the TUN. However, Xray-core itself doesn’t read from the TUN – the external tun2socks does. So the VpnService will do: 
  - `tunFD = establish()` a VPN interface (Android returns a FileDescriptor for the tun). 
  - Start the tun2socks native component, pointing it to `tunFD` and to the SOCKS5 address (which the JSON config specifies, e.g. `127.0.0.1:10808`). In v2rayNG, this might be done by calling a JNI method like `tun2socksStart(tunFD, "127.0.0.1", 10808)`. In the Xray app, using hev-socks5-tunnel, similarly there will be a JNI call (hev-socks5-tunnel likely exposes a function to run it). 
  - The tun2socks runs in native code (on a separate thread) and starts feeding data. No further action needed from the Go core besides having the SOCKS inbound open. The core will see incoming SOCKS connections representing the device’s traffic and handle them. 
  - The app might use `VpnService.protect(socket)` on any outbound sockets Xray-core opens, to ensure they don’t get caught in the VPN again. This can be done in Go by calling back to Java. libv2ray’s `V2RayVPNServiceSupportsSet` interface likely includes a method for protecting sockets which the app implements and passes into `NewV2RayPoint` ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=func%20NewV2RayPoint,V2RayPoint)). Indeed, in the code snippet, `NewV2RayPoint(s V2RayVPNServiceSupportsSet, adns bool)` ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=func%20NewV2RayPoint,V2RayPoint)) takes an object that has support functions – one of those is usually to protect a socket (common in VpnService-based proxies). The app provides an implementation that calls `VpnService.protect(FileDescriptor)`. This prevents routing loops. 
- **Stopping the Core:** When the user disconnects, the app will:
  - Signal tun2socks to stop (maybe by closing the tun FD or invoking a stop method).
  - Call the Go library’s stop function. For example, `coreInstance.stopLoop()` which in Go triggers a shutdown of Xray-core (closing listeners, etc.) ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=func%20%28v%20,)). The Go wrapper might handle waiting for all goroutines to finish. If not, the app could simply let the process end or in worst case kill the service (but a clean stop is ideal to free resources). 
  - The VpnService is terminated (closing TUN) and the app UI updates. 

- **Shared Library vs. Multi-Process:** All these steps happen within one process (the VPN service process which is part of the app’s process). This means no IPC between app and core is needed – function calls suffice. Contrast this with some other VPN apps that spawn a background daemon: they would need to send config via Intents or IPC, which is more complex and error-prone. 

- **Java/Kotlin Code Snippets:** As an illustration, here’s a pseudo-code snippet combining everything for an Android client using the library approach (not actual code from the repos, but representative): 

  ```kotlin
  class VpnService : VpnService() {
      override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
          // 1. Prepare TUN interface
          val builder = Builder()
          builder.addAddress("10.0.0.2", 32)  // example private IP
          builder.addDnsServer("8.8.8.8")
          builder.addRoute("0.0.0.0", 0)
          val fd = builder.establish()  // FileDescriptor for tun
          // 2. Start Xray-core via lib
          val configJson = AppConfig.createXrayConfig(localSocksPort = 10808)
          LibXray.initEnv(appContext.filesDir.path)  // set asset dir for geo files (if needed)
          xrayInstance = LibXray.startInstance(configJson)  // hypothetical call to start core
          // 3. Launch tun2socks (hev-socks5-tunnel)
          Tun2Socks.start(fd, "127.0.0.1", 10808)
          return START_STICKY
      }
      override fun onDestroy() {
          Tun2Socks.stop() 
          xrayInstance?.stop()  // or LibXray.stopAll()
          fd?.close() 
          super.onDestroy()
      }
  }
  ``` 

  In reality, there are additional details (threads, error handling, etc.), but this gives the flavor of interaction: the app *configures environment -> starts core -> bridges network*. 

- **ABI Considerations:** When interfacing, ensure the device’s ABI is supported. For example, if you only included arm64 and x86_64, a 32-bit ARM phone wouldn’t be compatible. That’s why Saeed’s project still builds ARM32 and x86. Google Play nowadays mandates 64-bit, but including 32-bit is optional unless you need to support very old devices or Android x86 installs. If the .so for the device’s ABI is missing, the app will crash on load. So developers must either supply all needed ABIs or restrict the app’s installation (e.g., via Play Store ABI filters). Both projects solved this by providing multiple APKs or AAB splits ([GitHub - SaeedDev94/Xray: Xray GUI Client For Android](https://github.com/SaeedDev94/Xray#:~:text=APK%20variants%20guide)). 

- **JNI Memory and Limits:** Since Go runs inside the app, memory usage contributes to the app’s memory profile. A high load on Xray-core could consume significant RAM or CPU, so developers often include options to reduce memory (like not loading unnecessary components, or using Go build tags if available to trim features). 

- **Using the Proxy Without VPN:** Both apps allow using the local proxy without enabling the system-wide VPN. In that case, the app just starts Xray-core with, say, a HTTP/SOCKS proxy inbound and shows the address (127.0.0.1:port). The user could then configure other apps or Android’s private DNS/VPN settings to use that proxy (or use it via tethering). The core usage is the same, minus the tun2socks part. This mode is essentially running Xray-core as a local client proxy. Saeed’s app specifically mentions this “just for your socks proxy (Like SocksDroid)” use-case ([GitHub - SaeedDev94/Xray: Xray GUI Client For Android](https://github.com/SaeedDev94/Xray#:~:text=This%20is%20a%20simple%20GUI,Like%20SocksDroid)). When used this way, the VpnService is not started; Xray-core still runs as a lib in the app (listening on a localhost port) and Android’s VPN API is not involved at all. This is simpler (no need for tun2socks). However, it requires manual proxy setup in other apps (or per-app proxy settings via third-party tools) – not as universal as the VPN approach. 

In conclusion, the **Java/Kotlin Android client communicates with the Go library through the auto-generated interface**. The developers of v2rayNG and Xray app have abstracted most of this away so that from the app’s perspective, using the core is as easy as calling a few methods with JSON strings or config parameters. The heavy lifting (packeting handling, encryption, protocol negotiation) is all done in Xray-core’s Go code, which is running natively at near full speed on the device. This marriage of Go and Android tech yields a powerful client: the flexibility of Xray-core with the user-friendly interface and integration of Android. 

# Conclusion  
We have seen that **Xray-core is typically compiled as a shared library for Android clients**, using the gomobile tool to generate an AAR that the Android app can invoke directly ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=outdated,and%20Makefiles%20for%20Go%20Developers)) ([Using X-Ray Core for Android · Issue #2808 · XTLS/Xray-core · GitHub](https://github.com/XTLS/Xray-core/issues/2808#:~:text=yuhan6665%20%20%20commented%20,74)). Both the v2rayNG and SaeedDev94’s Xray projects embed the core this way, with a thin Go wrapper (custom or libXray) to expose a clean interface. The Android apps are structured to manage VPN tunneling (via VpnService and tun2socks) and to feed configurations to the Xray-core library, which runs in-process. 

By following the steps outlined (setting up Go, NDK, using `gomobile bind`), developers can replicate this setup – compiling Xray-core for multiple ABIs (arm64-v8a, x86_64, etc.) ([github.com](https://github.com/SaeedDev94/Xray/raw/refs/heads/master/buildXrayCore.sh#:~:text=URL%3A%20https%3A%2F%2Fgithub.com%2FSaeedDev94%2FXray%2Fraw%2Frefs%2Fheads%2Fmaster%2FbuildXrayCore.sh%20%21%2Fbin%2Fbash%20TARGET%3D,replace%20github.com%2Fxtls%2Flibxray%3D.%2FlibXray%20%23%20go)) and integrating it into their own Android applications. The key is to leverage existing wrapper code (such as **AndroidLibXrayLite** or **libXray**) so you don’t have to reinvent the wheel parsing JSON in Java or dealing with Go internals. Instead, you call high-level methods to start the proxy. 

**Reference Build Scripts & Guides:** Both projects provide guidance in their repos:
- The v2rayNG README’s *Development guide* points to AndroidLibXrayLite and Go Mobile usage ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=or%20using%20Gradle%20wrapper,and%20Makefiles%20for%20Go%20Developers)). It even references a Makefile tutorial for Go developers ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=outdated,and%20Makefiles%20for%20Go%20Developers)) for further reading on cross-compiling.
- The AndroidLibXrayLite repository README gives exact commands for building the AAR ([GitHub - 2dust/AndroidLibXrayLite](https://github.com/2dust/AndroidLibXrayLite#:~:text=1.%20%60git%20clone%20,w%27)). 
- SaeedDev94’s build script exemplifies automating builds for all architectures using gomobile ([github.com](https://github.com/SaeedDev94/Xray/raw/refs/heads/master/buildXrayCore.sh#:~:text=mod%20tidy%20,check_target%20prepare_go%20build_android%20refresh_dependencies)). 
- XTLS’s libXray README explains their approach and suggests always using their script for compatibility ([GitHub - XTLS/libXray](https://github.com/XTLS/libXray#:~:text=build)).

With the core compiled and integrated, the Java/Kotlin client can use either the **executive approach** (invoke as a separate process, not covered in depth here due to its complexity) or the **embedded approach** (as demonstrated). All evidence and current best practices indicate the embedded library approach is superior for Android apps, offering a seamless, efficient way to harness Xray-core’s capabilities on mobile. 

**Sources:**

- Xray Android client description ([GitHub - SaeedDev94/Xray: Xray GUI Client For Android](https://github.com/SaeedDev94/Xray#:~:text=Image%3A%20App%20Cover)) (SaeedDev94/Xray README)  
- v2rayNG README (Android client using Xray-core library) ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=Development%20guide))  
- AndroidLibXrayLite build instructions (gomobile usage) ([GitHub - 2dust/AndroidLibXrayLite](https://github.com/2dust/AndroidLibXrayLite#:~:text=1.%20%60git%20clone%20,w%27))  
- SaeedDev94’s build script (gomobile bind for Android ABIs) ([github.com](https://github.com/SaeedDev94/Xray/raw/refs/heads/master/buildXrayCore.sh#:~:text=mod%20tidy%20,check_target%20prepare_go%20build_android%20refresh_dependencies))  
- libXray documentation (wrapper around Xray-core for mobile) ([GitHub - XTLS/libXray](https://github.com/XTLS/libXray#:~:text=Compile%20script,by%20using%20other%20compilation%20methods))  
- GitHub Issue confirming gomobile as the method for Android ([Using X-Ray Core for Android · Issue #2808 · XTLS/Xray-core · GitHub](https://github.com/XTLS/Xray-core/issues/2808#:~:text=yuhan6665%20%20%20commented%20,74)) and that the provided Xray-core file is an executable ([Using X-Ray Core for Android · Issue #2808 · XTLS/Xray-core · GitHub](https://github.com/XTLS/Xray-core/issues/2808#:~:text=Loading)).