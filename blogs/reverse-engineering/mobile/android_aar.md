Got it. I’ll dig into the Android AAR package structure, how it includes both Java classes and native libraries, and how it is compiled and transformed through the build process. I’ll also include some real-world case studies of open-source libraries that use native code in AARs. I’ll start with Gradle-based builds and expand to other build tools if useful. I’ll update you once I have everything together.

# Understanding Android AAR Structure and Build Flow

## Introduction  
Android AAR (Android Archive) packages are the standard format for distributing reusable Android libraries. An AAR is similar to a JAR but can include Android-specific components like resources, manifests, and native binaries. This report provides a detailed look at AAR file structure, how Java classes and native `.so` libraries are packaged inside, and what happens when an AAR is integrated into an application’s build (APK or App Bundle). We also examine the build pipeline (especially with Gradle, and a note on Bazel) and real-world examples of open-source Android libraries that bundle native code in AARs. The goal is to demystify what an AAR contains and how it flows through the build process from library to final app.

## Anatomy of an Android AAR File  
An AAR file is essentially a ZIP archive containing an Android library’s compiled code and assets. According to the official Android documentation, the **only required entry** in an AAR is an `AndroidManifest.xml` (the library’s manifest). All other entries are optional and appear if the library has those components ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#:~:text=The%20file%20extension%20for%20an,AndroidManifest.xml)). Key contents of an AAR include ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#:~:text=The%20file%20extension%20for%20an,AndroidManifest.xml)) ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#:~:text=,for%20%20219)):

- **AndroidManifest.xml:** The library’s own manifest declaring components, permissions, etc. (always present).  
- **classes.jar:** The compiled Java/Kotlin bytecode of the library (packaged as a JAR inside the AAR) ([Dealing with the 64K Method Limit in Your Unity3D Game](https://www.gamedeveloper.com/programming/dealing-with-the-64k-method-limit-in-your-unity3d-game#:~:text=The%20classes%20in%20both%20Library,jar)). This contains all the library’s classes (and usually the library’s `R` class).  
- **res/**: A folder of Android resource files (layouts, drawables, values, etc.) that the library provides. These will be merged with an app’s resources when the AAR is used.  
- **R.txt:** A text file indexing the resource IDs that were assigned to the library’s resources during its build. This helps the build system ensure consistent resource ID mapping when merging with an app.  
- **public.txt:** (Optional) Specifies which resources are public API for the library (used to restrict resource visibility).  
- **assets/**: Asset files packaged with the library (if any).  
- **jni/<ABI>/**: Any compiled native libraries (`.so` files) for one or more CPU architectures (ABI = Application Binary Interface). Each subdirectory is named after an ABI (e.g. `arm64-v8a`, `armeabi-v7a`, `x86_64`, etc.) and contains the corresponding `.so` binaries ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#:~:text=,for%20%20219)). For example, an AAR might include `jni/arm64-v8a/libmynative.so` and `jni/armeabi-v7a/libmynative.so` for 64-bit and 32-bit ARM support.  
- **libs/**: Any additional JAR files that the library includes (for example, third-party Java dependencies that have been packaged with the library). These appear as `libs/yourlib.jar` inside the AAR ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#:~:text=,supported)).  
- **proguard.txt:** Consumer ProGuard rules for this library. If present, these rules are meant to be **merged into the app’s ProGuard/R8 configuration** when the AAR is used ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#:~:text=If%20you%20have%20a%20library,of%20the%20app%20module)). This allows the library to specify keep rules (to avoid its code being obfuscated or stripped incorrectly).  
- **lint.jar:** (Optional) Any custom Lint checks packaged with the library. Android Studio will detect and run these checks when you use the library.  
- **api.jar:** (Optional) A stub API jar (sometimes used to hold only the library’s API signatures, if provided).  
- **prefab/**: (Optional) A directory for **Prefab** packs, which is a mechanism to export C/C++ headers and prebuilt native libs for consumption by CMake or ndk-build in the app. This is used for easier native integration (for example, OpenCV’s AAR uses Prefab to expose headers) ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#:~:text=,for%20%20219)).

**Structure Example:** If we inspect an example AAR (e.g., the Zstandard compression JNI library), we see the manifest, resource index, classes JAR, and native `.so` files for each architecture packaged inside. For instance, `com.github.luben:zstd-jni` version 1.5.5-4 contains: `AndroidManifest.xml`, `R.txt`, `classes.jar`, and native libraries under `jni/arm64-v8a`, `jni/armeabi-v7a`, `jni/x86`, and `jni/x86_64` (each containing a `libzstd-jni.so` for that ABI) ([.SO file not packed with APK file · Issue #333 · luben/zstd-jni · GitHub](https://github.com/luben/zstd-jni/issues/333#:~:text=AndroidManifest.xml%20R.txt%20classes.jar%20jni%2F%20jni%2Farm64,4.so)). This illustrates how an AAR can bundle all necessary pieces of a library (code, resources, native code, etc.) into one file for distribution.

## Including Java Classes and Native Libraries in an AAR  
When you create an Android library module (using the Gradle plugin `com.android.library`), the build system will produce an AAR instead of an APK. The packaging process ensures that your Java/Kotlin code and any native code are included properly:

- **Java/Kotlin Classes:** All compiled `.class` files from your library are archived into the `classes.jar` inside the AAR. In fact, an AAR’s classes.jar is the direct equivalent of a JAR library – it is simply packaged within the AAR for convenience ([Dealing with the 64K Method Limit in Your Unity3D Game](https://www.gamedeveloper.com/programming/dealing-with-the-64k-method-limit-in-your-unity3d-game#:~:text=The%20classes%20in%20both%20Library,jar)). If your library module depends on other libraries, those are **not** automatically merged into classes.jar; they must be added as separate dependencies. (In a Maven repository, the AAR’s POM will list its dependencies. If you’re manually bundling an AAR, you’d need to ensure its dependencies are provided when used.) It’s possible to include additional JARs in the AAR under `libs/`, but this typically requires manually adding them to the library module (for example by putting a third-party JAR in the module’s `libs` directory or using Gradle’s `implementation files('...')`). Generally, AARs keep their dependencies separate to avoid “fat” AARs, unless you specifically build one that way.

- **Native `.so` Libraries:** AARs can directly embed precompiled native libraries. The Gradle Android plugin looks for native libraries in the `jniLibs` directory of the library module. The usual convention is to place compiled `.so` files in `src/main/jniLibs/<ABI>/`. For example:  
  ```plaintext
  mylib-module/
    src/main/jniLibs/arm64-v8a/libmylib.so
    src/main/jniLibs/armeabi-v7a/libmylib.so
    src/main/jniLibs/x86_64/libmylib.so
  ```  
  Upon building the library, Gradle packages these into `jni/<ABI>/` in the AAR ([How to Build *.so Library Files into AAR Bundle in Android Studio |
  Dynamsoft Developers Blog](https://www.dynamsoft.com/codepool/build-so-aar-android-studio.html#:~:text=The%20simplest%20way%20to%20add,so%20files%20into%20the%20folder)). This approach is commonly used when you have pre-built native binaries. If you are instead building native code from source (C/C++), you can integrate CMake or ndk-build in your Gradle script (via `externalNativeBuild`). Gradle will compile the native code for the ABIs you specify and automatically output the `.so` files. By default, those outputs will be picked up and included in the AAR (Gradle knows the output paths for the `.so` files and packages them). In older setups, one might have used `sourceSets.main.jniLibs.srcDir` or copied files manually, but with modern plugins this is usually handled for you. 

- **Resources and Assets:** If your library has an `res/` directory (with XML layouts, drawables, etc.) or `assets/`, these are packaged into the AAR as-is. They will later be merged into any app that uses the library. The AAR also includes the `R.txt` file which lists the resource IDs assigned at library build time.

- **The Library Manifest:** The `AndroidManifest.xml` inside the AAR is the library’s own manifest. It might declare components (activities, services, providers), `<uses-permission>` requirements, and other metadata. This manifest will be merged with an app’s manifest when the library is consumed (more on this in the next section).

- **ProGuard Rules:** If you want to include ProGuard (R8) rules with your library (to advise consumer apps how to keep or optimize code), you can specify a `consumerProguardFiles` in the library Gradle config. This will cause a `proguard.txt` (or similarly named) file to be packaged in the AAR. When the AAR is used in an application, these rules are automatically applied so the app developer doesn’t have to manually add them ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#:~:text=If%20you%20have%20a%20library,of%20the%20app%20module)).

**Note:** Unlike an APK, an AAR doesn’t contain Dalvik/ART bytecode (.dex files) or a packaged APK manifest, since it’s not a standalone application. It’s a library package to be merged into an app. Also, AARs do not themselves contain the metadata about their dependencies except through Gradle/Maven. If you manually include an AAR file in a project (outside of Gradle’s dependency mechanism), you must also include any of its transitive dependencies on your own, because the build will not know about them automatically (the AAR is a lone zip). In typical Gradle usage, this isn’t an issue because the Maven artifact for the AAR will list dependencies which Gradle pulls in.

## From AAR to APK/AAB: Build Process and Transformation Pipeline  
Including an AAR in an Android app (APK or App Bundle) triggers a series of build steps that integrate the library into the final product. In a Gradle-based build (Android Studio), this process is mostly automatic. Below is the typical pipeline from adding an AAR as a dependency to getting a final APK/AAB, highlighting how each part of the AAR is handled:

1. **Dependency Inclusion:** When you declare an AAR dependency (for example, via `implementation 'com.example:my-library:1.0.0'` in Gradle), the build system fetches the AAR (and its POM-defined transitive dependencies). Gradle adds the AAR’s `classes.jar` to the compile classpath of your app module, so you can use the library’s classes in your code. If you include a library module from the same project, a similar process occurs: the library module is built into an AAR which is added to the app. In either case, at compile time your app is aware of the library’s API. The library’s resources are also made available to the app (so you can reference them in XML or code via the library’s R class). Each library module has its own R class (in its own package namespace) generated during library compilation ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#:~:text=,class)), and the app will have references to those as needed.  

2. **Resource Merging and R Class Generation:** All resources from AAR libraries are merged with the app’s own resources. The Android build tools (AAPT2) take the `res/` directory of each AAR and combine them into one resource set. If there are resource name conflicts, the build may fail or apply override rules (usually the app’s resources can override library resources if specifically configured via tools attributes). During this merge, AAPT2 assigns final resource IDs and generates the **application’s R class** which includes entries for all resources (including those from libraries). The build strives to keep the resource IDs consistent with what the libraries expect. The `R.txt` from each AAR guides the build to map the library’s resource references to the correct IDs. In practice, the library’s compiled code has inlined integer constants for its resources (because the library’s R class was compiled in the classes.jar). The resource merger ensures that the final APK will use those same integer values for the corresponding resources, or it will rewrite them if needed. The result is that your app gets a single consolidated set of resources and an R class (in the app’s namespace) that covers everything. Each library’s package R class is also regenerated in the app build (as needed for references in code), but these are basically pointers to the merged resources ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#:~:text=,class)).  

3. **Manifest Merging:** Because an APK can only have one `AndroidManifest.xml`, the library’s manifest is merged into the app’s manifest at build time. Gradle’s manifest merger tool combines the XML elements following a priority system and merge rules ([Manage manifest files  |  Android Studio  |  Android Developers](https://developer.android.com/build/manage-manifests#:~:text=Your%20APK%20or%20Android%20App,that%27s%20packaged%20into%20your%20app)). The app module’s own manifest is highest priority, and library manifests are lower (they can provide default elements which the app can override if needed). For example, if the AAR’s manifest declares an `<activity>` or a `<uses-permission>`, those entries will be added to the final manifest of the APK ([Manage manifest files  |  Android Studio  |  Android Developers](https://developer.android.com/build/manage-manifests#:~:text=Your%20APK%20or%20Android%20App,that%27s%20packaged%20into%20your%20app)). If both the app and library declare the same `<uses-sdk>` (minSdkVersion, etc.), Gradle will enforce compatibility or allow the app to override (e.g., the app cannot have a lower minSdk than a library). You can control this process with special attributes (`tools:merge`, `tools:node`) if there are conflicts, but by default it just appends components and merges metadata. The merged manifest ensures that any components the library needs (services, permissions, provider authorities, etc.) are present in the APK’s manifest without manual steps.

4. **Java Bytecode and Dexing:** The library’s `classes.jar` (and any `libs/*.jar`) are essentially class files that now become part of the app. During the DEX generation phase (conversion of Java bytecode to Dalvik bytecode), the app’s classes and all library classes are fed together into the DEX compiler. This produces one or more `.dex` files that contain the combined program. In other words, the classes from the AAR become indistinguishable from the app’s own classes in the final dex output. If the number of methods is large, the app may need multidex just as if those methods were in the app code (AARs contribute to method count). **Important:** If two AARs contain classes with the same fully-qualified name (which is rare and considered an error), you would get a build error for duplicate classes. So, each library’s classes.jar should have unique packages to avoid conflicts. The Android Gradle plugin will also merge JNI interface code loading. For example, if the library calls `System.loadLibrary("foo")` for its native code, that call remains in the code – but the presence of the actual native lib is handled separately as described next.

5. **Native Libraries Packaging:** Gradle will package the `.so` files from any AAR into the final APK or App Bundle. For an **APK**, this means copying each `.so` into the `lib/<ABI>/` folder inside the APK. For an **Android App Bundle (AAB)**, the build process actually keeps the native libraries separate so that they can be distributed in split APKs. The bundle will contain each ABI’s `.so` files, and when processed by Google Play (or BundleTool), it can produce split APKs per ABI (so a device only gets the lib for its architecture). From a developer’s perspective, you simply include the AAR and build an AAB; the splitting is handled by the bundle tool. If no splitting is used, all `.so` remain packaged together. The key point is that **you do not need to manually load or include these native libraries** – the build system and Android package manager handle that. The app only needs to call `System.loadLibrary("mynative")` in its code (usually the library SDK will do that internally) and the OS will find the corresponding `libmynative.so` in the APK. As an example, when using the OpenCV SDK AAR, Gradle "automatically adds the native libraries to the APK" ([Enhanced OpenCV For Android Support & ARM Performance Gains - OpenCV](https://opencv.org/blog/enhanced-opencv-for-android-support-arm-performance-gains/#:~:text=The%20OpenCV%20package%20will%20be,first%20library%20usage%20like%20this)) and you only need to ensure a loadLibrary call is made (e.g., OpenCV uses a static initializer to load its lib). 

    *ABI Considerations:* The AAR may include multiple ABIs. Developers can choose to limit which ABIs get packaged into the app to reduce size. For instance, the TensorFlow Lite AAR includes binaries for **all** major ABIs, but the TensorFlow team notes you can save space by filtering out unused ones (e.g., omit x86/x86_64 for release builds on mobile devices) ([tensorflow-1/tensorflow/lite/g3doc/guide/android.md at master · sourcecode369/tensorflow-1 · GitHub](https://github.com/sourcecode369/tensorflow-1/blob/master/tensorflow/lite/g3doc/guide/android.md#:~:text=This%20AAR%20includes%20binaries%20for,ABIs%20you%20need%20to%20support)). This is done via Gradle `ndk.abiFilters`. If you filter out an ABI, Gradle will exclude that folder’s .so files from your APK/AAB. Keep in mind that Google Play now [requires 64-bit support](https://developer.android.com/distribute/best-practices/develop/64-bit) for apps, so libraries typically include an `arm64-v8a` build. Many libraries also still include `armeabi-v7a` for 32-bit devices. Some have dropped 32-bit entirely if targeting modern devices (more on this in case studies). By default, if you don’t set abiFilters, all ABIs present in the AAR will be packaged in your APK/AAB.

6. **ProGuard (R8) Rules Application:** If you run a code shrinker (ProGuard/R8) on your app, the build will automatically apply any consumer ProGuard rules from the AAR. As mentioned, the AAR’s `proguard.txt` is appended to your app’s ProGuard configuration ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#:~:text=If%20you%20have%20a%20library,of%20the%20app%20module)). This ensures that the library’s required classes or serialization fields, etc., are kept or renamed properly according to the library authors’ specification. For example, a library might add a rule to keep certain classes that are accessed via reflection. This happens behind the scenes – you’ll see it in the Gradle build output that the consumer proguard file was applied.

7. **Other Metadata:** If the AAR contains a `lint.jar`, those checks will be included when running `lint` on your project (helping catch misuse of the library). This doesn’t affect the APK but is part of the development process. Similarly, any annotations in the library (like Jetpack Compose metrics, etc.) are handled as if they were in your code. An AAR might also include an `assets/` folder; these assets will be merged with the app’s assets (copied into the APK’s `assets` directory) so the app can access them via AssetManager. Essentially, the build system treats the library’s assets and resources as additional sources for the app.

After these steps, the result is an APK or App Bundle where the library’s code and resources have been fully integrated. There is no notion of an AAR at runtime – by the time the app is built, the AAR is unpacked and merged. The library’s **R class** constants are merged into the app’s resources and no separate R classes exist at runtime (they are compile-time artifacts). The app can use the library seamlessly. 

**Gradle vs. Other Build Systems:** While Gradle is the default build system for Android, other build tools also support AAR integration. For example, **Bazel** has an `aar_import` rule which allows using an external AAR in a Bazel build, and an `android_library` rule that can produce an AAR as output ([Android Rules  |  Bazel](https://bazel.build/versions/6.2.0/reference/be/android#:~:text=This%20rule%20allows%20the%20use,rules)) ([Android Rules  |  Bazel](https://bazel.build/versions/6.2.0/reference/be/android#:~:text=,not%20contain%20the%20transitive%20closure)). In Bazel’s case, `android_library(name = "foo", ...)` will produce a `foo.aar` containing that module’s classes and resources (but not its dependencies – similar to Gradle, transitive dependencies aren’t bundled) ([Android Rules  |  Bazel](https://bazel.build/versions/6.2.0/reference/be/android#:~:text=,not%20contain%20the%20transitive%20closure)). The `aar_import` rule can then take a pre-built .aar and make its contents available to Bazel’s merge and dex steps, effectively doing the same merging of manifest, resources, and native libs. Other build systems (Buck, Maven, etc.) handle AARs in analogous ways – they treat the AAR as a zip of resources and classes to be combined into the final app. The specifics differ, but the high-level idea of merging everything at build time is consistent.

## Case Studies: Open-Source AAR Libraries with Native Code  
To solidify our understanding, let’s look at a few real-world Android libraries that package native code in AARs, and how they structure and build them:

### OpenCV Android SDK  
[OpenCV](https://opencv.org) is a large computer vision library written in C/C++. The Android SDK for OpenCV is distributed as an AAR on Maven Central. Inside the OpenCV AAR, you will find a substantial native library (for example, `libopencv_java4.so`) for each supported architecture, plus a small Java API. The AAR includes the OpenCV binaries for **arm64-v8a, armeabi-v7a, x86, and x86_64** (allowing it to run on both 64-bit and 32-bit devices, and on emulators) ([tensorflow-1/tensorflow/lite/g3doc/guide/android.md at master · sourcecode369/tensorflow-1 · GitHub](https://github.com/sourcecode369/tensorflow-1/blob/master/tensorflow/lite/g3doc/guide/android.md#:~:text=This%20AAR%20includes%20binaries%20for,ABIs%20you%20need%20to%20support)). It also uses the **Prefab** system: the AAR’s `prefab/` folder contains C++ headers and metadata so that developers can easily **include OpenCV in their own native code**. In practice, this means you can add OpenCV’s AAR as a dependency and then in your CMake script do `find_package(OpenCV REQUIRED)` to link against OpenCV – the Prefab mechanism will pull in the correct headers and `.so` for your ABI ([Enhanced OpenCV For Android Support & ARM Performance Gains - OpenCV](https://opencv.org/blog/enhanced-opencv-for-android-support-arm-performance-gains/#:~:text=It%20is%20also%20possible%20to,provides%20an%20example%20of%20this)). OpenCV’s build process produces the .so libraries by cross-compiling for each ABI, and Gradle (or rather the publishing script) bundles them into the AAR. When you use this AAR, Gradle will merge OpenCV’s manifest (which might not have much besides a version or authority if needed) and add all the native libs. As the OpenCV team notes, simply adding the dependency will automatically make its native libraries available in your APK ([Enhanced OpenCV For Android Support & ARM Performance Gains - OpenCV](https://opencv.org/blog/enhanced-opencv-for-android-support-arm-performance-gains/#:~:text=The%20OpenCV%20package%20will%20be,first%20library%20usage%20like%20this)). Developers just have to load the library (e.g., call `System.loadLibrary("opencv_java4")`) in their code, and they can start using OpenCV’s API. OpenCV’s AAR does not typically include Android resource files (it’s mainly code), but it’s a prime example of shipping a complex native code base via AAR.

### TensorFlow Lite  
Google’s **TensorFlow Lite** (TFLite) provides machine learning inference on mobile, and it offers an AAR for Android. The TFLite AAR contains the native TensorFlow Lite runtime (`libtensorflowlite_jni.so`) for multiple architectures, as well as a Java wrapper API. The AAR is quite large because it packs native libraries for arm64, armv7, x86, x86_64 all together. The official TensorFlow docs highlight that the AAR includes binaries for all supported ABIs and show how developers can exclude certain ABIs to cut down APK size ([tensorflow-1/tensorflow/lite/g3doc/guide/android.md at master · sourcecode369/tensorflow-1 · GitHub](https://github.com/sourcecode369/tensorflow-1/blob/master/tensorflow/lite/g3doc/guide/android.md#:~:text=This%20AAR%20includes%20binaries%20for,ABIs%20you%20need%20to%20support)). For instance, if your app only needs to run on ARM devices, you might set `abiFilters 'armeabi-v7a', 'arm64-v8a'` to drop the x86 ones (which are mostly useful for emulators). TensorFlow Lite’s build uses Bazel under the hood to compile the native code, then they publish the AAR to Maven. In use, it’s straightforward: add the dependency and the `Interpreter` class (from the classes.jar) is available, and the `.so` gets included so that when the `Interpreter` loads the native library it finds `libtensorflowlite_jni.so` in the APK. This library doesn’t have Android UI resources, so it mainly demonstrates pure native + Java packaging. The pattern is similar for other Google ML kits or media libraries that bundle native code (they ship a combined AAR, and you can opt-out of some ABIs if needed).

### WeChat MMKV  
[MMKV](https://github.com/Tencent/MMKV) by Tencent is a small key-value storage library (alternative to SharedPreferences) that uses C++ under the hood for performance. MMKV provides an AAR as well. Notably, starting from version 2.0.0, MMKV **dropped 32-bit support** and only includes 64-bit (`arm64-v8a`) binaries (and possibly x86_64) by default ([android_setup · Tencent/MMKV Wiki · GitHub](https://github.com/Tencent/MMKV/wiki/android_setup#:~:text=,to%20build%20MMKV%20from%20source)). This was a deliberate choice to reduce the library size, given that modern Android devices are mostly 64-bit. Developers who still need 32-bit support are directed to use the older 1.x versions of MMKV. In the AAR structure, you’ll find something like `jni/arm64-v8a/libmmkv.so` (and maybe an x86_64 counterpart), but no armeabi-v7a lib in newer versions. The classes.jar contains the JNI bridge and API for MMKV usage in Java/Kotlin. MMKV’s build uses CMake to compile the native library. They also statically link the C++ STL (libc++) to avoid needing a separate `libc++_shared.so` in the APK ([android_setup · Tencent/MMKV Wiki · GitHub](https://github.com/Tencent/MMKV/wiki/android_setup#:~:text=2,this%20line%20to%20your%20Gradle)). This case study highlights that AARs give library developers flexibility to choose which ABIs to include. If an app uses MMKV 2.x, the app *must* be 64-bit capable (which is fine due to Play Store requirements). MMKV’s AAR includes a few resources (it uses an `assets/` folder for default files in some cases) and those are merged normally. Consuming MMKV is as easy as adding the dependency – the native lib is packaged and ready to be loaded via `System.loadLibrary("mmkv")` when the library is initialized.

### Realm Database  
Realm is a popular mobile database that uses a C++ core. The **Realm Java** library is open source and distributes its binary as an AAR. The Realm AAR includes multiple `.so` files (e.g., `librealm-jni.so`) for each ABI since the database engine is native. Realm’s Gradle setup is somewhat complex (they even provide a Gradle plugin for some integrations), but fundamentally the AAR contains the native core and the Java binding. When you add Realm as a dependency, you get its classes (for database operations) and all the native libs included in your APK. One challenge that Realm had historically is its size – including all ABIs made the AAR large, so some developers exclude unused ABIs to reduce APK size. Realm’s case is similar to the others: heavy native logic delivered via an AAR. It demonstrates that even with multiple `.so` (for instance, Realm might have separate libs for the database and maybe utilities), you can package them all under the jni folder. The build tools will package **all of them**, and at runtime the library code will load the appropriate one. For example, `System.loadLibrary("realm_jni")` will load `librealm-jni.so` for the device’s ABI. Realm also uses consumer ProGuard rules to ensure its model classes aren’t stripped out by optimization.

### SQLCipher for Android  
**SQLCipher**, an extension of SQLite that enables database encryption, is another example. It’s provided as an AAR containing the modified SQLite native library. Inside its AAR, you’d find `libsqlcipher.so` for various ABIs, and a classes.jar that gives a drop-in replacement for the Android database API. SQLCipher’s AAR historically included some additional native helpers and an STL library (in older versions, as seen by presence of `libstlport_shared.so` in some distributions). This reflects that an AAR can have multiple `.so` files per ABI. In an app using SQLCipher, the developer doesn’t have to worry about the native libs explicitly – by adding the dependency, the native SQLCipher libraries ride along. One just has to initialize the database normally. SQLCipher’s example also often comes up in context of the 64K method count, as it adds methods, and the 64-bit requirement (ensuring libsqlcipher for arm64 is present from recent versions). It’s a good case of an existing C library repackaged into an AAR for Android consumption.

**Summary:** These case studies show that AAR files are versatile – from massive libraries like OpenCV and TensorFlow Lite to small ones like MMKV – and they simplify distribution of native code. Each library’s build system takes care of compiling or gathering the native `.so` files and packaging them in the AAR. As consumers of these libraries, Android developers can mostly ignore the complexity of native code integration; they add the AAR dependency and let Gradle handle merging and packaging. The libraries typically document any special steps (like calling `System.loadLibrary` or setting ABI filters for size optimization), but otherwise the AAR mechanism abstracts the native integration details. The official Android Developer guides emphasize that AARs can contain C/C++ binaries and that they will be included in the app’s lib folder automatically ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#:~:text=,the%20app%20module%27s%20C%2FC%2B%2B%20code)) ([Enhanced OpenCV For Android Support & ARM Performance Gains - OpenCV](https://opencv.org/blog/enhanced-opencv-for-android-support-arm-performance-gains/#:~:text=The%20OpenCV%20package%20will%20be,first%20library%20usage%20like%20this)). This seamless integration is why the AAR format has become the standard for Android libraries that go beyond pure Java. By understanding the structure and build flow outlined above, you can better troubleshoot and optimize how libraries are included in your app (for example, managing ABI splits or avoiding resource name conflicts) and even build your own AAR libraries with confidence about what’s happening under the hood.

**References:** The information above is drawn from official Android documentation, open-source project repositories, and developer guides. Key sources include the Android Developers guide on library modules and AAR format ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#:~:text=The%20file%20extension%20for%20an,AndroidManifest.xml)) ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#:~:text=,for%20%20219)), the Gradle build system behavior as described in Android Studio docs ([Manage manifest files  |  Android Studio  |  Android Developers](https://developer.android.com/build/manage-manifests#:~:text=Your%20APK%20or%20Android%20App,that%27s%20packaged%20into%20your%20app)) ([Create an Android library  |  Android Studio  |  Android Developers](https://developer.android.com/studio/projects/android-library#:~:text=If%20you%20have%20a%20library,of%20the%20app%20module)), and examples from open-source libraries like OpenCV, TensorFlow Lite, MMKV, and others (as cited inline). These illustrate the AAR internals and the build process that transforms an AAR into a functioning part of an Android application.