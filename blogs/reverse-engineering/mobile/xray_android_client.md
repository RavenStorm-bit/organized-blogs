Perfect. I’ll do a deep dive into how Xray core (written in Go) works on Android—specifically how Android Xray clients embed and interface with the Xray binary, whether they use it as a standalone executable or a shared library. I’ll also look into how you can write your own Android app that runs a native Go binary, covering both approaches (standalone and via NDK/Go Mobile).

I’ll report back with technical breakdowns, common strategies used by popular clients, and tips for embedding a Go binary in your own app.

# Android Xray Client Architecture and Integration

## Overview of Xray Core on Android
**Xray-core** (a Go implementation derived from V2Ray) is commonly integrated into Android clients to provide VPN/proxy functionality. Android apps like **v2rayNG**, **NekoRay**, and **SagerNet** all leverage the Xray (or V2Ray) core for protocol handling. There are two primary architectures for embedding Xray-core in an Android app: 

- **Embedding as a native library** (shared object via JNI).  
- **Bundling as a standalone executable** (and running it as a subprocess).

Each approach has distinct integration patterns and trade-offs in how the Java/Kotlin layer invokes the core.

## Embedding Xray Core as a Shared Library (GoMobile Bind)
In this approach, the Go-based Xray core is compiled into a native **.so** library (packaged in an AAR). The Android app loads and calls the Go code via JNI, as if it were a normal native library. The official Go Mobile toolchain (`gomobile`) makes this straightforward by generating JNI bindings and a Java wrapper interface. The library runs **in-process** with the Android app (often within the VPN service). 

**How it works:** The Xray core Go code is compiled with `gomobile bind` into an Android AAR that contains architecture-specific .so files and auto-generated Java classes to call into Go. For example, the popular client **v2rayNG** packages the Xray core inside an AAR library (named `libv2ray.so` or similar) ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=Android%20project%20under%20V2rayNG%20folder,and%20Makefiles%20for%20Go%20Developers)). The v2rayNG project provides submodules like **AndroidLibXrayLite** which build the core into a lightweight library via Go Mobile. The build process uses commands like `gomobile bind -target=android` to produce the AAR ([GitHub - 2dust/AndroidLibXrayLite](https://github.com/2dust/AndroidLibXrayLite#:~:text=1.%20%60git%20clone%20,w%27)), targeting API level 21+ in this case. This AAR is then included in the Android Studio project.

At runtime, the app loads the native library (usually automatically via the generated Java bindings or with `System.loadLibrary`). The Go code exposes functions that the Java/Kotlin layer can call. For example, a wrapper class might have methods like `V2RayController.start(config)` or similar to initialize and run the core with a given configuration ([GitHub - dev7dev/V2ray-Android: A simple Java module with sample source for implementing V2ray/Xray on Android.](https://github.com/dev7dev/V2ray-Android#:~:text=match%20at%20L324%20V2rayController.startV2ray%28this%2C%20,null)). In **NekoRay** (an Android fork with a custom UI), a similar architecture is used – it supports Xray/v2fly cores by including the same kind of native library binding approach (likely reusing v2rayNG’s library code). When the user starts the VPN, the app’s `VpnService` invokes Go functions to start Xray core within the app’s process.

**Example – v2rayNG:** v2rayNG’s development guide notes that the “v2ray core inside the AAR” can be rebuilt from source using AndroidLibXrayLite (with GoMobile) ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=Android%20project%20under%20V2rayNG%20folder,and%20Makefiles%20for%20Go%20Developers)). This means v2rayNG calls into Go code directly via JNI rather than spawning an external process. The Go library runs in the **VPN service process**, so it can directly interact with the Android VPN API. This in-process design avoids complex IPC: the Go code can call `VpnService` methods (via callback interfaces) for things like protecting sockets or closing the VPN. In fact, running Go in-process with the VPN service means the app doesn’t need to pass file descriptors between processes – the Go code can handle the TUN interface directly if given the FD, or use Go callbacks to request Android to protect certain sockets.

**Integration details:** Projects like v2rayNG and kitsunebi-android chose this approach ([用 Golang 在 Android 上实现代理的几个问题 - Meow](https://diov.github.io/post/tips-for-golang-proxy-for-android/#:~:text=Golang%20%E5%AE%98%E6%96%B9%E5%AE%9E%E7%8E%B0%E4%BA%86%20Gomobile%20%E7%94%A8%E4%BA%8E%E7%BC%96%E8%AF%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%8F%AF%E7%94%A8%E7%9A%84%20Golang,android%E3%80%82)). The **GoMobile** tool injects a JNI interface, so from Java you call into Go as you would call any SDK method. For instance, a function to start the core might accept a JSON config string or file path and then internally launch Xray’s event loop. Status or callbacks from Go to Java are more limited (usually you define Go interfaces that GoMobile translates to Java interfaces). But basic usage (start/stop core, get core version, etc.) is easily managed via the generated bindings.

**Cross-compilation:** The Xray core is cross-compiled for Android as part of building the AAR. GoMobile automatically builds .so libraries for multiple ABIs (ARMv7, ARM64, x86_64, etc.) and packages them. This ensures the APK will contain `libxray.so` for each supported architecture under `lib/`. When the app runs, the correct native library is loaded for the device’s ABI. (If building manually without GoMobile, developers could use the NDK toolchain or Go cross-compile to produce .so files, but GoMobile greatly simplifies this by handling the NDK calls and JNI generation.)

**Advantages:** Embedding as a library keeps everything in one process. It’s easier to call Go functions directly from Kotlin/Java (no need to manage subprocess I/O) ([用 Golang 在 Android 上实现代理的几个问题 - Meow](https://diov.github.io/post/tips-for-golang-proxy-for-android/#:~:text=%E7%9B%AE%E5%89%8D%E6%9D%A5%E7%9C%8B%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%BE%88%E5%A5%BD%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%9C%A8%20Android%20%E4%B8%8A%EF%BC%8CGomobile%20%E7%9A%84%E4%BC%98%E7%82%B9%E5%B0%B1%E6%98%AF%20Java,Java%20%E5%8F%AA%E8%83%BD%E9%80%9A%E8%BF%87%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%8F%A6%E5%A4%96%E5%8C%85%E4%BD%93%E7%A7%AF%E8%BE%83%E5%A4%A7%E3%80%82%E5%85%B7%E4%BD%93%E9%80%89%E5%93%AA%E7%A7%8D%E5%B0%B1%E8%A7%81%E4%BB%81%E8%A7%81%E6%99%BA%E4%BA%86%E3%80%82)). Also, using the VPN service in-process means you can avoid extra IPC overhead for tunneling data – the Go code can read/write the VPN TUN fd directly or via Go callbacks, and you can call Android APIs like `VpnService.protect()` on sockets easily. v2rayNG and similar apps benefit from this straightforward integration. The downside is that the **APK size** can be larger (embedding the Go runtime and core for each ABI). Also, calling **back** into Java from Go is restricted – you must define interface callbacks in GoMobile (which can be a bit limited) ([用 Golang 在 Android 上实现代理的几个问题 - Meow](https://diov.github.io/post/tips-for-golang-proxy-for-android/#:~:text=%E7%9B%AE%E5%89%8D%E6%9D%A5%E7%9C%8B%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%BE%88%E5%A5%BD%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%9C%A8%20Android%20%E4%B8%8A%EF%BC%8CGomobile%20%E7%9A%84%E4%BC%98%E7%82%B9%E5%B0%B1%E6%98%AF%20Java,Java%20%E5%8F%AA%E8%83%BD%E9%80%9A%E8%BF%87%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%8F%A6%E5%A4%96%E5%8C%85%E4%BD%93%E7%A7%AF%E8%BE%83%E5%A4%A7%E3%80%82%E5%85%B7%E4%BD%93%E9%80%89%E5%93%AA%E7%A7%8D%E5%B0%B1%E8%A7%81%E4%BB%81%E8%A7%81%E6%99%BA%E4%BA%86%E3%80%82)). In practice this is not a huge issue for VPN clients, since most heavy work stays in Go.

**Real-world usage:** Aside from v2rayNG and NekoRay, the now-archived **SagerNet** app also used in-process libraries. SagerNet was a “universal proxy toolchain” supporting multiple core engines. It employed a fork of GoMobile to build not only Xray/v2ray core as a lib but also other Go proxies (like Brook, Hysteria, etc.) into plugins. In F-Droid build logs you can see SagerNet installing a custom `gomobile` and building `libcore.so` for v2ray-core ([ log: com.github.dyhkwong.sagernet:1001 - F-Droid Monitor](https://monitor.f-droid.org/builds/log/com.github.dyhkwong.sagernet/1001#:~:text=github.com%2Fv2fly%2Fv2ray)) ([ log: com.github.dyhkwong.sagernet:1001 - F-Droid Monitor](https://monitor.f-droid.org/builds/log/com.github.dyhkwong.sagernet/1001#:~:text=github,crypto%2Fsha256%20crypto%2Faes%20crypto%2Fecdh%20crypto%2Fsha512%20crypto%2Fhmac)). Like v2rayNG, SagerNet’s Kotlin code would load these libs and run the core internally. Running in-process also made it easier for SagerNet to orchestrate different proxy “engines” under one app.

## Using Xray Core as a Standalone Executable
The alternative architecture is to package the Xray core as a **standalone binary** and invoke it as an external process from the Android app. In this design, the Go binary runs in a separate OS process (forked by the app) rather than inside the app’s Dalvik/ART process. Android allows this as long as the binary is packaged with the app and has the correct permissions.

**How it works:** The Xray core can be cross-compiled for Android (producing an ELF executable) and included in the APK (often in the assets or raw resources). At runtime, the app copies this binary to a writable path (e.g. the app’s internal storage directory) and sets it executable (`chmod 700`). Then the app spawns it via `Runtime.getRuntime().exec()` or `ProcessBuilder`, passing the necessary command-line arguments (such as `-c /path/to/config.json`). The Xray process runs independently, reading the config and opening local ports or tun devices as needed.

To integrate with Android’s VPN API, apps using this model typically still use a `VpnService` in the Java layer. The `VpnService` sets up the TUN interface and then passes the file descriptor to the Xray process. Because the Xray process is separate, it **cannot directly access** the VPN interface FD owned by the parent process without help. The common solution is to send the FD through a Unix domain socket using the `SCM_RIGHTS` mechanism (ancillary messages) ([用 Golang 在 Android 上实现代理的几个问题 - Meow](https://diov.github.io/post/tips-for-golang-proxy-for-android/#:~:text=Android%20%E4%B8%8A%E4%BD%BF%E7%94%A8%20VpnService%20%E7%94%B1%E7%B3%BB%E7%BB%9F%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%20TUN,descriptor%EF%BC%8C%E9%80%9A%E8%BF%87%E8%BF%99%E4%B8%AA%20FD%20%E5%8F%AF%E4%BB%A5%E8%AF%BB%E5%8F%96%2F%E5%86%99%E5%85%A5%20IP%20packet%E3%80%82)). The Android side (VpnService) opens a local socket, attaches the TUN fd, and the Go process receives the fd and uses it. This is a known technique: Android’s **Shadowsocks** client and **ClashForAndroid** (which uses a Clash core binary) both employ it. As one developer notes, *“the child process cannot access the parent’s FD in Android’s restricted Linux environment, so you must share it via Unix socket with SCM_RIGHTS”* ([用 Golang 在 Android 上实现代理的几个问题 - Meow](https://diov.github.io/post/tips-for-golang-proxy-for-android/#:~:text=%E4%BC%9A%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%20file%20descriptor%EF%BC%8C%E9%80%9A%E8%BF%87%E8%BF%99%E4%B8%AA%20FD%20%E5%8F%AF%E4%BB%A5%E8%AF%BB%E5%8F%96%2F%E5%86%99%E5%85%A5,IP%20packet%E3%80%82)). This adds a bit of complexity: essentially an IPC channel is needed between the app and the core process. The app may also use this channel (or another pipe) to send control commands or receive status logs from the core.

**Example – ClashForAndroid:** ClashForAndroid bundles the Clash core (Go binary) and runs it as a separate process. The Android service hands off the tun interface to the Clash process and communicates via a local API socket. This approach was considered a “stable and mainstream” solution, inherited from Shadowsocks on Android ([用 Golang 在 Android 上实现代理的几个问题 - Meow](https://diov.github.io/post/tips-for-golang-proxy-for-android/#:~:text=%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%81%9A%E6%B3%95%E6%98%AF%E5%B0%86%20Golang%20%E7%BC%96%E8%AF%91%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87%20,Android%20%E5%B0%B1%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E7%AE%97%E6%98%AF%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E7%A8%B3%E5%AE%9A%E4%B8%BB%E6%B5%81%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9C%89%20ClashForAndroid%E3%80%82)). By analogy, an Android Xray client *could* do the same – package `xray` binary and run it. (There are fewer examples of Xray being run this way on Android, since most Xray clients opted for the library method. But technically something like **AnXray** or others could use the binary directly.)

**Cross-compilation:** To get an Android-compatible binary, one must compile Xray core with `GOOS=android` for each target ABI. This ensures the Go runtime uses Android syscalls (for example, standard Linux builds may have network issues on Android due to seccomp). Historically, one needed to link the binary as PIE (Position Independent Executable) for Android. For instance, building with: 

```
GOOS=android GOARCH=arm64 CGO_ENABLED=1 CC=<NDK toolchain gcc> \
   go build -ldflags="-extldflags=-pie" -o xray_arm64 ./main
``` 

will produce an ARM64 binary that Android accepts ([ Building binary executables for Android in Go · Sajal Kayan ](https://www.sajalkayan.com/post/go-android-binary.html#:~:text=sajal%40sajal,not%20stripped)) ([ Building binary executables for Android in Go · Sajal Kayan ](https://www.sajalkayan.com/post/go-android-binary.html#:~:text=It%20took%20me%20a%20while,not%20being%20in%20PIE%20format)). Modern Go versions often handle PIE automatically for android targets. The Xray project itself provides prebuilt Android binaries (without file extension) in its releases, which can be used directly. These binaries are typically ~10-15 MB and are placed in the APK’s assets. The developer must include one per supported architecture (and select the correct one at runtime, similar to how one provides multiple .so files). The APK can use the ABI splits or packaging to include the appropriate binary for each ABI.

**Invocation from Java/Kotlin:** Launching the Xray binary is done via `ProcessBuilder` or the `Runtime.exec()` API. The app might assemble a command like: `["/data/data/<app>/files/xray", "-config", "/data/data/<app>/files/config.json"]` and execute it. If needed, the app can capture the process output streams for logging. To stop the core, the app can kill the process (or the core could listen for a signal/command to shut down). Interfacing in this scenario is more “indirect” – configuration is often written to a JSON file that the Go process reads, rather than passing complex data via JNI. State monitoring might be done by reading stdout or using a local control port.

**Managing permissions and execution:** Android does not require any special permission to run an embedded binary, but the binary must be stored in a permitted location and flagged executable. Typically, the binary is copied into the app’s internal storage (`/data/data/<app>/...`) which is allowed to have executables. The app can call `new File(...).setExecutable(true)` or use a shell `chmod` command to ensure the file is executable. One must **not** store the binary on external storage/SD card, as those are mounted with `noexec`. The internal app directory is fine. Additionally, the app needs the **VpnService** permission to create the VPN interface (just as with the library approach). If the core runs in a separate process, the app usually **excludes** itself from the VPN to avoid routing loops. This can be done by `VpnService.Builder.addDisallowedApplication(appPackage)` so that the app (and its spawned process) traffic doesn’t get captured by its own VPN ([用 Golang 在 Android 上实现代理的几个问题 - Meow](https://diov.github.io/post/tips-for-golang-proxy-for-android/#:~:text=P,%E4%BA%86%E3%80%82%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E6%9C%80%E8%BF%91%E5%88%9A%E5%88%9A%E5%BC%80%E6%BA%90%E7%9A%84%20ClashForAndroid)). By excluding itself, the Xray process can make outgoing proxy connections without needing to call `protect()`. (Alternatively, the core process could send socket descriptors back to the VpnService to invoke `VpnService.protect(fd)` on them – but excluding is simpler).

**Pros and Cons:** Running Xray as a separate process has some advantages: the heavy work is out-of-process, so even if it crashes it might not crash the UI. It also isolates the Go runtime from the Android UI thread completely. In some cases, memory usage can be slightly higher due to an extra process (but it also means the Java app heap is not impacted by Go). A major benefit is that you don’t have to deal with JNI or GoMobile’s limitations – you can use the *official Xray binary directly*, and update it by replacing the file without recompiling the whole app. (This is useful if you want to let users drop in a new core version without reinstalling the APK.) One developer noted this approach is “stable [and] mainstream” since it’s used by well-known clients ([用 Golang 在 Android 上实现代理的几个问题 - Meow](https://diov.github.io/post/tips-for-golang-proxy-for-android/#:~:text=%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%81%9A%E6%B3%95%E6%98%AF%E5%B0%86%20Golang%20%E7%BC%96%E8%AF%91%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87%20,Android%20%E5%B0%B1%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E7%AE%97%E6%98%AF%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E7%A8%B3%E5%AE%9A%E4%B8%BB%E6%B5%81%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9C%89%20ClashForAndroid%E3%80%82)). The downsides are the added complexity of IPC: you need to implement a way to pass the config and TUN fd, and control the process lifecycle. It’s not as straightforward as a function call. Additionally, packaging multiple binaries (one per ABI) can bloat the APK size a bit, though you can mitigate that with Play Store’s split APKs or only including needed architectures.

## Real-World Examples

- **v2rayNG** – Uses the **shared library** approach. Xray-core (and v2fly core) are compiled into `libv2ray.so` using GoMobile. The Android app calls Go functions to start the core with a given config. As a VPN client, it runs as an Android VpnService that invokes the Go library in the same process. This design is confirmed by v2rayNG’s documentation ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=Android%20project%20under%20V2rayNG%20folder,and%20Makefiles%20for%20Go%20Developers)) and is facilitated by projects like AndroidLibXrayLite. 

- **NekoRay** – An Android client by the UWU team (inspired by v2rayNG). It supports Xray and likely follows the same pattern as v2rayNG (embedding the core as a library). The app provides a different UI skin, but under the hood it relies on the Xray/v2fly core via JNI. Given that NekoRay advertises support for Xray core, it presumably includes the AAR from AndroidLibXrayLite or similar during build.

- **SagerNet** – A now-discontinued “universal proxy toolchain” app. SagerNet was notable for supporting multiple core implementations (V2Ray/Xray, Sing-box, Shadowsocks, etc.) through a plugin system. It primarily used the **in-process library** approach: the maintainers even forked the GoMobile tool to customize bindings. SagerNet’s build scripts compiled the cores into .so libraries which the app loaded at runtime ([ log: com.github.dyhkwong.sagernet:1001 - F-Droid Monitor](https://monitor.f-droid.org/builds/log/com.github.dyhkwong.sagernet/1001#:~:text=github,anytls%2Fpipe%20os%2Fsignal)) ([ log: com.github.dyhkwong.sagernet:1001 - F-Droid Monitor](https://monitor.f-droid.org/builds/log/com.github.dyhkwong.sagernet/1001#:~:text=match%20at%20L2658%20github,org%2Fx%2Fnet%2Fhttp2%2Fhpack%20mime)). It offloaded all traffic through a VPN tunnel (VpnService) similarly to v2rayNG. SagerNet shows that even complex multi-core scenarios can be handled with the in-app approach, though it adds significant build complexity. (SagerNet could also launch external binaries for certain plugins, but the main Xray integration was in-process.)

- **Clash for Android** – (Not an Xray client per se, but instructive) uses the **external binary** model. It bundles the Clash core (written in Go) as a binary and spawns it. Communication with the Clash process is done via a local REST API or socket. This is analogous to how an Xray-based app would run the Xray binary externally. It demonstrates the viability of managing a Go VPN core as a separate process on Android ([用 Golang 在 Android 上实现代理的几个问题 - Meow](https://diov.github.io/post/tips-for-golang-proxy-for-android/#:~:text=%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%81%9A%E6%B3%95%E6%98%AF%E5%B0%86%20Golang%20%E7%BC%96%E8%AF%91%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87%20,Android%20%E5%B0%B1%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E7%AE%97%E6%98%AF%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E7%A8%B3%E5%AE%9A%E4%B8%BB%E6%B5%81%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9C%89%20ClashForAndroid%E3%80%82)).

- **AnXray** – An open-source Android client introduced in 2021, maintained by nekohasekai (a SagerNet contributor). It’s based on Xray-core and likely uses an approach similar to v2rayNG (embedding Xray via JNI). The announcement of AnXray highlighted it as a pure Xray-core Android client ([The Great Chronicles | Project X](https://xtls.github.io/en/about/news.html#:~:text=2021)), which suggests it incorporates Xray’s Go code directly rather than using v2fly. While details on its architecture are sparse, it’s reasonable to assume AnXray follows the pattern of other clients and uses either GoMobile or a direct library build of Xray core.

## Developing Your Own Android App with Xray (Go) Core
If you plan to write your own Android client incorporating the Xray core, you have two main approaches:

**1. Bundle Xray as a Native Library (.so) using GoMobile or NDK**  
   - **Compile the Go code as a shared library:** Use the Go Mobile toolchain or NDK to build Xray-core into a .so. For instance, you can create a small Go package that calls Xray’s main entry points and then run `gomobile bind -target=android` to generate an AAR. This AAR will contain the `.so` files for each ABI and a Java stub to invoke your Go methods. Projects like 2dust’s AndroidLibXrayLite illustrate this: they call `gomobile bind -androidapi 21 -ldflags='-s -w' ./` on the Xray Go package ([GitHub - 2dust/AndroidLibXrayLite](https://github.com/2dust/AndroidLibXrayLite#:~:text=1.%20%60git%20clone%20,w%27)). GoMobile takes care of using the NDK and building with the correct ARMv7/ARM64 instruction sets. Alternatively, without GoMobile, you could manually build a .so via the NDK (using CGo to create JNI wrappers), but this is more involved. GoMobile is the recommended route for ease.
   - **Integrate into your app:** Add the resulting AAR to your Android Studio project. It will provide classes (e.g. `XrayCore` or whatever you named it) that you can call from Kotlin. You might have methods to start the core with a configuration string, stop the core, get status, etc. You will likely implement a `VpnService` and within `VpnService.onStartCommand()`, call the Go function to start Xray with the VPN interface. Remember to handle VPN setup (establish the tun interface, configure routes) on the Java side or in Go – many clients do it in Java and then just let Xray run as a SOCKS/HTTP proxy bound to the tun.
   - **Permissions:** In your manifest, declare the VPN service and use `android:permission="android.permission.BIND_VPN_SERVICE"`. The user will have to grant VPN usage. No special storage or execution permissions are needed for the .so – it’s loaded as part of the app.
   - **Example resources:** The v2rayNG project is a great reference – its source shows how the Go library is invoked. Another example is the dev7dev/V2ray-Android module, which provides a ready-made Java wrapper for an Xray-based core ([GitHub - dev7dev/V2ray-Android: A simple Java module with sample source for implementing V2ray/Xray on Android.](https://github.com/dev7dev/V2ray-Android#:~:text=A%20simple%20Java%20module%20with,implement%20the%20v2ray%20on%20Android)) ([GitHub - dev7dev/V2ray-Android: A simple Java module with sample source for implementing V2ray/Xray on Android.](https://github.com/dev7dev/V2ray-Android#:~:text=V2rayController.startV2ray%28this%2C%20)). You can also refer to the official GoMobile documentation on binding Go for Android ([用 Golang 在 Android 上实现代理的几个问题 - Meow](https://diov.github.io/post/tips-for-golang-proxy-for-android/#:~:text=Golang%20%E5%AE%98%E6%96%B9%E5%AE%9E%E7%8E%B0%E4%BA%86%20Gomobile%20%E7%94%A8%E4%BA%8E%E7%BC%96%E8%AF%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%8F%AF%E7%94%A8%E7%9A%84%20Golang,android%E3%80%82)). This approach is convenient if you want all-in-one APK and direct function calls. Keep in mind the size overhead (Go runtime ~5-6MB per ABI) and complexity of updating the core (you’d need to rebuild the library to update Xray version).

**2. Bundle Xray as a Command-Line Executable**  
   - **Cross-compile Xray for Android:** Use the Go compiler to build the Xray-core main program for each target ABI. Set `GOOS=android` and the appropriate `GOARCH` (e.g. `arm64`, `386`, `amd64`, `arm` for 32-bit). Ensure you compile as PIE. For example, to build for 64-bit ARM:  
     ```bash
     GOOS=android GOARCH=arm64 go build -trimpath -ldflags="-s -w -extldflags=-pie" -o xray_arm64 ./main
     ```  
     This will produce an **xray_arm64** binary. Repeat for other architectures (arm, amd64, etc.) or use a script. The official Xray-core repo might already provide these binaries (often named `Xray-android-arm64-v8a` etc., which you can use directly). Verify the binary works on a device (you can use `file` command to ensure it’s an ELF for Android ([ Building binary executables for Android in Go · Sajal Kayan ](https://www.sajalkayan.com/post/go-android-binary.html#:~:text=sajal%40sajal,lappy))). The binary should be dynamically linked against Android’s Bionic libc and marked as PIE; otherwise Android 6.0+ will refuse to load it ([ Building binary executables for Android in Go · Sajal Kayan ](https://www.sajalkayan.com/post/go-android-binary.html#:~:text=It%20took%20me%20a%20while,not%20being%20in%20PIE%20format)).
   - **Include in APK and install:** Place the compiled binaries in your app’s `src/main/assets` or `raw` resources. At runtime, determine the device ABI (Android’s Build.SUPPORTED_ABIS) and copy the corresponding binary to internal storage. For example, copy from assets to `context.getFilesDir()/xray` file. Then use `File.setExecutable(true)` to make it executable. (Alternatively, you can package the binaries in the `lib/` folder by renaming them with a `.so` extension. Android will extract them to `/lib/<arch>`. Despite the `.so` name, you can still execute them as binaries. Some developers use this trick to avoid the manual copy, since the libs in `/data/app/.../lib` are already executable by default.)
   - **Run the process:** Use a Service (probably a VpnService) to launch the binary. Using `ProcessBuilder` is common: e.g. 
     ```kotlin
     ProcessBuilder("${filesDir.path}/xray", "-config", "${filesDir.path}/config.json")
         .redirectErrorStream(true)
         .start()
     ``` 
     This starts the core. Make sure to supply the configuration. You can write a JSON config file or use environment variables/flags as Xray supports. The process will run independently. Your app should show a persistent notification (as required by VpnService). If using VpnService, after `VpnService.Builder.establish()` to get the TUN fd, pass that fd to the Xray process. One way is to launch Xray with an environment variable or argument that points to the FD (some clients use `/proc/self/fd/<n>` trick or a custom flag in Xray to inherit an fd). If Xray-core doesn’t natively support receiving an existing tun fd, you may need a helper like `tun2socks` or use the local socket method described earlier.
   - **Communication & control:** Consider how to stop the Xray process. You might simply keep a reference to the `Process` object and call `destroy()` on it when you want to stop VPN. For more graceful control, you could send a signal or use Xray’s built-in admin port (if any) to shut it down. Logging can be captured from the process’ InputStream. For more advanced control, set up a local Unix socket that both Java and Xray listen on – you can define simple commands or use it to send the tun file descriptor. This is exactly how Clash and Shadowsocks Android clients operate ([用 Golang 在 Android 上实现代理的几个问题 - Meow](https://diov.github.io/post/tips-for-golang-proxy-for-android/#:~:text=%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%81%9A%E6%B3%95%E6%98%AF%E5%B0%86%20Golang%20%E7%BC%96%E8%AF%91%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87%20,Android%20%E5%B0%B1%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E7%AE%97%E6%98%AF%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E7%A8%B3%E5%AE%9A%E4%B8%BB%E6%B5%81%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9C%89%20ClashForAndroid%E3%80%82)).
   - **Pros/Cons:** This route can be simpler in terms of **build** (no JNI or special Gradle tasks – you just drop in the binary). It also decouples the core version from the app: updating the core is as easy as shipping a new binary file. However, you need to handle compatibility across architectures and the runtime interaction is more complex than function calls. Performance-wise, the overhead of a separate process and IPC is usually small, but the benefit is the Go GC and heavy crypto runs outside the Android app’s VM, which can sometimes improve overall app responsiveness. On the other hand, debugging issues might be harder since you can’t easily debug the Go code via Android Studio. 
   - **Example references:** You can study the **Clash for Android** source or Shadowsocks for Android to see how they execute binaries and communicate. The article *“Using Golang on Android for proxy – issues and tips”* by Dio Ye (in Chinese) specifically compares the two approaches and provides pseudo-code for IPC (file descriptor passing and protecting sockets) ([用 Golang 在 Android 上实现代理的几个问题 - Meow](https://diov.github.io/post/tips-for-golang-proxy-for-android/#:~:text=Android%20%E4%B8%8A%E4%BD%BF%E7%94%A8%20VpnService%20%E7%94%B1%E7%B3%BB%E7%BB%9F%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%20TUN,descriptor%EF%BC%8C%E9%80%9A%E8%BF%87%E8%BF%99%E4%B8%AA%20FD%20%E5%8F%AF%E4%BB%A5%E8%AF%BB%E5%8F%96%2F%E5%86%99%E5%85%A5%20IP%20packet%E3%80%82)) ([用 Golang 在 Android 上实现代理的几个问题 - Meow](https://diov.github.io/post/tips-for-golang-proxy-for-android/#:~:text=%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%81%9A%E6%B3%95%E6%98%AF%E5%B0%86%20Golang%20%E7%BC%96%E8%AF%91%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87%20,Android%20%E5%B0%B1%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E7%AE%97%E6%98%AF%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E7%A8%B3%E5%AE%9A%E4%B8%BB%E6%B5%81%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9C%89%20ClashForAndroid%E3%80%82)). Also, Sajal Kayan’s blog post on building Go binaries for Android explains the cross-compilation flags needed ([ Building binary executables for Android in Go · Sajal Kayan ](https://www.sajalkayan.com/post/go-android-binary.html#:~:text=sajal%40sajal,lappy%3A~%24%20file%20minion)). These resources will help you avoid common pitfalls (like missing PIE or blocked syscalls).

## Conclusion
Both embedding strategies are widely used and proven for Android VPN clients. In summary, embedding Xray-core as a library (using GoMobile) offers tight integration with easier function calls (used by v2rayNG, NekoRay, etc.), whereas using a standalone Xray binary provides process isolation and flexibility (analogous to how ClashForAndroid works, and theoretically usable for Xray as well). The Xray core is indeed cross-compiled for Android in all these cases – either into a `.so` or an executable – and must be packaged with the app since it’s not available on the device otherwise. Android’s sandbox allows such binaries to run, provided you manage the file permissions and follow VPN Service requirements. 

When developing your own app, choose the approach that fits your needs: **GoMobile (JNI)** if you want a cleaner API and don’t mind the larger APK and build complexity, or **external binary** if you prefer treating Xray as a black-box engine you can start/stop. Many developers lean toward GoMobile for Xray because it was recommended by Xray’s maintainers (“gomobile is the way to go” for Android ([Using X-Ray Core for Android · Issue #2808 · XTLS/Xray-core · GitHub](https://github.com/XTLS/Xray-core/issues/2808#:~:text=yuhan6665%20%20%20commented%20,74))). On the other hand, if you foresee frequently updating the core or using multiple cores, the binary approach might be easier to maintain (as SagerNet did for plugin cores). 

With either approach, Android’s Java/Kotlin layer remains in control of the UI, configuration, and VPN permission, while the Go-based Xray core handles the heavy network translation work. By examining open-source clients like v2rayNG ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=Android%20project%20under%20V2rayNG%20folder,and%20Makefiles%20for%20Go%20Developers)) and following Go mobile binding guides, a developer can successfully integrate Xray-core into a custom Android app and leverage its powerful proxy capabilities on mobile.

**Sources:**

- v2rayNG project documentation and README ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=Android%20project%20under%20V2rayNG%20folder,and%20Makefiles%20for%20Go%20Developers))  
- AndroidLibXrayLite build instructions (GoMobile usage) ([GitHub - 2dust/AndroidLibXrayLite](https://github.com/2dust/AndroidLibXrayLite#:~:text=2.%20,w%27))  
- Dio Ye, *Using Golang for Android proxies – Gomobile vs Executable* (Chinese) ([用 Golang 在 Android 上实现代理的几个问题 - Meow](https://diov.github.io/post/tips-for-golang-proxy-for-android/#:~:text=Golang%20%E5%AE%98%E6%96%B9%E5%AE%9E%E7%8E%B0%E4%BA%86%20Gomobile%20%E7%94%A8%E4%BA%8E%E7%BC%96%E8%AF%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%8F%AF%E7%94%A8%E7%9A%84%20Golang,android%E3%80%82)) ([用 Golang 在 Android 上实现代理的几个问题 - Meow](https://diov.github.io/post/tips-for-golang-proxy-for-android/#:~:text=%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%81%9A%E6%B3%95%E6%98%AF%E5%B0%86%20Golang%20%E7%BC%96%E8%AF%91%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87%20,Android%20%E5%B0%B1%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E7%AE%97%E6%98%AF%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E7%A8%B3%E5%AE%9A%E4%B8%BB%E6%B5%81%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9C%89%20ClashForAndroid%E3%80%82)) ([用 Golang 在 Android 上实现代理的几个问题 - Meow](https://diov.github.io/post/tips-for-golang-proxy-for-android/#:~:text=%E7%9B%AE%E5%89%8D%E6%9D%A5%E7%9C%8B%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%BE%88%E5%A5%BD%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%9C%A8%20Android%20%E4%B8%8A%EF%BC%8CGomobile%20%E7%9A%84%E4%BC%98%E7%82%B9%E5%B0%B1%E6%98%AF%20Java,Java%20%E5%8F%AA%E8%83%BD%E9%80%9A%E8%BF%87%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%8F%A6%E5%A4%96%E5%8C%85%E4%BD%93%E7%A7%AF%E8%BE%83%E5%A4%A7%E3%80%82%E5%85%B7%E4%BD%93%E9%80%89%E5%93%AA%E7%A7%8D%E5%B0%B1%E8%A7%81%E4%BB%81%E8%A7%81%E6%99%BA%E4%BA%86%E3%80%82)) ([用 Golang 在 Android 上实现代理的几个问题 - Meow](https://diov.github.io/post/tips-for-golang-proxy-for-android/#:~:text=%E4%BC%9A%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%20file%20descriptor%EF%BC%8C%E9%80%9A%E8%BF%87%E8%BF%99%E4%B8%AA%20FD%20%E5%8F%AF%E4%BB%A5%E8%AF%BB%E5%8F%96%2F%E5%86%99%E5%85%A5,IP%20packet%E3%80%82))  
- Sajal Kayan, *Building binary executables for Android in Go* ([ Building binary executables for Android in Go · Sajal Kayan ](https://www.sajalkayan.com/post/go-android-binary.html#:~:text=sajal%40sajal,lappy%3A~%24%20file%20minion)) ([ Building binary executables for Android in Go · Sajal Kayan ](https://www.sajalkayan.com/post/go-android-binary.html#:~:text=It%20took%20me%20a%20while,not%20being%20in%20PIE%20format))  
- dev7dev’s V2Ray-Android example (Java integration with Xray core) ([GitHub - dev7dev/V2ray-Android: A simple Java module with sample source for implementing V2ray/Xray on Android.](https://github.com/dev7dev/V2ray-Android#:~:text=A%20simple%20Java%20module%20with,implement%20the%20v2ray%20on%20Android)) ([GitHub - dev7dev/V2ray-Android: A simple Java module with sample source for implementing V2ray/Xray on Android.](https://github.com/dev7dev/V2ray-Android#:~:text=V2rayController.startV2ray%28this%2C%20))  
- F-Droid build logs for SagerNet (indicating custom gomobile build of core) ([ log: com.github.dyhkwong.sagernet:1001 - F-Droid Monitor](https://monitor.f-droid.org/builds/log/com.github.dyhkwong.sagernet/1001#:~:text=github.com%2Fv2fly%2Fv2ray)).