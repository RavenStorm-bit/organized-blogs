Understood. I’ll study how the v2rayNG project uses gomobile to compile an AAR containing the Xray-core Go code. I’ll walk through the exact steps, toolchain setup, environment variables, and build process, including how gomobile handles JNI bindings and packaging into the AAR.

I’ll also include background on how gomobile works, how JNI is bridged, and how Android integrates these AARs in Kotlin apps.

I’ll get back to you shortly with a complete technical walkthrough.

# Building the Xray Core AAR for Android in *v2rayNG*: A Technical Case Study

## Overview and Context  
The **v2rayNG** Android app relies on a Go-based core (Xray or V2Fly) for its proxy and VPN functionality. Instead of embedding a native binary directly, the project uses **Gomobile** to compile the Go Xray-core into an **Android AAR (Android Archive)** library. This AAR (often named **`libv2ray.aar`**) includes pre-compiled native `.so` libraries and generated Java bindings, allowing the Android app to call Go functions seamlessly. By modularizing the core as an AAR, v2rayNG cleanly separates the UI/logic (Kotlin) from the networking core (Go), and can update the core by swapping the AAR. In this guide, we detail the step-by-step build process, the internal mechanics of Gomobile’s binding (JNI generation and packaging), the contents of the AAR, and how v2rayNG integrates this library (including handling multiple CPU ABIs and data files like geosite.dat). 

## Environment Setup for Gomobile Build  
Building the Xray core AAR requires a proper Go and Android build environment:

- **Go Toolchain**: Install Go (at least Go 1.16+, newer is better for Xray-core). Recent guides use Go 1.22.1 on 64-bit Ubuntu 22.04 ([Ubuntu下使用GoMobile构建AndroidLibXrayLite/AndroidLibV2rayLite的arr包 | kdsunset的个人博客](https://kdsunset.top/gomv2ray/index.html#:~:text=,go%201.22.1)). Ensure `$GOROOT/bin` is in PATH.
- **Android SDK & NDK**: Install the Android SDK (with Build Tools) and the Android NDK. Gomobile needs the NDK to cross-compile Go for ARM/ARM64/x86. For example, Android SDK API 34 and NDK r26.2 were used in a 2024 build setup ([Ubuntu下使用GoMobile构建AndroidLibXrayLite/AndroidLibV2rayLite的arr包 | kdsunset的个人博客](https://kdsunset.top/gomv2ray/index.html#:~:text=,go%201.22.1)). After installation, set environment variables `ANDROID_HOME` (SDK path) and `ANDROID_NDK_HOME` (NDK path) ([Ubuntu下使用GoMobile构建AndroidLibXrayLite/AndroidLibV2rayLite的arr包 | kdsunset的个人博客](https://kdsunset.top/gomv2ray/index.html#:~:text=,11394342%20export%20PATH%3D%24PATH%3A%24ANDROID_NDK_HOME)), or ensure the default SDK/NDK locations are used. The NDK version must support API 21–34 (the range that Gomobile expects by default) – using a too-old or mismatched NDK causes errors (e.g. *“unsupported API version 19 (not in 21..34)”* ([Ubuntu下使用GoMobile构建AndroidLibXrayLite/AndroidLibV2rayLite的arr包 | kdsunset的个人博客](https://kdsunset.top/gomv2ray/index.html#:~:text=1))).
- **Java JDK**: Install JDK (Java 8 or higher; JDK 11+ recommended). OpenJDK 17 was used in the example setup ([Ubuntu下使用GoMobile构建AndroidLibXrayLite/AndroidLibV2rayLite的arr包 | kdsunset的个人博客](https://kdsunset.top/gomv2ray/index.html#:~:text=,go%201.22.1)). Ensure `javac` is in PATH.
- **Gomobile tool**: Gomobile is a Go command for mobile builds. Install it by running: `go install golang.org/x/mobile/cmd/gomobile@latest`. After installation, initialize it with `gomobile init` to download required dependencies (Android API jar, etc) ([Ubuntu下使用GoMobile构建AndroidLibXrayLite/AndroidLibV2rayLite的arr包 | kdsunset的个人博客](https://kdsunset.top/gomv2ray/index.html#:~:text=)). This command must be run after setting Android SDK/NDK env variables, as it checks for the SDK/NDK and configures build caches.

Once Go, Android SDK/NDK, JDK, and Gomobile are ready, you can proceed to build the AAR.

## Step-by-Step: Building the **AndroidLibXrayLite** AAR  
The **AndroidLibXrayLite** project is essentially a Go module that wraps Xray-core for Android. It’s published by v2rayNG’s author as an open-source library (LGPL-3.0) and contains the Go code and build scripts. The build steps are straightforward:

1. **Checkout the source**: Clone the repository and enter it. For example:  
   ```bash
   git clone https://github.com/2dust/AndroidLibXrayLite.git && cd AndroidLibXrayLite
   ```  
   (There is a similar **AndroidLibV2rayLite** for V2Ray’s core – but for Xray core, use AndroidLibXrayLite ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=outdated,and%20Makefiles%20for%20Go%20Developers)).)

2. **Initialize Gomobile**: Ensure you’ve run `gomobile init` at least once in your Go environment ([Ubuntu下使用GoMobile构建AndroidLibXrayLite/AndroidLibV2rayLite的arr包 | kdsunset的个人博客](https://kdsunset.top/gomv2ray/index.html#:~:text=%E5%91%BD%E4%BB%A4%EF%BC%9A%60gomobile%20bind%20,w%27%20.%2F%60%E3%80%82%20%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A%EF%BC%9A)). This needs to be done only once per setup (it installs the Android API platform jar and other support files Gomobile needs).

3. **Tidy Go modules**: Run `go mod tidy -v` to download and sync all Go module dependencies ([Ubuntu下使用GoMobile构建AndroidLibXrayLite/AndroidLibV2rayLite的arr包 | kdsunset的个人博客](https://kdsunset.top/gomv2ray/index.html#:~:text=,v)). This will fetch the Xray-core module and any other requirements. (AndroidLibXrayLite’s `go.mod` pins a specific Xray-core version – for example, recent releases correspond to Xray-core v1.8.x – ensuring consistency).

4. **Bind and compile to AAR**: Run the Gomobile bind command with appropriate flags:  
   ```bash
   gomobile bind -v -androidapi 21 -ldflags="-s -w" ./
   ```  
   **Explanation**: `gomobile bind` generates language bindings and builds an AAR library from the current Go package (denoted by `./`). We specify:  
   • **`-androidapi 21`**: Set minimum Android API level to 21 (Android 5.0), which is the lowest supported by v2rayNG. This ensures the compiled native libs target API 21.  
   • **`-ldflags="-s -w"`**: Strip the Go binaries of symbol table and debug info to reduce size. (The Xray core is large, so stripping saves space).  
   • **`-v`**: Enable verbose output to see progress and any warnings.  

   Gomobile will take some time to compile (it builds for multiple ABIs sequentially). On success, it produces two key output files in the current directory: **`libv2ray.aar`** and `libv2ray-sources.jar` ([Ubuntu下使用GoMobile构建AndroidLibXrayLite/AndroidLibV2rayLite的arr包 | kdsunset的个人博客](https://kdsunset.top/gomv2ray/index.html#:~:text=gomobile%20bind%20,w%27)) ([Ubuntu下使用GoMobile构建AndroidLibXrayLite/AndroidLibV2rayLite的arr包 | kdsunset的个人博客](https://kdsunset.top/gomv2ray/index.html#:~:text=%E8%80%90%E5%BF%83%E7%AD%89%E5%BE%85%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%88%90%EF%BC%8C%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%88%90%E5%90%8E%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E7%9A%84%20%60libv2ray.aar%20%60%E5%92%8C%20%60libv2ray)). The AAR is the packaged Android library, and the sources JAR contains the generated Java source (optional for debugging or inspection).

   > **Note:** The AAR name is `libv2ray.aar` because the Go package in AndroidLibXrayLite is named “libv2ray” ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=package%20libv2ray)). (Both the V2Fly and Xray versions use the same package name so that the app code can remain agnostic to which core is used.) By default, `gomobile bind` names the output `<packagename>.aar` ([v2raylib.aar · Issue #2277 · 2dust/v2rayNG · GitHub](https://github.com/2dust/v2rayNG/issues/2277#:~:text=file%20that%20archives%20the%20precompiled,This%20requires%20%27javac)).

5. **(Optional) Include Geoip/Geosite data**: The AAR build can bundle asset files if they are placed in an `assets/` directory in the Go project ([v2raylib.aar · Issue #2277 · 2dust/v2rayNG · GitHub](https://github.com/2dust/v2rayNG/issues/2277#:~:text=For%20,This%20requires%20%27javac)). AndroidLibXrayLite provides a script `gen_assets.sh` to download the latest `geoip.dat` and `geosite.dat` files from an external repository ([AndroidLibXrayLite/gen_assets.sh at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/gen_assets.sh#:~:text=download_dat%28%29%20)) ([AndroidLibXrayLite/gen_assets.sh at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/gen_assets.sh#:~:text=ACTION%3D%22%24%7B1%3A)). This script saves them under a `data/` folder by default, but you could move them to `assets/` before binding if you wanted the AAR to include these as assets. In practice, v2rayNG **does not bundle these data files in the AAR** (to keep size small and allow updates). Instead, v2rayNG downloads or expects these files at runtime (stored under app external storage, e.g. `Android/data/com.v2ray.ang/files/assets` on the device ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=))). So it’s common to build the AAR without any assets and handle geosite/geoip in the app.

After these steps, you will have the AAR library ready. At this point, you can import the AAR into the Android app (either via Gradle or Android Studio’s import wizard). The **v2rayNG** project doesn’t commit the AAR in its repo (to avoid bloating the repo and due to license considerations), so developers either download a prebuilt AAR or build it themselves ([github - how to Build V2ray in android studio - Stack Overflow](https://stackoverflow.com/questions/75517519/how-to-build-v2ray-in-android-studio#:~:text=I%20have%20the%20same%20problem,try%20one%20of%20these%20options)) ([github - how to Build V2ray in android studio - Stack Overflow](https://stackoverflow.com/questions/75517519/how-to-build-v2ray-in-android-studio#:~:text=,Recommended)).

## What’s Inside the AAR: Multi-ABI Libraries and Bindings  
An AAR is essentially a zip archive for Android libraries. The **libv2ray.aar** produced by Gomobile contains:

- **Native .so libraries for multiple ABIs**: By default, Gomobile builds for all supported Android architectures: armeabi-v7a (32-bit ARM), arm64-v8a (64-bit ARM), x86, and x86_64 ([v2raylib.aar · Issue #2277 · 2dust/v2rayNG · GitHub](https://github.com/2dust/v2rayNG/issues/2277#:~:text=package%20prefix%20for%20the%20generated,classes)). The AAR will have `jni/armeabi-v7a/libgojni.so`, `jni/arm64-v8a/libgojni.so`, etc. (Gomobile uses the name “gojni” for the compiled library internally ([bind/java/LoadJNI.java - mobile.git - Git at Google](https://go.googlesource.com/mobile.git/+/6fa95d984e88af20c7b8869192a2345dc560fdbf/bind/java/LoadJNI.java#:~:text=private%20static%20Logger%20log%20%3D,invoke%28null)) ([bind/java/LoadJNI.java - mobile.git - Git at Google](https://go.googlesource.com/mobile.git/+/6fa95d984e88af20c7b8869192a2345dc560fdbf/bind/java/LoadJNI.java#:~:text=static%20%7B%20System.loadLibrary%28,Exception%20e%29))). Each .so contains the Go core (Xray) compiled for that architecture, along with JNI bridge code. These .so libraries are what the app ultimately loads at runtime.

- **Java wrapper classes (compiled)**: Gomobile generates a set of Java classes that act as the API for the Go library. These are output as `.class` files (and packaged as classes.jar inside the AAR). The `libv2ray-sources.jar` contains the human-readable Java source for these. Key generated classes include:  
  - `libv2ray.Libv2ray`: a utility class with static methods corresponding to Go package-level functions (e.g., `Libv2ray.checkVersionX()` for the Go `CheckVersionX()` function).  
  - Classes for each exported Go type, e.g., `libv2ray.V2RayPoint`, `libv2ray.ProtectedDialer`, etc., mirroring the Go structures. These classes have methods matching the Go methods (e.g., `V2RayPoint.runLoop()` calls the Go `RunLoop` method).  
  - An interface (or abstract class) for any Go interface type. Notably, the Go interface `V2RayVPNServiceSupportsSet` becomes a Java interface `libv2ray.V2RayVPNServiceSupportsSet` that the Android app must implement. This interface defines callbacks that the Go core will invoke (like `setup(...)`, `protect(...)`, etc., described below).

- **JNI glue code**: The AAR’s `.so` files also include the JNI code that bridges the Java and Go worlds. Gomobile auto-generates C/C++ code to register native methods and manage calls between languages. You won’t see these as separate files in the AAR, but they are embedded in the native libraries. For example, a Java method `V2RayPoint.runLoop()` is actually a native method that JNI-calls into the Go runtime to execute the Go `RunLoop` function.

- **Optional assets**: If the Go package had an `assets/` directory, its contents would be copied into the AAR’s `assets/` folder ([v2raylib.aar · Issue #2277 · 2dust/v2rayNG · GitHub](https://github.com/2dust/v2rayNG/issues/2277#:~:text=For%20,This%20requires%20%27javac)). (For AndroidLibXrayLite, this is usually empty unless you manually added assets as discussed.)

Importantly, Gomobile ensures the Java stubs will automatically load the native .so at runtime. The generated Java code includes a static initializer that calls `System.loadLibrary("gojni")` to load the correct native library for the device’s ABI ([bind/java/LoadJNI.java - mobile.git - Git at Google](https://go.googlesource.com/mobile.git/+/6fa95d984e88af20c7b8869192a2345dc560fdbf/bind/java/LoadJNI.java#:~:text=private%20static%20Logger%20log%20%3D,invoke%28null)) ([bind/java/LoadJNI.java - mobile.git - Git at Google](https://go.googlesource.com/mobile.git/+/6fa95d984e88af20c7b8869192a2345dc560fdbf/bind/java/LoadJNI.java#:~:text=static%20%7B%20System.loadLibrary%28,Exception%20e%29)). It uses a helper class `go.LoadJNI` and `go.Seq` (in the package `go`) for this bootstrap process ([gomobile-java/bind/java/Seq.java at master · sridharv/gomobile-java · GitHub](https://github.com/sridharv/gomobile-java/blob/master/bind/java/Seq.java#:~:text=static%20)) ([gomobile-java/bind/java/Seq.java at master · sridharv/gomobile-java · GitHub](https://github.com/sridharv/gomobile-java/blob/master/bind/java/Seq.java#:~:text=%2F%2F%20Its%20only%20purpose%20is,loadLibrary)). So as soon as you use any class from `libv2ray` in the app, the underlying native library will be loaded.

### Exported Go API and Corresponding Java API  
The AndroidLibXrayLite project’s Go code defines the API surface that will be exposed to Android. Reviewing its source (package `libv2ray`), the key exported pieces are:

- **Functions:** 
  - `CheckVersionX() string` – returns a version string for the binding and Xray-core. For example: “Lib v30, Xray-core v1.8.3” ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=%2F%2F%20CheckVersionX%20returns%20the%20library,and%20V2Ray%20versions)). This helps the app verify which core version is in use.
  - `InitV2Env(envPath string, key string)` – (likely initializes environment, not as commonly used in recent code).
  - `MeasureOutboundDelay(configContent string, url string) (int64, error)` – allows the app to measure the latency of a given outbound configuration toward a URL ([libv2ray package - github.com/2dust/AndroidLibXrayLite - Go Packages](https://pkg.go.dev/github.com/2dust/AndroidLibXrayLite#:~:text=,Conn%2C%20error)) (useful for testing server latency).
  
  These become static methods in the `Libv2ray` class, e.g. `Libv2ray.checkVersionX(): String`. The app can call them directly. For instance, v2rayNG calls `Libv2ray.checkVersionX()` at startup to log the core version.

- **The Vpn Service interface:** 
  - `type V2RayVPNServiceSupportsSet interface { … }` – this Go interface defines callbacks that the Go core expects the Android VPN service to implement ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=%2F%2F%20V2RayVPNServiceSupportsSet%20is%20an%20interface,to%20support%20Android%20VPN%20mode)). Methods include: `Setup(conf string) int`, `Prepare() int`, `Shutdown() int`, `Protect(fd int) bool`, and `OnEmitStatus(code int, msg string) int` ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=type%20V2RayVPNServiceSupportsSet%20interface%20)) ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=Shutdown)). These correspond to tasks like configuring the VPN interface, cleaning up, protecting sockets (using Android’s VpnService.protect), etc.  
  Gomobile generates a Java interface `V2RayVPNServiceSupportsSet` with the same methods (the names are lowercased in Java due to language conventions). The Android service (written in Kotlin) will implement this interface, so that the Go code can call back into Android. We’ll see this integration below.

- **Core controller types:** 
  - `type V2RayPoint struct { … }` – This is a struct that holds a running instance of the Xray core and related state ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=SupportSet%20V2RayVPNServiceSupportsSet)). It has methods to start and stop the core:
    - `NewV2RayPoint(s V2RayVPNServiceSupportsSet, adns bool) *V2RayPoint` – constructor that takes the support interface implementation and a flag for async DNS resolve ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=%2F%2F%20NewV2RayPoint%20creates%20a%20new,V2RayPoint%20instance)) ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=dialer%20%3A%3D%20NewProtectedDialer)). It returns a new `V2RayPoint` object (or `null` on failure).
    - `(*V2RayPoint) RunLoop(prefIPv6 bool) error` – starts the V2Ray event loop (runs the core with the current configuration) ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=%2F%2F%20RunLoop%20runs%20the%20V2Ray,main%20loop)) ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=v)).
    - `(*V2RayPoint) StopLoop() error` – stops the core loop and cleans up ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=%2F%2F%20StopLoop%20stops%20the%20V2Ray,main%20loop)) ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=close%28v)).
    - `(*V2RayPoint) QueryStats(tag, direction string) int64` – gets traffic statistics for a given tag ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=%2F%2F%20QueryStats%20returns%20the%20traffic,a%20given%20tag%20and%20direction)).
    - `(*V2RayPoint) MeasureDelay(url string) int64` – (if the core is running) measure latency to a URL via the proxy.
    
    In Java/Kotlin, `V2RayPoint` becomes a class. `Libv2ray.newV2RayPoint(V2RayVPNServiceSupportsSet s, boolean adns)` is the factory method (returning a `V2RayPoint` object), and `runLoop()`, `stopLoop()`, etc. are instance methods on that object.

  - `type ProtectedDialer struct { … }` – A struct that implements custom DNS resolution and dialing, integrating with Android’s network (the protect mechanism) ([AndroidLibXrayLite/libv2ray_support.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_support.go#:~:text=type%20ProtectedDialer%20struct%20)) ([AndroidLibXrayLite/libv2ray_support.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_support.go#:~:text=%2F%2F%20IsVServerReady%20checks%20if%20the,virtual%20server%20is%20ready)). It has:
    - `NewProtectedDialer(p protectSet) *ProtectedDialer` – constructor that takes a `protectSet` (which is basically the same as V2RayVPNServiceSupportsSet, to use its `Protect()` method) ([AndroidLibXrayLite/libv2ray_support.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_support.go#:~:text=func%20NewProtectedDialer%28p%20protectSet%29%20)).
    - Methods like `Dial(ctx, src, dest, sockopt) (net.Conn, error)`, `IsVServerReady() bool`, `PrepareDomain(name, chan, prefIPv6)`, etc. ([libv2ray package - github.com/2dust/AndroidLibXrayLite - Go Packages](https://pkg.go.dev/github.com/2dust/AndroidLibXrayLite#:~:text=,52)) ([libv2ray package - github.com/2dust/AndroidLibXrayLite - Go Packages](https://pkg.go.dev/github.com/2dust/AndroidLibXrayLite#:~:text=,50)). These allow the Go core to perform DNS lookups via Android and to open sockets that bypass the VPN when necessary (using the provided `Protect()` callback to avoid routing loops).  
    In the Java binding, `ProtectedDialer` is a class mostly used internally by the library; v2rayNG doesn’t need to call its methods directly (they’re invoked by the core). 

In summary, **AndroidLibXrayLite exposes a minimal API**: create a `V2RayPoint`, start it, stop it, measure delays, and implement a few callbacks for VPN support. This design is intentional – by keeping only high-level controls, the complex internals of Xray (routing, protocols, etc.) remain encapsulated in Go.

## Integration into the v2rayNG App (Kotlin Side)  
With the AAR built and included in the Android project, v2rayNG integrates it as follows:

### Including the AAR in the Project  
v2rayNG includes the AAR as a library module. In the Gradle config, it is referenced as module `:libv2ray`. For example, the app’s `build.gradle` has `compile project(':libv2ray')` ([V2RayNG/v2rayNG/V2rayNG/app/build.gradle at master · v2ray/V2RayNG · GitHub](https://github.com/v2ray/V2RayNG/blob/master/v2rayNG/V2rayNG/app/build.gradle#:~:text=compile%20project)). This suggests that developers import the AAR into Android Studio which creates a module (named libv2ray) or they manually include it in the Gradle settings. Another common approach is to drop the AAR into `app/libs` and use `implementation files('libs/libv2ray.aar')`. In either case, the classes from the AAR become available to the app. (If the AAR is missing, the app won’t compile – e.g., you’d get errors like *“unresolved reference: libv2ray”* ([github - how to Build V2ray in android studio - Stack Overflow](https://stackoverflow.com/questions/75517519/how-to-build-v2ray-in-android-studio#:~:text=app,Libv2ray)) ([github - how to Build V2ray in android studio - Stack Overflow](https://stackoverflow.com/questions/75517519/how-to-build-v2ray-in-android-studio#:~:text=I%20want%20to%20run%20v2ray,me%20to%20find%20the%20solution)), which many new builders of v2rayNG encounter until they add the AAR ([github - how to Build V2ray in android studio - Stack Overflow](https://stackoverflow.com/questions/75517519/how-to-build-v2ray-in-android-studio#:~:text=I%20have%20the%20same%20problem,try%20one%20of%20these%20options)).)

After inclusion, the app can import the generated classes. In v2rayNG’s Kotlin code, you’ll see imports like:  
```kotlin
import libv2ray.Libv2ray  
import libv2ray.V2RayPoint  
import libv2ray.V2RayVPNServiceSupportsSet  
```  
These correspond to the AAR’s packages. The `go.Seq` and `go.LoadJNI` classes are also imported behind the scenes (usually handled automatically; the app code typically doesn’t need to touch these).

### Initializing and Running the Core  
v2rayNG’s VPN service class (which extends Android `VpnService`) is where the Go library is used. The service class implements the `V2RayVPNServiceSupportsSet` interface provided by the AAR. For example, in Kotlin it will have:  
```kotlin
class V2RayVpnService : VpnService(), V2RayVPNServiceSupportsSet { … }
```  
And inside, it implements the required methods: `override fun prepare(): Long`, `override fun setup(s: String): Long`, `override fun protect(fd: Long): Long`, `override fun shutdown(): Long`, `override fun onEmitStatus(code: Long, msg: String?): Long`. These map to the Go interface (with some differences in types due to language mapping). For instance, the Go `Protect(int) bool` becomes `protect(fd: Long): Long` in Kotlin – returning 0 for true/success and 1 for false (the implementation calls Android’s `VpnService.protect(int)` and returns 0/1 accordingly) ([V2RayNG/v2rayNG/V2rayNG/app/src/main/kotlin/com/v2ray/ang/service/V2RayVpnService.kt at master · v2ray/V2RayNG · GitHub](https://github.com/v2ray/V2RayNG/blob/master/v2rayNG/V2rayNG/app/src/main/kotlin/com/v2ray/ang/service/V2RayVpnService.kt#:~:text=override%20fun%20protect,toLong)). Similarly, `setup(s: String): Long` in Kotlin will configure the VPN interface and return 0 on success or -1 on error ([V2RayNG/v2rayNG/V2rayNG/app/src/main/kotlin/com/v2ray/ang/service/V2RayVpnService.kt at master · v2ray/V2RayNG · GitHub](https://github.com/v2ray/V2RayNG/blob/master/v2rayNG/V2rayNG/app/src/main/kotlin/com/v2ray/ang/service/V2RayVpnService.kt#:~:text=override%20fun%20setup,)).

At service startup, the app creates a new `V2RayPoint` by calling the Go library’s factory and passing `this` (the service instance) as the support interface. For example:  
```kotlin
private val v2rayPoint = Libv2ray.newV2RayPoint(this, false)  // ‘false’ for adns (async DNS)
```  
(*Note:* In some versions of v2rayNG, the code might call `Libv2ray.newV2RayPoint()` without explicit arguments if default parameters were handled. But conceptually, it provides the service interface and a DNS mode flag to the Go library.) This call goes through JNI to `NewV2RayPoint(s, adns)` in Go, which stores the passed interface and returns a handle to a new core instance ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=func%20NewV2RayPoint,V2RayPoint)) ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=dialer%20%3A%3D%20NewProtectedDialer)).

The service then loads a JSON configuration (either built from user settings or a file) and calls `v2rayPoint.runLoop(prefIPv6: Boolean)` ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=%2F%2F%20RunLoop%20runs%20the%20V2Ray,main%20loop)) ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=v)) to start the Xray core. Internally, `RunLoop` in Go will call the interface’s `Prepare()` and `Setup()` methods to prepare the system VPN interface and routing before the core fully starts ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=v.closeChan%20%3D%20make%28chan%20struct)). This is where the callback happens: the Go code (running on a new goroutine) invokes `V2RayVPNServiceSupportsSet.Setup(conf)` which actually executes our Kotlin `V2RayVpnService.setup()` method – configuring the TUN interface via Android APIs ([V2RayNG/v2rayNG/V2rayNG/app/src/main/kotlin/com/v2ray/ang/service/V2RayVpnService.kt at master · v2ray/V2RayNG · GitHub](https://github.com/v2ray/V2RayNG/blob/master/v2rayNG/V2rayNG/app/src/main/kotlin/com/v2ray/ang/service/V2RayVpnService.kt#:~:text=fun%20setup%28parameters%3A%20String%29%20)) ([V2RayNG/v2rayNG/V2rayNG/app/src/main/kotlin/com/v2ray/ang/service/V2RayVpnService.kt at master · v2ray/V2RayNG · GitHub](https://github.com/v2ray/V2RayNG/blob/master/v2rayNG/V2rayNG/app/src/main/kotlin/com/v2ray/ang/service/V2RayVpnService.kt#:~:text=when%20%28it%5B0%5D%5B0%5D%29%20)) (setting IP address, routes, DNS, etc. using `VpnService.Builder`). Once that is done, the Go core begins processing network traffic. The `RunLoop` call in Go doesn’t return until the VPN is stopped; it effectively runs the event loop.

During operation, the Go core might call other interface methods: e.g., if the user stops the VPN or an error occurs, v2rayNG might call `v2rayPoint.stopLoop()`, which triggers Go to stop and then calls `Shutdown()` on the interface for cleanup ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=%2F%2F%20StopLoop%20stops%20the%20V2Ray,main%20loop)) ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=close%28v)). Or if the core needs to open a socket to a remote server, it will call the provided `Protect(fileDescriptor)` to exempt that socket from the VPN routing (the Kotlin service’s `protect(fd)` calls the system `protect()` and returns the result) ([V2RayNG/v2rayNG/V2rayNG/app/src/main/kotlin/com/v2ray/ang/service/V2RayVpnService.kt at master · v2ray/V2RayNG · GitHub](https://github.com/v2ray/V2RayNG/blob/master/v2rayNG/V2rayNG/app/src/main/kotlin/com/v2ray/ang/service/V2RayVpnService.kt#:~:text=override%20fun%20protect,toLong)). The `OnEmitStatus(code, msg)` function can be called by Go to send status updates – in the current implementation it just logs a message ([V2RayNG/v2rayNG/V2rayNG/app/src/main/kotlin/com/v2ray/ang/service/V2RayVpnService.kt at master · v2ray/V2RayNG · GitHub](https://github.com/v2ray/V2RayNG/blob/master/v2rayNG/V2rayNG/app/src/main/kotlin/com/v2ray/ang/service/V2RayVpnService.kt#:~:text=else%201%29)).

### Handling Multiple CPU ABIs in the App  
Since the AAR includes native libraries for four ABIs, v2rayNG configures Gradle to produce multiple APKs – one for each ABI, plus an all-in-one if needed. In the app’s `build.gradle`, ABI splits are enabled:  
```gradle
splits {
    abi {
        enable true
        include 'x86', 'x86_64', 'armeabi-v7a', 'arm64-v8a'
        universalApk true
    }
}
// Version code adjustments for each ABI:
project.ext.versionCodes = ['armeabi-v7a':1, 'arm64-v8a':2, 'x86':3, 'x86_64':4]
android.applicationVariants.all { variant ->
    // apply ABI-specific version code
    variant.outputs.each { output ->
        output.versionCode = project.ext.versionCodes.get(output.getFilter(OutputFile.ABI), 0) * 1000000 + android.defaultConfig.versionCode
    }
}
```  
This configuration ensures that when building release packages, Gradle will output separate APKs (e.g., one containing only arm64 libs, one for armeabi-v7a, etc.) each with a unique versionCode suffix ([V2RayNG/v2rayNG/V2rayNG/app/build.gradle at master · v2ray/V2RayNG · GitHub](https://github.com/v2ray/V2RayNG/blob/master/v2rayNG/V2rayNG/app/build.gradle#:~:text=include%20%27x86%27%2C%20%27x86_64%27%2C%20%27armeabi,ABIs%20to%20build%20APKs%20for)) ([V2RayNG/v2rayNG/V2rayNG/app/build.gradle at master · v2ray/V2RayNG · GitHub](https://github.com/v2ray/V2RayNG/blob/master/v2rayNG/V2rayNG/app/build.gradle#:~:text=project.ext.versionCodes%20%3D%20%5B%27armeabi,2%2C%20%27x86%27%3A%203%2C%20%27x86_64%27%3A%204)). The `universalApk true` also produces a combined APK with all libs (useful for direct distribution). Splitting by ABI greatly reduces the download size for users (since the Xray core .so for all ABIs combined can be 30+ MB). When installing, the Play Store or the user can choose the APK that matches their device’s ABI.

v2rayNG’s Gradle config also marks the `libv2ray` module as a dependency so that the .so files are packaged into the APK’s `lib/` folder automatically. No manual loading of .so is needed in code (the generated Java ensures `System.loadLibrary` is called).

### Assets and Configuration Data in v2rayNG  
As mentioned, v2rayNG does not bundle the large `geoip.dat` and `geosite.dat` files inside the AAR. Instead, it manages them at runtime. On first run or when updating, the app may download these files from a repository (e.g., Loyalsoldier’s v2ray-rules-dat on GitHub) and save them to `.../files/assets/geoip.dat` on external storage ([GitHub - 2dust/v2rayNG: A V2Ray client for Android, support Xray core and v2fly core](https://github.com/2dust/v2rayNG#:~:text=)). The **AndroidLibXrayLite** code is written to look for these files in the filesystem. The `InitV2Env(envPath, key)` function (if used) would tell the Go core where to find resource files. Typically, v2rayNG calls `Libv2ray.initV2Env(context.filesDir.path, "")` to set up the environment directory, and then places the dat files in an `assets` subdirectory there. The Xray core then reads geoip/geosite from those files when needed (for routing rules). This design allows the app to update geodata without rebuilding the AAR. 

**Summary of integration:** The Android app treats the Gomobile AAR as a black box library. It implements required interfaces and calls a few methods to start/stop the core. Thanks to Gomobile’s generated bindings, the cross-language calls (Kotlin ↔ Go) are as straightforward as calling any other library method.

## How Gomobile Works Under the Hood (Cross-Compilation & JNI Generation)  
Gomobile’s `bind` command automates what would otherwise be a complex process. Here’s a brief technical background on what happens when we run `gomobile bind` for Android:

- **Cross-compiling Go to ARM/ARM64/x86**: Gomobile leverages Go’s cross-compilation capabilities. It sets the appropriate environment (GOOS=android and GOARCH for each target ABI) and compiles the Go package into a shared library (.so). It uses the Android NDK compilers and linkers behind the scenes – `gomobile init` ensures it knows where to find them. By default, it compiles for `arm`, `arm64`, `386` (x86), and `amd64` (x86_64) ([v2raylib.aar · Issue #2277 · 2dust/v2rayNG · GitHub](https://github.com/2dust/v2rayNG/issues/2277#:~:text=package%20prefix%20for%20the%20generated,classes)). You can restrict ABIs via the `-target` flag (e.g., `-target=android/arm64,android/arm` to build only 32/64-bit ARM). The output for each arch is a file like `libgojni.so` (plus some intermediate libgojni.a during build).

- **Generating binding code (gobind)**: The real magic is in code generation. Gomobile uses a tool (internally `gobind`) to scan the Go package’s exported API and produce equivalent declarations in Java. It creates: 
  - **Java source files** for classes/interfaces corresponding to the Go types and functions. For example, it generates a `Libv2ray.java` with static methods and a `V2RayPoint.java` class with native method declarations for `runLoop`, etc. For the Go interface `V2RayVPNServiceSupportsSet`, it generates a Java interface and also some support code to allow a Java object to satisfy a Go interface. Under the hood, when you pass a Java object implementing that interface into a Go function, gobind creates a proxy Go object that forwards calls to Java. This involves reference tracking (that’s what the `go.Seq` class is for – it manages a table of cross-language object references) ([gomobile-java/bind/java/Seq.java at master · sridharv/gomobile-java · GitHub](https://github.com/sridharv/gomobile-java/blob/master/bind/java/Seq.java#:~:text=%2F%2F%20Seq%20is%20a%20sequence,dependent%20encoded%20values)) ([gomobile-java/bind/java/Seq.java at master · sridharv/gomobile-java · GitHub](https://github.com/sridharv/gomobile-java/blob/master/bind/java/Seq.java#:~:text=%2F%2F%20ctx%20is%20an%20android)).
  - **C/JNI code**: Gobind also emits C glue code that is compiled into the .so. This code registers JNI methods for each binding. For instance, when Java calls `V2RayPoint.runLoop()`, the call goes into a JNI function that calls the actual Go `RunLoop` method on the Go object. Conversely, when Go needs to call Java (like calling `SupportSet.Protect()`), there’s JNI support to call into the Java object’s method. Gobind handles both directions, ensuring exceptions or panics convert to errors, etc.

- **Packaging into an AAR**: After compiling the .so for all ABIs and compiling the Java code into .class files (Gomobile will invoke `javac` under the hood, using the Android API jar for references), it then packages everything. The AAR is structured per standard: a `classes.jar` (or classes.dex in some cases) for the Java bytecode, a `jni` folder with subfolders for each ABI containing the .so files, and metadata like `AndroidManifest.xml` (usually minimal or none for a pure code library). The default manifest from Gomobile is essentially empty or includes only required permissions if any (for Xray core, no special manifest entries are needed since it doesn’t declare components). The Gomobile tool then outputs this as `<pkg>.aar` ([v2raylib.aar · Issue #2277 · 2dust/v2rayNG · GitHub](https://github.com/2dust/v2rayNG/issues/2277#:~:text=file%20that%20archives%20the%20precompiled,This%20requires%20%27javac)).

- **Auto-loading the native library**: The generated Java code ensures the native library is loaded. As seen in the snippet from the Go mobile source, a class `go.LoadJNI` is generated which calls `System.loadLibrary("gojni")` in a static block ([bind/java/LoadJNI.java - mobile.git - Git at Google](https://go.googlesource.com/mobile.git/+/6fa95d984e88af20c7b8869192a2345dc560fdbf/bind/java/LoadJNI.java#:~:text=private%20static%20Logger%20log%20%3D,invoke%28null)) ([bind/java/LoadJNI.java - mobile.git - Git at Google](https://go.googlesource.com/mobile.git/+/6fa95d984e88af20c7b8869192a2345dc560fdbf/bind/java/LoadJNI.java#:~:text=static%20%7B%20System.loadLibrary%28,Exception%20e%29)). Additionally, the `Seq.java` static initializer will attempt to load `go.LoadJNI` class to trigger that loading ([gomobile-java/bind/java/Seq.java at master · sridharv/gomobile-java · GitHub](https://github.com/sridharv/gomobile-java/blob/master/bind/java/Seq.java#:~:text=static%20)). This means as soon as you touch any `libv2ray` class (which depends on `go.Seq`), the `libgojni.so` is loaded. The `LoadJNI` class also tries to get the Android application context and stores it in a static `ctx` field ([bind/java/LoadJNI.java - mobile.git - Git at Google](https://go.googlesource.com/mobile.git/+/6fa95d984e88af20c7b8869192a2345dc560fdbf/bind/java/LoadJNI.java#:~:text=Object%20androidCtx%20%3D%20null%3B%20try,finally)) – this context can be accessed on the Go side via a special function if needed (for example, if the Go library wanted to call Android APIs through JNI, it has a reference to the app context).

- **Memory and threading model**: Gomobile binds run the Go code on Go’s runtime (goroutine threads) and the Java code on the Android runtime threads. It’s important to note that when Go calls back into Java (e.g., `OnEmitStatus`), it’s actually executing on a Go native thread, not the Android main thread, so v2rayNG must handle thread-safety (in practice, they post UI updates from those callbacks if needed, or simply log them). The Gomobile binding takes care of attaching threads to the JVM as needed. Also, because Xray-core is heavily concurrent, it runs in background threads; the app’s main thread is not blocked when `runLoop()` is called – that call quickly returns and the core runs in a goroutine.

Gomobile abstracts these details, so as a developer you mostly see a clean Java API. But understanding this helps in debugging (for instance, knowing that panics in Go land will surface as Java exceptions of type `RuntimeException`).

## Best Practices and Caveats in Maintaining the Core Library  
**Updating the core**: v2rayNG’s core AAR can become outdated if the Xray-core project releases new versions. To update, you would pull the latest AndroidLibXrayLite code (or update its `go.mod` to a newer Xray-core tag) and rebuild the AAR. The version can be checked via `CheckVersionX()` at runtime ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=%2F%2F%20CheckVersionX%20returns%20the%20library,and%20V2Ray%20versions)). It’s recommended to rebuild with the latest Go compiler as well to get performance and security improvements. The process is deterministic via Gomobile, though sometimes minor code adjustments in the Go wrapper are needed if Xray-core’s API changed.

**Environment issues**: Ensure the Android NDK is compatible with Gomobile. The error example above ([Ubuntu下使用GoMobile构建AndroidLibXrayLite/AndroidLibV2rayLite的arr包 | kdsunset的个人博客](https://kdsunset.top/gomv2ray/index.html#:~:text=1)) shows that using an NDK that doesn’t match the expected API range will cause `gomobile bind` to fail. The fix was to use an NDK that supports API 21 and above (r21+). Also, on Windows, be careful with quoting in the `-ldflags='-s -w'` argument – the single quotes may need to be double quotes or escaped. If you see *“flag provided but not defined: -w”* it means the quotes weren’t handled properly by your shell ([v2raylib.aar · Issue #2277 · 2dust/v2rayNG · GitHub](https://github.com/2dust/v2rayNG/issues/2277#:~:text=When%20I%20try%20to%20use,I%20get%20the%20following%20error)).

**Library size**: The Xray core is sizable (the AAR can be tens of MB). Stripping symbols (`-s -w`) is already done ([Ubuntu下使用GoMobile构建AndroidLibXrayLite/AndroidLibV2rayLite的arr包 | kdsunset的个人博客](https://kdsunset.top/gomv2ray/index.html#:~:text=%2A%20,%E8%A1%A8%E7%A4%BA%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%EF%BC%8C%E8%A1%A8%E7%A4%BA%E5%B0%86%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%20Go%20%E5%8C%85%E7%BB%91%E5%AE%9A%E4%B8%BA%E7%A7%BB%E5%8A%A8%E5%BA%93%E3%80%82)), but you can further reduce size by enabling Go build tags to disable features you don’t need (for example, Xray-core has build tags to drop certain protocol support). However, v2rayNG typically includes most features. Another approach is using ABI splits (as v2rayNG does) so end-users only download what they need. Also, ProGuard (code shrinking) doesn’t really affect the AAR’s size, but you should keep the `go` and `libv2ray` classes intact (ProGuard rules are usually added to not strip native library loading calls).

**Stability**: Running a large Go library in Android is generally stable, but OOM can occur if mis-used. One known issue in the past was related to Go’s thread stack and `_cgo_topofstack` errors on older Go versions when used with Android API < 21. By targeting API 21+, those issues are resolved, and using up-to-date Go (1.18+ fixed many 64-bit issues for Android) is advised.

**Interface mapping quirks**: As seen, the `bool` returns became `long` in Java (`0` or `1`). This is an implementation detail of gobind (it doesn’t expose Go `bool` as Java `boolean` directly in interfaces for historical reasons). Developers should be mindful to return the expected values. Similarly, any `error` returned by Go becomes an exception in Java. For example, `MeasureOutboundDelay(...)` returns `(int64, error)` – in Java it might be two separate outputs or an exception if error; the exact mapping is documented in Gomobile’s docs.

**ABI compatibility**: The AAR’s .so libraries require certain CPU features. For instance, Xray-core may use AES-NI or NEON instructions. Gomobile/Go will emit code that checks at runtime and falls back if unavailable, so it’s usually fine. But ensure you don’t try to load an arm64 lib on an armv7 device, etc. (the split APK strategy prevents that).

**Development workflow**: For testing, you can include the AAR in debug builds. If you are actively modifying the Go code, you’d have to rebuild the AAR on every significant change. To speed up iteration, you could target a single ABI during local dev (e.g., only arm64) by using `gomobile bind -target=android/arm64`. This produces a smaller AAR quicker, which you can use on an arm64 emulator or device.

**Licensing**: AndroidLibXrayLite is LGPL-3.0, which requires that if you distribute a binary (APK) with it, you provide means to obtain the library’s source or object files for relinking. v2rayNG complies by being open-source and pointing users to the source. Just be aware to follow the license if you customize and redistribute.

## Conclusion  
By using Gomobile and the AndroidLibXrayLite wrapper, the v2rayNG project cleanly integrates a Go networking core into an Android app. The process involves cross-compiling Go to multiple architectures and generating JNI bindings packaged in an AAR ([v2raylib.aar · Issue #2277 · 2dust/v2rayNG · GitHub](https://github.com/2dust/v2rayNG/issues/2277#:~:text=For%20,This%20requires%20%27javac)). The AAR contains everything needed for the app to interact with the Go library as if it were a native Java library – loading the correct `.so` for the device and calling Go functions through Java methods. v2rayNG handles VPN setup by implementing the callback interface provided by the Go library, allowing the Go code to delegate Android-specific tasks (like setting up the VPN interface or protecting sockets) to Kotlin code. The use of ABI splits and external asset files helps optimize the app’s size and flexibility.

In summary, **the build workflow** is: prepare environment → use `gomobile bind` to produce libv2ray.aar → add it to the Android Studio project → implement required interfaces and calls in Kotlin. **The result** is an Android app powered by the Go Xray-core, with minimal friction between the two worlds. This approach is a powerful pattern for integrating Go libraries into mobile apps, but requires careful setup and understanding of the generated code. With the details outlined above, developers can confidently build and update the v2rayNG core, and even apply similar techniques to other Go libraries for Android.

**Sources:** The information above is drawn from the v2rayNG project README and wiki, the AndroidLibXrayLite repository, Gomobile documentation, and community guides. Key references include the AndroidLibXrayLite build instructions ([github.com-2dust-AndroidLibXrayLite_-_2024-10-09_07-47-31 : 2dust : Free Download, Borrow, and Streaming : Internet Archive](https://archive.org/details/github.com-2dust-AndroidLibXrayLite_-_2024-10-09_07-47-31#:~:text=Build%20instructions)) ([Ubuntu下使用GoMobile构建AndroidLibXrayLite/AndroidLibV2rayLite的arr包 | kdsunset的个人博客](https://kdsunset.top/gomv2ray/index.html#:~:text=gomobile%20bind%20,w%27)), the Gomobile tool usage description ([v2raylib.aar · Issue #2277 · 2dust/v2rayNG · GitHub](https://github.com/2dust/v2rayNG/issues/2277#:~:text=For%20,Import%20.JAR%20or)), and examples from v2rayNG’s code (VpnService implementation and Gradle config) ([AndroidLibXrayLite/libv2ray_main.go at main · 2dust/AndroidLibXrayLite · GitHub](https://github.com/2dust/AndroidLibXrayLite/blob/main/libv2ray_main.go#:~:text=%2F%2F%20V2RayVPNServiceSupportsSet%20is%20an%20interface,to%20support%20Android%20VPN%20mode)) ([V2RayNG/v2rayNG/V2rayNG/app/build.gradle at master · v2ray/V2RayNG · GitHub](https://github.com/v2ray/V2RayNG/blob/master/v2rayNG/V2rayNG/app/build.gradle#:~:text=include%20%27x86%27%2C%20%27x86_64%27%2C%20%27armeabi,ABIs%20to%20build%20APKs%20for)), as well as a developer blog detailing the build process on Ubuntu ([Ubuntu下使用GoMobile构建AndroidLibXrayLite/AndroidLibV2rayLite的arr包 | kdsunset的个人博客](https://kdsunset.top/gomv2ray/index.html#:~:text=%E8%80%90%E5%BF%83%E7%AD%89%E5%BE%85%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%88%90%EF%BC%8C%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%88%90%E5%90%8E%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E7%9A%84%20%60libv2ray.aar%20%60%E5%92%8C%20%60libv2ray)) ([Ubuntu下使用GoMobile构建AndroidLibXrayLite/AndroidLibV2rayLite的arr包 | kdsunset的个人博客](https://kdsunset.top/gomv2ray/index.html#:~:text=1)). These provide a concrete foundation for the step-by-step guide and technical insights presented here.